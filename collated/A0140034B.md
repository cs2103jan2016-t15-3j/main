# A0140034B
###### \ArchPlanner\application\application.css
``` css

#_mainWindow {
    -fx-background-color: transparent;
}

#_taskWindow {
	-fx-background-color: white;
	-fx-background-radius: 20;
	
	-fx-border-radius: 15;
  	-fx-border-width: 8;
	-fx-border-color: #651b1b;
}

#_feedbackWindow {
	-fx-background-color: rgba(0, 0, 0, 0.8);
	-fx-background-radius: 20;
}

#_categoryPane {
	-fx-background-radius: 15;
	-fx-background-color: rgba(0, 0, 0, 0.05);
}

#_userInputTextField {
	-fx-background-radius: 20;
	
	-fx-border-radius: 15;
  	-fx-border-width: 8;
	-fx-border-color: #651b1b;
	
	-fx-font-size: 2em;
	-fx-focus-color: transparent;
	-fx-faint-focus-color: transparent;
}

#_scopeOfViewLabel {
	-fx-font-size: 2.5em;
	-fx-text-fill: black;
	-fx-padding: 20 0 0 0;
}

#_feedbackLabel {
	-fx-text-fill: white;
}

#_topPromptLabel, #_bottomPromptLabel{
	-fx-background-color: rgba(0, 0, 0, 0.8);
	-fx-background-radius: 20; 
    -fx-text-fill: white;
	-fx-padding: 10 25 10 25;
	-fx-font: 1.2em System;
}

#_maxiButton {
	-fx-background-image: url('/images/MaxiImage.png');
	-fx-background-size: 100% 100%;
}

#_miniButton {
	-fx-background-image: url('/images/MiniImage.png');
	-fx-background-size: 100% 100%;
}

#_closeButton {
	-fx-background-image: url('/images/CloseImage.png');
	-fx-background-size: 100% 100%;
}

#_backButton {
	-fx-background-image: url('/images/BackImage.png');
	-fx-background-size: 100% 100%;
}

.label {
	-fx-font-size: 1.5em;
    -fx-font-family: "Tempus Sans ITC";
    -fx-text-fill: black;
    -fx-padding: 0 10 0 10;
}

.toggle-button {
	-fx-font-size: 1.5em;
    -fx-font-family: "Tempus Sans ITC";
    -fx-text-fill: black;
    
	-fx-background-radius: 15;	
	-fx-background-color: lightgrey;
}

.toggle-button:selected {
	-fx-text-fill: white;
	-fx-background-color: grey;
}

.context-menu .label {
  	-fx-font-size: 0.8em;
  	-fx-font-family: "System";
}

.tooltip {
	-fx-font-size: 1.5em;
}

.list-cell {
    -fx-background-color: transparent;
}

.button {
	-fx-background-color: lightgrey;
	-fx-background-radius: 50%;
}

.button:pressed {
	-fx-background-color: grey;
}

.list-view {
	-fx-background-radius: 15;
	-fx-background-color: rgba(0, 0, 0, 0.05);
}

/* The main scroll-bar */
.list-view .scroll-bar {
	-fx-background-color: transparent;
	-fx-padding:5 5 5 0;
}

/* The increment and decrement button in scrollbar */
.list-view .scroll-bar .increment-button,
.list-view .scroll-bar .decrement-button {
    -fx-background-color:transparent;
    -fx-padding: 2px;
}

/* The main scroll-bar which user interact with*/
.list-view .scroll-bar:horizontal .thumb,
.list-view .scroll-bar:vertical .thumb {
    -fx-background-color:derive(black,90%);
	-fx-background-radius: 2em;
}
```
###### \ArchPlanner\application\MainController.java
``` java
 */
public class MainController implements Initializable{ 
    static Logger log = Logger.getLogger(MainController.class.getName());
    
    private static final String LOG_MESSAGE_SETTING_DEFAULT_WINDOW_SIZE = "Setting default window size";
    private static final String LOG_MESSAGE_SETTING_PERIODIC_REFRESH = "Setting periodic refresh to display";
    private static final String LOG_MESSAGE_INITIALIZING_TEXTFIELD = "Initializing TextField";
    private static final String LOG_MESSAGE_MAINCONTROLLER_INITIALIZED = "MainController initialized";   
    private static final String LOG_MESSAGE_MINIMIZE_BUTTON_CLICKED = "Minimize button clicked";
    private static final String LOG_MESSAGE_MAX_BUTTON_CLICKED = "Maximize/Restore button clicked";
    private static final String LOG_MESSAGE_CLOSED_BUTTON_CLICKED = "Close button clicked";
    private static final String LOG_MESSAGE_BACK_BUTTON_CLICKED = "Back button clicked";
    private static final String LOG_MESSAGE_CATEGORY_BUTTON_CLICKED = "Category button clicked: ";
    private static final String LOG_MESSAGE_TAG_BUTTON_CLICKED = "Tag button clicked: ";
    private static final String LOG_MESSAGE_ENTER_PRESSED = "Enter Pressed";
    private static final String LOG_MESSAGE_COMMAND_EXECUTION_SUCCESS = "Command execution success";
    private static final String LOG_MESSAGE_COMMAND_EXECUTION_FAILED = "Command execution failed";
    private static final String LOG_MESSAGE_DISPLAYING_FEEDBACK_WINDOW = "Displaying feedback window";
    private static final String LOG_MESSAGE_LIGHTING_UP_TASK = "Lighting up tasks";
    private static final String LOG_MESSAGE_PROMPT_HIDE = "Prompt hide";
    private static final String LOG_MESSAGE_PROMPT_DISPLAY = "Prompt display";
    private static final String LOG_MESSAGE_PROMPT_EMPTY = "Prompt empty";
    private static final String LOG_MESSAGE_REFRESHING_TASKS_DISPLAY = "Refreshing Tasks Display";
    private static final String LOG_MESSAGE_REFRESHING_TAGS_DISPLAY = "Refreshing Tags Display";
    private static final String LOG_MESSAGE_REFRESHING_CATEGORY_DISPLAY = "Refreshing Category Display";
    
    private static final String STRING_EMPTY = "";
    private static final String STRING_NEW_LINE = "\n";
    private static final String STRING_FAILED = "Failed";
    private static final String STRING_SUCCESS = "Success";
    
    private static final String SIMULATE_REDO = "redo";
    private static final String SIMULATE_UNDO = "undo";
    
    private static final String FILE_PATH_FAIL_IMAGE = "/images/FailIcon.png";
    private static final String FILE_PATH_SUCCESS_IMAGE = "/images/SuccessIcon.png";
    
    private static final String FX_WINDOW_DEFAULT_BACKGROUND_COLOR = "-fx-background-color: transparent;";
    private static final String FX_WINDOW_FULL_SCREEN_BACKGROUND_COLOR = "-fx-background-color: #651b1b;";
    private static final String FX_TASK_LIGHT_UP_COLOR = "-fx-background-color: yellow;";

    private static final int DELAY_IN_MS_DISPLAY_REFRESH = 60000;
    private static final int DELAY_IN_MS_TASKS_LIGHT_UP = 2000;
    private static final int DELAY_IN_MS_FEEDBACK_DISPLAY = 1500;
    private static final int DELAY_IN_MS_FEEDBACK_FADE_AWAY = 500;
    
    private static final double RATIO_OF_WIDTH = 0.6;
    private static final double RATIO_OF_HEIGHT = 0.8;
    
    private static final int FIRST_CHANGED_TASK = 0;      
    private static final int OPACITY_MIN = 0;
    private static final int OPACITY_MAX = 1;
    private static final int INDEX_INITIAL = 0; 
    private static final int INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER = 1;
    private static final int INDEX_NEXT = 1;
    private static final int PROMPTS_INDEX_MIN = 0;
    private static final int PROMPTS_INDEX_MAX = 4;
    private static final int PROMPT_BOX_MAX_HEIGHT = 140;
    
    // mainWindow contains all Windows
    @FXML private StackPane _mainWindow;
    // visibleWindow contains taskWindow and userInputTextField
    @FXML private GridPane _visibleWindow;
    // taskWindow contains category, tag, and task Pane, all windows modification buttons and scopeofViewLabel
    @FXML private GridPane _taskWindow;
    // feedbackWindows contains feedbackLabel and feedbackIcon
    @FXML private GridPane _feedbackWindow; 
    
    @FXML private Label _scopeOfViewLabel;
    @FXML private Label _topPromptLabel;
    @FXML private Label _bottomPromptLabel;
    @FXML private Label _feedbackLabel;

    @FXML private Button _miniButton;
    @FXML private Button _maxiButton;
    @FXML private Button _closeButton;
    @FXML private Button _backButton;

    @FXML private ToggleButton _eventTButton;
    @FXML private ToggleButton _deadlineTButton;
    @FXML private ToggleButton _taskTButton;  
    
    @FXML private TextField _userInputTextField;
    
    @FXML private ListView<ToggleButton> _tagListView;
    @FXML private ListView<GridPane> _taskListView;
    
    @FXML private ImageView _feedbackIcon;
 
    private ArrayList<Tag> _tags = new ArrayList<Tag>();
    private ArrayList<Task> _tasks = new ArrayList<Task>();
    
    private ObservableList<ToggleButton> _tagList = FXCollections.observableArrayList();
    private ObservableList<GridPane> _taskList = FXCollections.observableArrayList();
    
    private double _xCoordinate, _yCoordinate;
    private Rectangle2D _screenBound;
    
    private Image _successIcon;
    private Image _failIcon;
    
    private CATEGORY_TYPE _categorySelected;
    
    private SequentialTransition _fadeTransition;
    
    private Logic _logic;
    private Interpreter _interpreter;
    
    @Override
    public void initialize(URL arg0, ResourceBundle arg1) {              
        initPrompt();
        initLogic();   
        initFeedbackItems();
        
        _screenBound = Screen.getPrimary().getVisualBounds();
        setDefaultWindowSize(_mainWindow, _screenBound);
        
        _tagListView.setItems(_tagList);
        _taskListView.setItems(_taskList);
        updateUi(_logic);
        
        initTextField(_userInputTextField);
        
        setPeriodicRefreshToDisplay(_logic);    

        log.info(LOG_MESSAGE_MAINCONTROLLER_INITIALIZED);
    }

    private void initLogic() {
        _logic = new Logic();
    }

    private void initPrompt() {
        _interpreter = new Interpreter();
    }

    private void initFeedbackItems() {
        _fadeTransition = new SequentialTransition();
        _successIcon = new Image(FILE_PATH_SUCCESS_IMAGE);
        _failIcon = new Image(FILE_PATH_FAIL_IMAGE);
    }

    private void setDefaultWindowSize(Pane node, Rectangle2D screenBound) {
        log.info(LOG_MESSAGE_SETTING_DEFAULT_WINDOW_SIZE);
        
        int width = (int) (screenBound.getMaxX() * RATIO_OF_WIDTH);
        int height = (int) (screenBound.getMaxY() * RATIO_OF_HEIGHT);
        node.setPrefSize(width, height);
    }
    
    private void setPeriodicRefreshToDisplay(Logic logic) {
        log.info(LOG_MESSAGE_SETTING_PERIODIC_REFRESH);
        
        Timeline timeline = new Timeline(new KeyFrame(Duration.millis(DELAY_IN_MS_DISPLAY_REFRESH), timesUp -> {
            logic.updateViewList();
            updateUi(logic);
        }));
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }
    
    private void initTextField(TextField userInputTextField) {
        log.info(LOG_MESSAGE_INITIALIZING_TEXTFIELD);
        
        userInputTextField.textProperty().addListener(new ChangeListener<String>() {
            public void changed(ObservableValue<? extends String> observable, String oldString, String newString) {
                onTextChanged(newString);
            }
        });
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                setTextFieldFocus(userInputTextField);
            }
        });
    }
    
    /**
     * set the initial position of mouse coordinates.
     * 
     * @param event     mouse clicked on taskWindow.
     */
    @FXML
    private void onWindowPressed(MouseEvent event) {
        Stage stage = (Stage) _taskWindow.getScene().getWindow();
        if (!stage.isFullScreen()) {
            _xCoordinate = stage.getX() - event.getScreenX();
            _yCoordinate = stage.getY() - event.getScreenY();
        }
    }
    
    /**
     * set the stage coordinates to move window when drag.
     * 
     * @param event     mouse dragged on taskWindow.
     */
    @FXML
    private void onWindowDragged(MouseEvent event) {
        Stage stage = (Stage) _taskWindow.getScene().getWindow();
        if (!stage.isFullScreen()) {
            stage.setX(event.getScreenX() + _xCoordinate);
            stage.setY(event.getScreenY() + _yCoordinate);
        } 
    }
    
    /** miniButton clicked to minimize window. */
    @FXML
    private void minimize() {
        log.info(LOG_MESSAGE_MINIMIZE_BUTTON_CLICKED);
        
        ((Stage) _miniButton.getScene().getWindow()).setIconified(true);
        setTextFieldFocus(_userInputTextField);
    }
    
    /** maxiButton clicked to maximize or restore window. */
    @FXML
    private void maxOrRestore() {
        log.info(LOG_MESSAGE_MAX_BUTTON_CLICKED);
        
        Stage stage = (Stage) _maxiButton.getScene().getWindow();
        if (!stage.isFullScreen()) {
            maxWindowSize();
        } else {
            restoreWindowSize();
        }
        setTextFieldFocus(_userInputTextField);
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                onTextChanged(_userInputTextField.getText());
            }
        });
    }
    
    private void maxWindowSize() {
        Stage stage = (Stage) _maxiButton.getScene().getWindow();
        stage.setFullScreen(true);
        stage.setHeight(_screenBound.getMaxY() + PROMPT_BOX_MAX_HEIGHT);
        _visibleWindow.setStyle(FX_WINDOW_FULL_SCREEN_BACKGROUND_COLOR);
    }
    
    private void restoreWindowSize() {
        Stage stage = (Stage) _maxiButton.getScene().getWindow();
        stage.setFullScreen(false);
        _visibleWindow.setStyle(FX_WINDOW_DEFAULT_BACKGROUND_COLOR);
    }
    
    /** closeButton clicked to close program. */
    @FXML
    private void close() {
        log.info(LOG_MESSAGE_CLOSED_BUTTON_CLICKED);
        
        ((Stage) _closeButton.getScene().getWindow()).close();
    }
    
     /** switch scope of view to view all tasks. */
    @FXML
    private void back() {
        log.info(LOG_MESSAGE_BACK_BUTTON_CLICKED);
        
        _logic.setSelectedCategory(CATEGORY_TYPE.ALL);
        updateUi(_logic);        
        setTextFieldFocus(_userInputTextField);
    }
    
    /**
     * verify the category clicked and send to Logic to update display.
     * 
     * @param event     the category clicked.
     */
    @FXML
    private void onCategoryPressed(ActionEvent event) {
        log.info(LOG_MESSAGE_CATEGORY_BUTTON_CLICKED + event.getSource().toString());
        
        ToggleButton clicked = (ToggleButton)event.getSource();
        if (clicked.isSelected()) {
            _logic.setSelectedCategory(_logic.getCategoryType(clicked.getText()));
        } else {
            _logic.setSelectedCategory(CATEGORY_TYPE.ALL);
        }   
        updateUi(_logic);        
        setTextFieldFocus(_userInputTextField);
    }
    
    /**
     * verify the tag clicked and inform Logic to update display.
     * 
     * @param event     the tag clicked.
     */
    private void onTagPressed(ActionEvent event) {
        log.info(LOG_MESSAGE_TAG_BUTTON_CLICKED + event.getSource().toString());
        
        TagButton clicked = (TagButton)event.getSource();
        _logic.setSelectedTag(clicked.getText(), clicked.isSelected());
        updateUi(_logic);        
        setTextFieldFocus(_userInputTextField);
    }
    
    /** enter pressed in userInputTextField and send text in TextField for execution. */
    @FXML
    private void onEnterPressed() {
        log.info(LOG_MESSAGE_ENTER_PRESSED);
        
        executeCommand(_userInputTextField.getText());
    }
    
    /**
     * send text to Logic for execution and feedback to user the status of the command.
     * 
     * @param input     the string of command to be processed.
     */
    private void executeCommand(String input) {
        CommandInterface command = _logic.executeCommand(input);
        
        if (command instanceof InvalidCommand) {
            log.info(LOG_MESSAGE_COMMAND_EXECUTION_FAILED);
            
            setFeedbackWindow(false, command.getMessage());
        } else {
            log.info(LOG_MESSAGE_COMMAND_EXECUTION_SUCCESS);
            
            updateUi(_logic);
            if (!(command instanceof ViewCommand)) {
                setFeedbackWindow(true, command.getMessage());
                lightUpTasksChange(_logic);
            }
            _userInputTextField.clear();
        }
    }
    
    /**
     * show Feedback window to user the status of the command.
     * 
     * @param isSuccessful  the status of the command.
     * @param message       the message to display to user.
     */
    private void setFeedbackWindow(boolean isSuccessful, String message) {
        log.info(LOG_MESSAGE_DISPLAYING_FEEDBACK_WINDOW);
        
        if (isSuccessful) {
            _feedbackIcon.setImage(_successIcon);
            _feedbackLabel.setText(STRING_SUCCESS + STRING_NEW_LINE + message);
        } else {
            _feedbackIcon.setImage(_failIcon);
            _feedbackLabel.setText(STRING_FAILED + STRING_NEW_LINE + message);
        }
        createFader(_feedbackWindow);
    }
    
    /**
     * create a transition for Feedback window to display and fade away.
     * 
     * @param node  the window to display and fade away.
     */
    private void createFader(Node node) {
        _fadeTransition.stop();
        node.setVisible(true);
        
        PauseTransition pause = new PauseTransition(Duration.millis(DELAY_IN_MS_FEEDBACK_DISPLAY));
        FadeTransition fade = new FadeTransition(Duration.millis(DELAY_IN_MS_FEEDBACK_FADE_AWAY), node);
        fade.setFromValue(OPACITY_MAX);
        fade.setToValue(OPACITY_MIN);
        
        _fadeTransition.setOnFinished(new EventHandler<ActionEvent>() {
            @Override 
            public void handle(ActionEvent event) {
                node.setVisible(false);
            }
        });
        _fadeTransition.getChildren().remove(INDEX_INITIAL, _fadeTransition.getChildren().size());
        _fadeTransition.getChildren().addAll(pause, fade);
        _fadeTransition.play();
    }
    
    /**
     * show Feedback window to user the status of the command.
     *
     * @param logic     to get the index of the tasks to light up
     */
    private void lightUpTasksChange(Logic logic) {
        log.info(LOG_MESSAGE_LIGHTING_UP_TASK);
        
        ArrayList<Integer> tasksChanged = logic.getIndexList();
        if (tasksChanged != null && !tasksChanged.isEmpty()) {
            _taskListView.layout();
            _taskListView.applyCss();
            for (int i = INDEX_INITIAL; i < tasksChanged.size(); i++) {
                fillTransition((TaskPane)_taskListView.getItems().get(tasksChanged.get(i)));
            }
            _taskListView.scrollTo(tasksChanged.get(FIRST_CHANGED_TASK));
        }
    }
    
    /**
     * light up task for a duration.
     * 
     * @param taskLabel     the task that will be lighted up.
     */
    private void fillTransition(TaskPane taskLabel) {
        String defaultStyleOfTask = taskLabel.getStyle();
        taskLabel.setStyle(defaultStyleOfTask + FX_TASK_LIGHT_UP_COLOR);

        PauseTransition pause = new PauseTransition(Duration.millis(DELAY_IN_MS_TASKS_LIGHT_UP));
        pause.setOnFinished(new EventHandler<ActionEvent>() {
            @Override 
            public void handle(ActionEvent event) {
                taskLabel.setStyle(defaultStyleOfTask);
                taskLabel.applyCss();
                taskLabel.layout();
            }
        });
        pause.play();
    } 
    
    /**
     * keys to help user input command in TextField.
     * 
     * @param event     the key that is released in userInputTextField.
     */
    @FXML
    private void onKeyReleased(KeyEvent event) {    
        String autoInput = STRING_EMPTY;
        switch (event.getCode()) {
            case UP : 
                autoInput = _logic.getPreviousUserInput();
                if (autoInput.isEmpty()) {
                    autoInput = _userInputTextField.getText();
                }
                _userInputTextField.setText(autoInput);
                setTextFieldFocus(_userInputTextField);
                break;
                
            case DOWN :
                autoInput = _logic.getNextUserInput();
                _userInputTextField.setText(autoInput);
                setTextFieldFocus(_userInputTextField);
                break;
                
            case TAB :
                autoInput = _interpreter.getAutoComplete(_userInputTextField.getText());
                _userInputTextField.setText(autoInput);
                setTextFieldFocus(_userInputTextField);
                break;
                
            default :
                break;
        } 
    }
    
    /**
     * hotkeys to help user execute a command.
     * 
     * @param event     the keys that is pressed in userInputTextField.
     */
    @FXML
    private void onKeyPressed(KeyEvent event) {
        if (event.isControlDown()) {
            switch(event.getCode()) {
                case D :
                    _deadlineTButton.fire();
                    break;
                case E :
                    _eventTButton.fire();
                    break;
                case T :
                    _taskTButton.fire();
                    break;
                case Y :
                    executeCommand(SIMULATE_REDO);
                    break;
                case Z :
                    executeCommand(SIMULATE_UNDO);
                    break;
                default:
                    break;
            }
        } else if (event.getCode() == KeyCode.TAB || event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN) {
            event.consume();
        } else if (event.getCode() == KeyCode.ESCAPE) {
            restoreWindowSize();
        }
    }
    
    /**
     * display prompts to user depending of the text in the TextField.
     * 
     * @param newString     the changed text in userInputTextField.
     */
    private void onTextChanged(String newString) {
        if (newString.isEmpty()) {
            log.info(LOG_MESSAGE_PROMPT_HIDE);
            
            hidePrompt();
        } else {
            log.info(LOG_MESSAGE_PROMPT_DISPLAY);
            
            setPrompt(newString);
            showPrompt();
        }
    }
    
    private void hidePrompt() {
        _topPromptLabel.setVisible(false);
        _bottomPromptLabel.setVisible(false);
    }
    
    /** show prompts bottom or top of userInputTextfield depending if prompt is out of screen. */
    private void showPrompt() {
        // get snapshot of node so height can be calculated
        _bottomPromptLabel.getScene().snapshot(null);
        
        double bottomIndexOfVisibleWindow =_mainWindow.localToScreen(_mainWindow.getBoundsInLocal()).getMaxY() - PROMPT_BOX_MAX_HEIGHT;
        double heightOfPromptBox = _bottomPromptLabel.getHeight();

        if (bottomIndexOfVisibleWindow + heightOfPromptBox > _screenBound.getMaxY()) {
            _topPromptLabel.setVisible(true);
            _bottomPromptLabel.setVisible(false);
        } else {
            _topPromptLabel.setVisible(false);
            _bottomPromptLabel.setVisible(true);
        }
    }
    
    private void setPrompt(String newString) {
        ArrayList<String> prompt = _interpreter.getPrompts(newString);
        assert(prompt.size() > PROMPTS_INDEX_MIN && prompt.size() <= PROMPTS_INDEX_MAX);
        
        if (prompt != null && !prompt.isEmpty()) {
            _topPromptLabel.setText(prompt.get(PROMPTS_INDEX_MIN));
            _bottomPromptLabel.setText(prompt.get(PROMPTS_INDEX_MIN));
            for (int i  = PROMPTS_INDEX_MIN + INDEX_NEXT; i < prompt.size(); i++) {
                _topPromptLabel.setText(prompt.get(i) + STRING_NEW_LINE + _topPromptLabel.getText());
                _bottomPromptLabel.setText(_bottomPromptLabel.getText() + STRING_NEW_LINE + prompt.get(i));
            }
        } else {
            log.warning(LOG_MESSAGE_PROMPT_EMPTY);
        }
    }

    private void updateUi(Logic logic) {
        assert(logic.getViewList() != null);
        assert(logic.getTagsList() != null);
        assert(logic.getSelectedCategory() != null);
        assert(logic.getCurrentViewType() != null);
        
    	_tasks = logic.getViewList();
    	updateTaskPane(_tasks);
    	
        _tags = logic.getTagsList();
        updateTagPane(_tags);
        
        _categorySelected = logic.getSelectedCategory();
        updateCategoryPane(_categorySelected);
        
        _scopeOfViewLabel.setText(logic.getCurrentViewType());
        displayBackButton(_scopeOfViewLabel.getText());
    }
    
    private void updateTaskPane(ArrayList<Task> tasks) {
        log.info(LOG_MESSAGE_REFRESHING_TASKS_DISPLAY);
        
        _taskList.clear();      
        for (int i = INDEX_INITIAL; i < tasks.size(); i++) {        
            TaskPane displayTask = new TaskPane(i + INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER, tasks.get(i), _taskListView.widthProperty());
            _taskList.add(displayTask);
        }
    }
    
    private void updateTagPane(ArrayList<Tag> tags) {
        log.info(LOG_MESSAGE_REFRESHING_TAGS_DISPLAY);
        
        _tagList.clear();       
        for (int i = INDEX_INITIAL; i < tags.size(); i++) {
            TagButton tagButton = new TagButton(tags.get(i), _tagListView.widthProperty());
            tagButton.setOnAction(tagObj -> {
                onTagPressed(tagObj);
            });
            _tagList.add(tagButton);
        }
    }
    
    private void updateCategoryPane(CATEGORY_TYPE categorySelected) {
        log.info(LOG_MESSAGE_REFRESHING_CATEGORY_DISPLAY);
        
        switch (categorySelected) {
            case ALL :
                _eventTButton.setSelected(false);
                _deadlineTButton.setSelected(false);
                _taskTButton.setSelected(false);
                break;
            case EVENTS :
                _eventTButton.setSelected(true);
                break;
            case DEADLINES :
                _deadlineTButton.setSelected(true);
                break;
            case TASKS :
                _taskTButton.setSelected(true);
                break;
        }
    }

    private void displayBackButton(String scopeOfView) {
        if (!scopeOfView.trim().equalsIgnoreCase(VIEW_TYPE.ALL.toString())) {
            _backButton.setVisible(true);
        } else {
            _backButton.setVisible(false);
        }
    }
    
    private void setTextFieldFocus(TextField textField) {
        textField.requestFocus();
        textField.end();
    }
}
```
###### \ArchPlanner\application\MainWindow.fxml
``` fxml

<StackPane fx:id="_mainWindow" prefHeight="500.0" prefWidth="700.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="application.MainController">
   <children>
      <GridPane>
        <columnConstraints>
          <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
        </columnConstraints>
        <rowConstraints>
          <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
          <RowConstraints maxHeight="140.0" minHeight="140.0" prefHeight="140.0" vgrow="SOMETIMES" />
        </rowConstraints>
         <children>
            <GridPane fx:id="_visibleWindow" onMouseDragged="#onWindowDragged" onMousePressed="#onWindowPressed">
              <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
              </columnConstraints>
              <rowConstraints>
                <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
                <RowConstraints maxHeight="10.0" minHeight="10.0" prefHeight="10.0" vgrow="SOMETIMES" />
                <RowConstraints maxHeight="70.0" minHeight="70.0" prefHeight="70.0" vgrow="SOMETIMES" />
              </rowConstraints>
               <children>
                  <GridPane fx:id="_taskWindow">
                     <columnConstraints>
                        <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
                     </columnConstraints>
                     <rowConstraints>
                        <RowConstraints maxHeight="50.0" minHeight="50.0" prefHeight="50.0" vgrow="SOMETIMES" />
                        <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
                     </rowConstraints>
                     <children>
                        <GridPane>
                           <columnConstraints>
                              <ColumnConstraints hgrow="SOMETIMES" maxWidth="120.0" minWidth="120.0" prefWidth="120.0" />
                              <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
                              <ColumnConstraints hgrow="SOMETIMES" maxWidth="120.0" minWidth="120.0" prefWidth="120.0" />
                           </columnConstraints>
                           <rowConstraints>
                              <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
                           </rowConstraints>
                           <children>
                              <GridPane alignment="CENTER" GridPane.columnIndex="2">
                                 <columnConstraints>
                                    <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" percentWidth="33.0" prefWidth="100.0" />
                                    <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" percentWidth="33.0" prefWidth="100.0" />
                                    <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" percentWidth="34.0" prefWidth="100.0" />
                                 </columnConstraints>
                                 <rowConstraints>
                                    <RowConstraints vgrow="SOMETIMES" />
                                 </rowConstraints>
                                 <children>
                                    <Button fx:id="_miniButton" alignment="CENTER" maxHeight="30.0" maxWidth="30.0" minHeight="30.0" minWidth="30.0" mnemonicParsing="false" onAction="#minimize" prefHeight="30.0" prefWidth="30.0" textAlignment="CENTER" GridPane.halignment="CENTER">
                                       <font>
                                          <Font name="System Bold" size="15.0" />
                                       </font>
                                    </Button>
                                    <Button fx:id="_maxiButton" alignment="CENTER" maxHeight="30.0" maxWidth="30.0" minHeight="30.0" minWidth="30.0" mnemonicParsing="false" onAction="#maxOrRestore" prefHeight="30.0" prefWidth="30.0" GridPane.columnIndex="1" GridPane.halignment="CENTER" />
                                    <Button fx:id="_closeButton" alignment="CENTER" maxHeight="30.0" maxWidth="30.0" minHeight="30.0" minWidth="30.0" mnemonicParsing="false" onAction="#close" prefHeight="30.0" prefWidth="30.0" textAlignment="CENTER" GridPane.columnIndex="2" GridPane.halignment="CENTER">
                                       <font>
                                          <Font name="System Bold" size="15.0" />
                                       </font>
                                    </Button>
                                 </children>
                                 <padding>
                                    <Insets right="10.0" />
                                 </padding>
                              </GridPane>
                              <Label fx:id="_scopeOfViewLabel" alignment="CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" onMouseDragged="#onWindowDragged" onMousePressed="#onWindowPressed" text="ALL" GridPane.columnIndex="1">
                                 <font>
                                    <Font size="24.0" />
                                 </font>
                                 <opaqueInsets>
                                    <Insets />
                                 </opaqueInsets>
                                 <padding>
                                    <Insets top="10.0" />
                                 </padding>
                              </Label>
                              <Button fx:id="_backButton" maxHeight="30.0" maxWidth="30.0" minHeight="30.0" minWidth="30.0" mnemonicParsing="false" onAction="#back" prefHeight="30.0" prefWidth="30.0" textAlignment="CENTER" translateX="10.0" visible="false">
                                 <font>
                                    <Font name="Agency FB Bold" size="15.0" />
                                 </font>
                              </Button>
                           </children>
                           <opaqueInsets>
                              <Insets />
                           </opaqueInsets>
                        </GridPane>
                        <GridPane fx:id="taskPane" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" GridPane.rowIndex="1">
                          <columnConstraints>
                            <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" percentWidth="20.0" prefWidth="100.0" />
                              <ColumnConstraints hgrow="SOMETIMES" maxWidth="10.0" minWidth="10.0" prefWidth="10.0" />
                            <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
                          </columnConstraints>
                          <rowConstraints>
                            <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
                          </rowConstraints>
                           <children>
                              <GridPane>
                                <columnConstraints>
                                  <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
                                </columnConstraints>
                                <rowConstraints>
                                  <RowConstraints maxHeight="-Infinity" minHeight="-Infinity" vgrow="SOMETIMES" />
                                  <RowConstraints maxHeight="10.0" minHeight="10.0" prefHeight="0.0" vgrow="SOMETIMES" />
                                  <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
                                </rowConstraints>
                                 <children>
                                    <VBox fx:id="_categoryPane" spacing="8.0">
                                       <children>
                                          <ToggleButton fx:id="_eventTButton" alignment="BOTTOM_LEFT" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#onCategoryPressed" text="Events">
                                             <toggleGroup>
                                                <ToggleGroup fx:id="categories" />
                                             </toggleGroup>
                                          </ToggleButton>
                                          <ToggleButton fx:id="_deadlineTButton" alignment="CENTER_LEFT" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#onCategoryPressed" text="Deadlines" toggleGroup="$categories" />
                                          <ToggleButton fx:id="_taskTButton" alignment="CENTER_LEFT" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#onCategoryPressed" text="Tasks" toggleGroup="$categories" />
                                       </children>
                                       <padding>
                                          <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                                       </padding>
                                    </VBox>
                                    <ListView fx:id="_tagListView" focusTraversable="false" GridPane.rowIndex="2">
                                       <padding>
                                          <Insets bottom="5.0" top="5.0" />
                                       </padding>
                                    </ListView>
                                 </children>
                              </GridPane>
                              <ListView fx:id="_taskListView" focusTraversable="false" GridPane.columnIndex="2">
                                 <padding>
                                    <Insets bottom="5.0" top="5.0" />
                                 </padding>
                              </ListView>
                           </children>
                           <padding>
                              <Insets bottom="10.0" left="10.0" right="10.0" top="15.0" />
                           </padding>
                        </GridPane>
                     </children>
                  </GridPane>
                  <TextField fx:id="_userInputTextField" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" onAction="#onEnterPressed" onKeyPressed="#onKeyPressed" onKeyReleased="#onKeyReleased" GridPane.rowIndex="2">
                     <font>
                        <Font size="24.0" />
                     </font>
                  </TextField>
               </children>
            </GridPane>
         </children>
      </GridPane>
      <GridPane alignment="BOTTOM_LEFT" pickOnBounds="false">
        <columnConstraints>
          <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="100.0" />
        </columnConstraints>
        <rowConstraints>
          <RowConstraints maxHeight="-Infinity" minHeight="-Infinity" vgrow="SOMETIMES" />
          <RowConstraints maxHeight="90.0" minHeight="90.0" prefHeight="90.0" vgrow="SOMETIMES" />
          <RowConstraints maxHeight="130.0" minHeight="130.0" prefHeight="130.0" vgrow="SOMETIMES" />
        </rowConstraints>
         <children>
            <Label fx:id="_topPromptLabel" maxHeight="-Infinity" maxWidth="1.7976931348623157E308" visible="false" GridPane.valignment="BOTTOM" />
            <Label fx:id="_bottomPromptLabel" maxHeight="-Infinity" maxWidth="1.7976931348623157E308" visible="false" GridPane.rowIndex="2" GridPane.valignment="TOP" />
         </children>
      </GridPane>
      <GridPane fx:id="_feedbackWindow" alignment="CENTER" maxHeight="100.0" maxWidth="-Infinity" minHeight="100.0" prefHeight="100.0" visible="false">
        <columnConstraints>
          <ColumnConstraints hgrow="SOMETIMES" />
          <ColumnConstraints hgrow="SOMETIMES" />
        </columnConstraints>
        <rowConstraints>
          <RowConstraints maxHeight="100.0" minHeight="100.0" prefHeight="100.0" vgrow="SOMETIMES" />
        </rowConstraints>
         <StackPane.margin>
            <Insets left="100.0" right="100.0" />
         </StackPane.margin>
         <children>
            <Label fx:id="_feedbackLabel" GridPane.columnIndex="1" />
            <ImageView fx:id="_feedbackIcon" fitHeight="70.0" fitWidth="70.0" pickOnBounds="true" preserveRatio="true" GridPane.halignment="CENTER" GridPane.valignment="CENTER" />
         </children>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
      </GridPane>
   </children>
</StackPane>
```
###### \ArchPlanner\application\MainWindow.java
``` java
 */
public class MainWindow extends Application {
    static Logger log = Logger.getLogger(MainWindow.class.getName());
    
    private static final String LOG_MESSAGE_LOADING_FXML = "Loading FXML";
    private static final String LOG_MESSAGE_SUCCESS_LOAD_FXML = "Successfully loaded FXML";
    private static final String LOG_MESSAGE_FAIL_LOAD_FXML = "Fail to load FXML: ";
    private static final String LOG_MESSAGE_LOADING_SCENE = "Loading Scene";
    private static final String LOG_MESSAGE_SETTING_STAGE = "Setting Stage";
    private static final String LOG_MESSAGE_SUCCESS_DISPLAY_WINDOW = "Successfully Displayed Window";
    
    private static final String FILE_PATH_LOGO_IMAGE = "/images/LogoImage.png";
    private static final String FILR_PATH_CSS = "/application/application.css";
    private static final String FILE_PATH_FXML = "/application/MainWindow.fxml";   
    
    public static void main(String[] args) {
        launch(args);
    }
    
    /** Set up the primary stage of the UI. */
	@Override
	public void start(Stage primaryStage) {
	    
	    URL layoutURL = getClass().getResource(FILE_PATH_FXML);
        URL cssURL = getClass().getResource(FILR_PATH_CSS);
        
        Parent root = loadFXML(layoutURL);       
        Scene scene = loadScene(cssURL, root);         
        setStage(primaryStage, scene);
        primaryStage.show();
        
        log.info(LOG_MESSAGE_SUCCESS_DISPLAY_WINDOW);
	}
	
	/** 
	 * Return the layout of the UI after loading from file.
	 * If URL of FXML file is not found, null is return.
	 *  
	 * @param layoutURL   the URL of the FXML file.
	 * @return            the layout of the UI.
	 */
    private Parent loadFXML(URL layoutURL) {
        log.info(LOG_MESSAGE_LOADING_FXML);
        FXMLLoader fxmlLoader = new FXMLLoader();
        Parent layout = null;
        try {
            layout = (Parent) fxmlLoader.load(layoutURL.openStream());
            log.info(LOG_MESSAGE_SUCCESS_LOAD_FXML);
        } catch (IOException e) {
            log.severe(LOG_MESSAGE_FAIL_LOAD_FXML + e.getMessage());
        }
        return layout;
    }
    
    /** 
     * Return the scene of the UI by setting the layout and applying the CSS file.
     *  The layout is assumed to be initialize.
     *  
     *  @param cssURL   the URL of the CSS file.
     *  @param layout   the layout for the scene.
     *  @return         the scene of the UI.
     */
    private Scene loadScene(URL cssURL, Parent layout) {
        log.info(LOG_MESSAGE_LOADING_SCENE);
        assert(layout != null);
        
        Scene scene = new Scene(layout);       
        scene.getStylesheets().addAll(cssURL.toExternalForm());
        scene.setFill(Color.TRANSPARENT);
        
        return scene;
    }
    
    /** 
     * Set the stage parameters.
     * The scene is assumed to be initialize.
     *  
     * @param stage     the stage that the parameters will be applied to.
     * @param scene     the scene that will be set to the stage.
     */
    private void setStage(Stage stage, Scene scene) {
        log.info(LOG_MESSAGE_SETTING_STAGE);
        assert(scene != null);
        
        stage.setScene(scene);
        stage.initStyle(StageStyle.TRANSPARENT);       
        stage.getIcons().add(new Image(FILE_PATH_LOGO_IMAGE));
    }
}
```
###### \ArchPlanner\application\TagButton.java
``` java
 */
public class TagButton extends ToggleButton{
    
    private static final int WIDTH_OF_SCROLL_BAR = 40;
    
    /**
     * construct a new ToggleButton with the Tag parameters and bind the its width.
     * 
     * @param tag       the Tag Object with the parameters.
     * @param width     the width that this ToggleButton will bind to.
     */
    public TagButton(Tag tag, ReadOnlyDoubleProperty width) {
        setTagInfo(tag);
        this.prefWidthProperty().bind(width.subtract(WIDTH_OF_SCROLL_BAR));
        
        this.setMaxWidth(Double.MAX_VALUE);
        this.setAlignment(Pos.CENTER_LEFT);
    }
    
    /**
     * set tag parameters such as tag name and isSelected.
     * 
     * @param tag     the Tag Object with the parameters.
     */
    public void setTagInfo(Tag tag) {
        assert(tag.getName() != null);
        
        this.setText(tag.getName());
        this.setSelected(tag.getIsSelected());
    }
}
```
###### \ArchPlanner\application\TaskPane.java
``` java
 */
public class TaskPane extends GridPane {
    private static final String STRING_NEWLINE = "\n";
    private static final String STRING_THREE_SPACE = "   ";
    private static final String STRING_EMPTY = "";

    private static final String FX_BACKGROUND_COLOR_NORMAL = "-fx-background-color: lightgray;";
    private static final String FX_BACKGROUND_COLOR_OVERDUE = "-fx-background-color: pink;";
    private static final String FX_BACKGROUND_COLOR_DONE = "-fx-background-color: lightgreen;";
    private static final String FX_TEXT_FILL_END_COLOR = "-fx-text-fill: red;";
    private static final String FX_TEXT_FILL_START_COLOR = "-fx-text-fill: green;";
    private static final String FX_BACKGROUND_RADIUS_OF_PANE = "-fx-background-radius: 15;";
    private static final String FX_PADDING_OF_PANE = "-fx-padding: 10;";
    
    private static final int WIDTH_OF_SCROLL_BAR = 40;
    private static final int WIDTH_OF_NUM_COLUMN = 50;
    private static final int WIDTH_OF_DATE_COLUMN = 150;
    private static final int WIDTH_OF_TIME_COLUMN = 130;
    
    private static final int INDEX_INITIAL = 0;
    private static final int DISPLAY_NUMBER_MIN = 1;
    private static final int ROW_1_OF_PANE = 0;
    private static final int ROW_2_OF_PANE = 1;
    
    private ColumnConstraints _numColumn;
    private ColumnConstraints _desColumn;
    private ColumnConstraints _dateColumn;
    private ColumnConstraints _timeColumn;
    
    private RowConstraints _taskRow1;
    private RowConstraints _taskRow2;
    
    private Label _number;
    private Label _description;
    private Label _startDate;
    private Label _startTime;
    private Label _endDate;
    private Label _endTime;
    private Label _tag;
    
    private Tooltip _desciptionHover = new Tooltip();
    private Tooltip _tagHover = new Tooltip();
    
    /**
     * construct a new GridPane with the Task parameters and bind the its width.
     * 
     * @param task      the Task Object with the parameters.
     * @param width     the width that this GridPane will bind to.
     */
    public TaskPane(int displayNumber, Task task, ReadOnlyDoubleProperty width) {        
        initialize();
        
        setWidthProperty(width);
        setNumber(displayNumber);
        setTaskInfo(task);
    }
    
    /**
     * set the number to represent this task.
     * 
     * @param displayNumber     the number to represent this task.
     */
    public void setNumber(int displayNumber) {
        assert(displayNumber >= DISPLAY_NUMBER_MIN);
        
        _number.setText(Integer.toString(displayNumber));        
    }
    
    /**
     * set the task parameters to this TaskPane for display.
     * 
     * @param task     the task with the parameters.
     */
    public void setTaskInfo(Task task) {
        setTaskParameters(task); 
        setHoverText(task);      
        setBackGroundColor(task);     
    }
    
    private void initialize() {              
        setColunmProperties();
        setRowProperties();
        setLabelProperties();
        setPaneProperties();
    }
    
    private void setColunmProperties() {
        _numColumn = new ColumnConstraints();
        _desColumn = new ColumnConstraints();
        _dateColumn = new ColumnConstraints();
        _timeColumn = new ColumnConstraints();
        
        _numColumn.setMinWidth(WIDTH_OF_NUM_COLUMN);     
        _desColumn.setHgrow(Priority.SOMETIMES);
        _dateColumn.setMinWidth(Region.USE_PREF_SIZE);
        _timeColumn.setMinWidth(Region.USE_PREF_SIZE);
    }
    
    private void setRowProperties() {
        _taskRow1 = new RowConstraints();
        _taskRow2 = new RowConstraints();
       
        _taskRow1.setVgrow(Priority.SOMETIMES);
        _taskRow2.setVgrow(Priority.SOMETIMES);
    }

    private void setLabelProperties() {
        initLabel();
        setLabelAlignment();     
        setLabelSize();
        setLabelTextColor();
    }
 
    private void setPaneProperties() {
        this.setStyle(FX_BACKGROUND_RADIUS_OF_PANE + FX_PADDING_OF_PANE);
        
        this.getColumnConstraints().addAll(_numColumn, _desColumn, _dateColumn, _timeColumn);
        
        this.getRowConstraints().add(_taskRow1);
        this.getRowConstraints().add(_taskRow2);
        
        this.addRow(ROW_1_OF_PANE, _number, _description, _startDate, _startTime);
        this.addRow(ROW_2_OF_PANE, new Label(), _tag, _endDate, _endTime);
    }
   
    private void setWidthProperty(ReadOnlyDoubleProperty maxWidth) {
        this.prefWidthProperty().bind(maxWidth.subtract(WIDTH_OF_SCROLL_BAR));
    }
    
    private void initLabel() {
        _number = new Label();
        _description = new Label();     
        _startDate = new Label();
        _startTime = new Label();      
        _endDate = new Label();
        _endTime = new Label();
        _tag = new Label();
    }
    
    private void setLabelAlignment() {
        _number.setAlignment(Pos.CENTER_LEFT);
        _description.setAlignment(Pos.CENTER_LEFT);
        _startDate.setAlignment(Pos.CENTER_LEFT);
        _startTime.setAlignment(Pos.CENTER_LEFT);
        _endDate.setAlignment(Pos.CENTER_LEFT);
        _endTime.setAlignment(Pos.CENTER_LEFT);
    }
    
    private void setLabelSize() {
        _number.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        _description.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        _startDate.setMinWidth(WIDTH_OF_DATE_COLUMN);
        _startTime.setMinWidth(WIDTH_OF_TIME_COLUMN);
        _endDate.setMinWidth(WIDTH_OF_DATE_COLUMN);
        _endTime.setMinWidth(WIDTH_OF_TIME_COLUMN);
        _tag.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
    }
   
    private void setLabelTextColor() {
        _startDate.setStyle(_startDate.getStyle() + FX_TEXT_FILL_START_COLOR);
        _startTime.setStyle(_startTime.getStyle() + FX_TEXT_FILL_START_COLOR);
        _endDate.setStyle(_endDate.getStyle() + FX_TEXT_FILL_END_COLOR);
        _endTime.setStyle(_endTime.getStyle() + FX_TEXT_FILL_END_COLOR);
    }
    
    private void setTaskParameters(Task task) {
        assert(task.getDescription() != null);
        assert(task.getStartDateString() != null);
        assert(task.getStartTimeString() != null);
        assert(task.getEndDateString() != null);
        assert(task.getEndTimeString() != null);
        assert(task.getTagsList() != null);
        
        _description.setText(task.getDescription());       
        _startDate.setText(task.getStartDateString());
        _startTime.setText(task.getStartTimeString());       
        _endDate.setText(task.getEndDateString());
        _endTime.setText(task.getEndTimeString());
        String allTag = STRING_EMPTY;
        for(int i = INDEX_INITIAL; i < task.getTagsList().size(); i++) {
            allTag += task.getTagsList().get(i) + STRING_THREE_SPACE;
        }
        _tag.setText(allTag);
    }

    private void setHoverText(Task task) {        
        _desciptionHover.setText(task.getDescription());
        _description.setTooltip(_desciptionHover);
        
        String allTag = STRING_EMPTY;
        for(int i = INDEX_INITIAL; i < task.getTagsList().size(); i++) {
            allTag += task.getTagsList().get(i) + STRING_NEWLINE;
        }
        if (!allTag.isEmpty()) {
            _tagHover.setText(allTag);
            _tag.setTooltip(_tagHover);
        } 
    }
    
    private void setBackGroundColor(Task task) {
        if(task.getIsDone()) {
            this.setStyle(this.getStyle() + FX_BACKGROUND_COLOR_DONE);
        } else {
            if (task.getIsOverdue()) {
                this.setStyle(this.getStyle() + FX_BACKGROUND_COLOR_OVERDUE);
            } else {
                this.setStyle(this.getStyle() + FX_BACKGROUND_COLOR_NORMAL);
            }
        }
    }
}
```
###### \ArchPlanner\interpreter\Interpreter.java
``` java
 */
public class Interpreter {
    
    private Prompt prompt;
    private Parser parser;
    
    /** initialize the Prompt and Parser object */
    public Interpreter() {
        prompt = new Prompt();
        parser = new Parser();
    }
    
    /**
     * Interpret the string and return the appropriate prompts to UI to display to the user.
     * 
     * @param userInput the string that represent the command.
     * @return          the list of prompts to display to user.
     */
    public ArrayList<String> getPrompts(String userInput) {
        return prompt.getPrompts(userInput);
    }
    
    /**
     * Interpret the string and return the appropriate string with the auto-complete keyword.
     * There is no keyword to auto-complete if the last character is a space.
     * Return the same string if there is no keyword to auto-complete.
     * 
     * @param userInput the string that represent the command.
     * @return          the string after auto-completing the keyword.
     */
    public String getAutoComplete(String userInput) {
        return prompt.getAutoComplete(userInput);
    }
    
    /**
     * This method is used to parse user input into command object.
     *
     * @param userInput     input The user's input.
     * @param viewListSize  the size of the list that the user is viewing to use for validating.
     * @param undoListSize  the size of the undo list to use for validating if there is nothing to undo.
     * @param redoListSize  the size of the redo list to use for validating if there is nothing to redo.
     * @param tagList       the list of tag for validating if a given tag exist.
     * @return              parsed command. If input is invalid, will return InvalidCommand
     */
    public CommandInterface parseCommand(String userInput, int viewListSize, int undoListSize, int redoListSize, ArrayList<Tag> tagList) {
        return parser.parseCommand(userInput, viewListSize, undoListSize, redoListSize, tagList);
    }
}
```
###### \ArchPlanner\interpreter\prompt\AddPrompt.java
``` java
 */
public class AddPrompt implements PromptInterface { 
    private enum Parameter {
        NONE, DESCRIPTION, KEYWORD, PARTIAL_KEYWORD, KEYWORD_TO, START_DATE, START_TIME, END_DATE, END_TIME, TAG
    }
    
    private static final String STRING_EMPTY = "";
    private static final String STRING_SINGLE_SPACE = " ";
    private static final String STRING_MULTIPLE_SPACE = "\\s+";
    
    private static final String PROMPT_ADD = "add";
    private static final String PROMPT_DESCRIPTION = " <Description>";
    private static final String PROMPT_START_DATE = " <Start Date>";
    private static final String PROMPT_START_TIME = " <Start Time>";
    private static final String PROMPT_END_DATE = " <End Date>";
    private static final String PROMPT_END_TIME = " <End Time>";
    private static final String PROMPT_TAG = " #<Tag>";
    private static final String PROMPT_INVALID_TAG = "Invalid Tag: ";
    private static final String PROMPT_INVALID_DATE_RANGE = "Invalid Date Range: ";
    private static final String PROMPT_INVALID_DATE_RANGE_AND_TAG = "Invalid Date Range and Tag: ";    
    private static final String PROMPT_KEYWORD_TO = " to";
    
    private static final String KEYWORD_TO = "to";

    private static final int MIN_NUM_OF_TAG = 0;
    private static final int INDEX_OF_FIRST_WORD = 0;
  
    private AddInputSeparater _parameter;
    
    /**
     * Interpret the given string to determine the relevant prompts.
     * 
     * @param userInput     the string that will be interpreted to provide the relevant prompts.
     * @return              the prompts to display to user.
     */
    @Override
    public ArrayList<String> getPrompts(String userInput) {             
        _parameter = new AddInputSeparater(removeAddCommand(userInput));
        ArrayList<String> addPrompts = new ArrayList<String>();  
        String prompt = appendPrompt(_parameter);
        Parameter lastAppend = getLastAppend(_parameter);      
        addPromptsAfterLastAppend(addPrompts, prompt, _parameter, lastAppend);
        return addPrompts;
    }
    
    /**
     * Return the add keyword that first partially matched the previously interpreted string in getPrompt.
     * Return the empty string if there is no keyword to auto-complete.
     * 
     * @return  the keyword for auto-completing.
     */
    @Override
    public String getAutoWord() {
        if (isValidPartialKeyWord(_parameter)) {
            return getPartialKeyWordString(_parameter);
        } else if (isValidPartialKeyWordTo(_parameter)){
            return KEYWORD_TO;
        } else {
            return STRING_EMPTY;
        }
    }
    
    /**
     * Form the prompt string using the parameters that the user have already inputed.
     * 
     * @param parameter     the parameters that the user have already inputed.
     * @return              the string formed from the present parameters.
     */
    private String appendPrompt(AddInputSeparater parameter) {
        String prompt = PROMPT_ADD;
        if (parameter.hasDescription()) {
            prompt += PROMPT_DESCRIPTION;
        }
        if (parameter.hasPartialKeyWord()) {
            prompt += STRING_SINGLE_SPACE + getPartialKeyWordString(parameter);
        } else if (parameter.hasKeyWord()) {
            prompt += STRING_SINGLE_SPACE + getKeyWordString(parameter); 
        }      
        if (parameter.hasStartDate()) {
            prompt += PROMPT_START_DATE;
        }     
        if (parameter.hasStartTime()) {
            prompt += PROMPT_START_TIME;
        }
        if (parameter.hasKeyWordTo()) {
            prompt += PROMPT_KEYWORD_TO;
        }    
        if (parameter.hasEndDate()) {
            prompt += PROMPT_END_DATE;
        }  
        if (parameter.hasEndTime()) {
            prompt += PROMPT_END_TIME;
        } 
        if (parameter.hasTag()) {
            for (int i = MIN_NUM_OF_TAG; i < parameter.getTags().length; i++) {
                prompt += PROMPT_TAG;
            }
        }
        return prompt;
    }
    
    /**
     * Check the last parameter that user have inputed.
     * 
     * @param parameter     the parameters that the user have already inputed.
     * @return              the last parameter that user have inputed.
     */
    private Parameter getLastAppend(AddInputSeparater parameter) {
        Parameter lastAppend = Parameter.NONE;
        if (parameter.hasDescription()) {
            lastAppend = Parameter.DESCRIPTION;
        }
        if (parameter.hasPartialKeyWord()) {
            lastAppend = Parameter.PARTIAL_KEYWORD;
        } else if (parameter.hasKeyWord()) {
            lastAppend = Parameter.KEYWORD;  
        }      
        if (parameter.hasStartDate()) {
            lastAppend = Parameter.START_DATE;
        }     
        if (parameter.hasStartTime()) {
            lastAppend = Parameter.START_TIME;
        }
        if (parameter.hasKeyWordTo()) {
            lastAppend = Parameter.KEYWORD_TO;
        }    
        if (parameter.hasEndDate()) {
            lastAppend = Parameter.END_DATE;
        }  
        if (parameter.hasEndTime()) {
            lastAppend = Parameter.END_TIME;
        } 
        if (parameter.hasTag()) {
            lastAppend = Parameter.TAG;
        }
        return lastAppend;
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input by checking what have already been inputed.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     * @param lastAppend    the last parameter that user have inputed.
     */
    private void addPromptsAfterLastAppend(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter, Parameter lastAppend) {
        switch (lastAppend) {
            case NONE :
                addPromptsAfterAdd(addPrompts, prompt);
                break;             
            case DESCRIPTION :
                addPromptsAfterDescription(addPrompts, prompt, parameter);
                break;          
            case PARTIAL_KEYWORD :
                // Fallthrough
            case KEYWORD :
                addPromptsAfterKeyWord(addPrompts, prompt, parameter);
                break;                   
            case START_DATE :
                addPromptsAfterStartDate(addPrompts, prompt, parameter);
                break;             
            case START_TIME :                        
                addPromptsAfterStartTime(addPrompts, prompt, parameter);
                break;              
            case KEYWORD_TO :
                addPromptsAfterKeyWordTo(addPrompts, prompt);
                break;             
            case END_DATE :
                addPromptsAfterEndDate(addPrompts, prompt, parameter);
                break;             
            case END_TIME :                    
                addPromptsAfterEndTime(addPrompts, prompt, parameter);
                break;
            case TAG :
                addPromptsAfterTag(addPrompts, prompt, parameter);
                break;
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after add command.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     */
    private void addPromptsAfterAdd(ArrayList<String> addPrompts, String prompt) {
        prompt += PROMPT_DESCRIPTION;
        addPrompts.add(prompt);
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after description.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterDescription(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (!parameter.hasSpace()) {
            addPrompts.add(prompt);
        } else {
            addPrompts.add(prompt + PROMPT_TAG);
            addPrompts.add(prompt + STRING_SINGLE_SPACE + AddKeyWordType.ON.toString().toLowerCase() + 
                           PROMPT_START_DATE);
            addPrompts.add(prompt + STRING_SINGLE_SPACE + AddKeyWordType.BY.toString().toLowerCase() + 
                           PROMPT_END_DATE);
            addPrompts.add(prompt + STRING_SINGLE_SPACE + AddKeyWordType.FROM.toString().toLowerCase() + 
                           PROMPT_START_DATE + PROMPT_KEYWORD_TO + PROMPT_END_DATE);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after keyword.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterKeyWord(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.BY || parameter.getPartialKeyWord() == AddKeyWordType.BY) {
            addPrompts.add(prompt + PROMPT_END_DATE);
            addPrompts.add(prompt + PROMPT_END_TIME);
        } else {
            addPrompts.add(prompt + PROMPT_START_DATE);
            addPrompts.add(prompt + PROMPT_START_TIME);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after start date.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterStartDate(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.FROM) {
            addPrompts.add(prompt + PROMPT_KEYWORD_TO + PROMPT_END_DATE);
            addPrompts.add(prompt + PROMPT_START_TIME + PROMPT_KEYWORD_TO + PROMPT_END_TIME);
            addPrompts.add(prompt + PROMPT_START_TIME + PROMPT_KEYWORD_TO + PROMPT_END_DATE + PROMPT_END_TIME);
        } else {
            if (!parameter.hasSpace()) {
                addPrompts.add(prompt);
            }
            addPrompts.add(prompt + PROMPT_TAG);
            addPrompts.add(prompt + PROMPT_START_TIME);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after start time.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterStartTime(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.FROM) {
            addPrompts.add(prompt + PROMPT_KEYWORD_TO + PROMPT_END_TIME);
            addPrompts.add(prompt + PROMPT_KEYWORD_TO + PROMPT_END_DATE);
            addPrompts.add(prompt + PROMPT_KEYWORD_TO + PROMPT_END_DATE + PROMPT_END_TIME);
        } else {
            if (!parameter.hasSpace()) {
                addPrompts.add(prompt);
            }
            addPrompts.add(prompt + PROMPT_TAG);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after to.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     */
    private void addPromptsAfterKeyWordTo(ArrayList<String> addPrompts, String prompt) {
        addPrompts.add(prompt + PROMPT_END_TIME);
        addPrompts.add(prompt + PROMPT_END_DATE);
        addPrompts.add(prompt + PROMPT_END_DATE + PROMPT_END_TIME);
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after end date.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterEndDate(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.FROM && !parameter.hasValidDateRange()) {
            if (!parameter.hasSpace()) {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE  + prompt);
            } else {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE + prompt + PROMPT_TAG);
            }
        } else {
            if (!parameter.hasSpace()) {
                addPrompts.add(prompt);
            }
            addPrompts.add(prompt + PROMPT_TAG);
            addPrompts.add(prompt + PROMPT_END_TIME);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after end time.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterEndTime(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.FROM && !parameter.hasValidDateRange()) {
            if (!parameter.hasSpace()) {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE  + prompt);
            } else {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE + prompt + PROMPT_TAG);
            }
        } else {
            if (!parameter.hasSpace()) {
                addPrompts.add(prompt);
            }
            addPrompts.add(prompt + PROMPT_TAG);
        }
    }
    
    /**
     * Add the additional prompts to guide the user on the next parameter that he could input after tags.
     * 
     * @param addPrompts    the list of prompts that will be form in this method to guide the user on the next parameter.
     * @param prompt        the string formed by the parameters that have already been inputed.
     * @param parameter     the parameters that the user have already inputed.
     */
    private void addPromptsAfterTag(ArrayList<String> addPrompts, String prompt, AddInputSeparater parameter) {
        if (parameter.getKeyWord() == AddKeyWordType.FROM && !parameter.hasValidDateRange()) {
            if (parameter.hasValidTag()) {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE  + prompt);
            } else {
                addPrompts.add(PROMPT_INVALID_DATE_RANGE_AND_TAG  + prompt);
            }
        } else {
            if (parameter.hasValidTag()) {
                addPrompts.add(prompt);
            } else {
                addPrompts.add(PROMPT_INVALID_TAG  + prompt);
            }
        }
    }

    private boolean isValidPartialKeyWord(AddInputSeparater parameter) {
        return parameter.getPartialKeyWord() != AddKeyWordType.UNKNOWN;
    }

    private boolean isValidPartialKeyWordTo(AddInputSeparater parameter) {
        if (parameter.getKeyWord() != AddKeyWordType.FROM) {
            return false;
        }    
        if (!parameter.hasKeyWordTo()) {
            return false;
        }     
        if (parameter.getEndDateTime() != null) {
            return false;
        }
        return true;
    }
    
    private String getPartialKeyWordString(AddInputSeparater parameter) {
        return parameter.getPartialKeyWord().toString().toLowerCase();
    }

    private String getKeyWordString(AddInputSeparater parameter) {
        return parameter.getKeyWord().toString().toLowerCase();
    }
    
    private String removeAddCommand(String input) {
        return input.substring(getFirstWord(input).length());
    }
    
    private String getFirstWord(String input) {
        return input.trim().split(STRING_MULTIPLE_SPACE)[INDEX_OF_FIRST_WORD];
    }
}
```
###### \ArchPlanner\interpreter\prompt\CommandPrompt.java
``` java
 */
public class CommandPrompt implements PromptInterface{
    
    private static final String STRING_EMPTY = "";
    private static final String STRING_MULTIPLE_SPACE = "\\s+";
    private static final char CHAR_SPACE = ' ';
    
    private static final int INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER = 1;
    private static final int PROMPTS_MIN = 1;
    private static final int FIRST_COMMAND_PROMPT = 0;   
    
    private ArrayList<String> _commandPrompts;
    private CommandType _partialCommand;
    
    /** Initializes a newly created CommandPrompt object. */
    public CommandPrompt() {
        _commandPrompts = new ArrayList<String>();
        _partialCommand = CommandType.UNKNOWN;
    }
    
    /**
     * Interpret the string and return the appropriate command prompts to UI to display to the user.
     * 
     * @param input     the string that represent the command.
     * @return          the list of command prompts to display to user.
     */
    @Override
    public ArrayList<String> getPrompts(String input) {
        if (!hasEndedWithSpace(input) && getNumOfWords(input) == 1) {
            _commandPrompts = getPartialCommands(input);
            if (_commandPrompts.size() < PROMPTS_MIN) {
                _partialCommand = CommandType.UNKNOWN;
            } else {
                _partialCommand = CommandType.valueOf(_commandPrompts.get(FIRST_COMMAND_PROMPT).toUpperCase());
            }
        }
        return _commandPrompts;
    }
    
    /**
     * Return the command that first partially matched the string.
     * Return the empty string if there is no keyword to auto-complete.
     * 
     * @return  the command for auto-completing.
     */
    @Override
    public String getAutoWord() {
        if (_partialCommand != CommandType.UNKNOWN) {
            return _partialCommand.toString().toLowerCase();
        } else {
            return STRING_EMPTY;
        }
    }
    
    /**
     * Return all commands that partially matched the string.
     * Return empty list if there is no command that partially matched the string.
     * 
     * @return  the list of commands that partially matched the string.
     */
    private ArrayList<String> getPartialCommands(String input) {
        ArrayList<String> partialCommands = new ArrayList<String>();
        input = input.trim().toUpperCase();
        for (CommandType commandType : CommandType.values()) {
            if (commandType != CommandType.UNKNOWN && commandType.toString().startsWith(input)) {
                partialCommands.add(commandType.toString().toLowerCase());
            }
        }
        return partialCommands;
    }
    
    private boolean hasEndedWithSpace(String input) {
        char lastChar = input.charAt(input.length() - INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER);
        if (lastChar == CHAR_SPACE) {
            return true;
        } else {
            return false;
        }
    }
    
    private int getNumOfWords(String input) {
        return input.trim().split(STRING_MULTIPLE_SPACE).length;
    }
}
```
###### \ArchPlanner\interpreter\prompt\Prompt.java
``` java
 */
public class Prompt { 
    public enum CommandType {
        ADD, DELETE, EDIT, VIEW, DONE, UNDONE, UNDO, REDO, EXIT, UNKNOWN, SET
    }

    private static final String STRING_MULTIPLE_SPACE = "\\s+";
    private static final String STRING_INVALID_COMMAND = "Invalid command: add | delete | edit | view | done | undone | undo | redo | exit";
    private static final char CHAR_SPACE = ' ';
    
    private static final int PROMPTS_MIN = 1;
    private static final int INITIAL_INDEX = 0;
    private static final int INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER = 1;
    
    private ArrayList<String> _prompts;
    private PromptInterface _promptObj;
    
    /** Initializes a newly created Prompt object. */
    public Prompt() {
        _prompts = new ArrayList<String>();
    }
    
    /**
     * Interpret the string and return the appropriate prompts to UI to display to the user.
     * 
     * @param userInput the string that represent the command.
     * @return          the list of prompts to display to user.
     */
    public ArrayList<String> getPrompts(String userInput) {
        _prompts.clear();
        
        if (userInput == null) {
            _prompts.add(STRING_INVALID_COMMAND);
        } else if (!userInput.trim().isEmpty()) {
            CommandType commandType = determineCommandType(userInput);

            _promptObj = getPromptObject(commandType);
            _prompts = _promptObj.getPrompts(userInput);
        }

        if (_prompts.size() < PROMPTS_MIN) {
            _prompts.add(STRING_INVALID_COMMAND);
        }
        return _prompts;
    }
    
    /**
     * Interpret the string and return the appropriate string with the auto-complete keyword.
     * There is no keyword to auto-complete if the last character is a space.
     * Return the same string if there is no keyword to auto-complete.
     * 
     * @param userInput the string that represent the command.
     * @return          the string after auto-completing the keyword.
     */
    public String getAutoComplete(String userInput) {
        if (userInput.isEmpty()) {
            return userInput;
        }
        char lastChar = userInput.charAt(userInput.length() - INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER);
        if (lastChar != CHAR_SPACE) {
            String autoWords = _promptObj.getAutoWord();
    
            if (autoWords == null || autoWords.isEmpty()) {
                return userInput;
            } else {
                return removeLastWord(userInput) + autoWords;
            }
        } else {
            return userInput;
        }
    }
    
    /**
     * Return the relevant Prompt Object depending on the command.
     * 
     * @param commandType   the command detected in the user input.
     * @return              the Object associated with the command
     */
    private PromptInterface getPromptObject(CommandType commandType) {
        switch (commandType) {
            case ADD :
                return new AddPrompt();
            case EDIT :
                return new EditPrompt();
            case VIEW :
                return new ViewPrompt();
            case SET :
                return new SetPrompt();
            case DELETE :
                // Fallthrough
            case DONE :
                // Fallthrough
            case UNDONE :
                return new IdOnlyPrompt();
            case UNDO :
                // Fallthrough
            case REDO :
                // Fallthrough
            case EXIT :
                // Fallthrough
            case UNKNOWN :
                return new CommandPrompt();
            default :
                return null;
        }
    }
    
    /**
     * Interpret the first word in the string and return the command associated with the word.
     * Return UNKNOWN if string is empty or no command is found.
     * 
     * @param input   the string used to interpret the command.
     * @return        the Command interpreted from the first word.
     */
    private CommandType determineCommandType(String input) {
        assert(input != null);
        
        String commandTypeString = getFirstWord(input);
        if (commandTypeString.isEmpty()) {
            return CommandType.UNKNOWN;
        }
        for (CommandType type : CommandType.values()) {
            if (commandTypeString.equalsIgnoreCase(type.name())) {
                return type;
            }
        }
        return CommandType.UNKNOWN;
    }

    private String getFirstWord(String input) {
        String commandTypeString = input.trim().split(STRING_MULTIPLE_SPACE)[INITIAL_INDEX];
        return commandTypeString;
    }
    
    private String removeLastWord(String input) {
        String[] splitInput = input.trim().split(STRING_MULTIPLE_SPACE);
        String lastWord = splitInput[splitInput.length - INDEX_OFFSET_OF_ARRAY_AND_DISPLAY_NUMBER];
        int indexOfLastWord = input.lastIndexOf(lastWord);
        return input.substring(INITIAL_INDEX, indexOfLastWord);
    }
}
```
###### \ArchPlanner\interpreter\prompt\PromptInterface.java
``` java
 */
public interface PromptInterface {
    ArrayList<String> getPrompts(String input);
    String getAutoWord();
}
```
###### \ArchPlanner\interpreter\separater\AddInputSeparater.java
``` java
 */
public class AddInputSeparater {
    public enum AddKeyWordType {
        ON, BY, FROM, UNKNOWN
    }

    private static final int DATE_TO_CALENDAR_MONTH_OFFSET = 1;
    private static final int PARAMETERS_MIN_NUM = 1;
    private static final int MINIMUM_WORD_BEFORE_KEYWORD = 1;
    private static final int INITIAL_INDEX = 0;
    private static final int LAST_INDEX_OFFSET = 1;
    private static final int NOT_FOUND = -1;
    
    private static final int FIRST_HOUR_OF_DAY = 0;
    private static final int FIRST_MINUTE_OF_HOUR = 0;
    private static final int FIRST_SECOND_OF_MINUTE = 0;
    private static final int LAST_HOUR_OF_DAY = 23;
    private static final int LAST_MINUTE_OF_HOUR = 59;
    private static final int LAST_SECOND_OF_MINUTE = 59;
    
    private static final String PARTIAL_KEYWORD_TO = "t";
    private static final String KEYWORD_TO = "to";
    private static final String KEYWORD_TAG = "#";
    private static final String INVALID_TAG_2 = " # ";
    private static final String INVALID_TAG_1 = "# ";
  
    private static final String STRING_EMPTY = "";
    private static final String STRING_SINGLE_SPACE = " ";
    private static final String STRING_MULTIPLE_SPACE = "\\s+";
    
    private String _description;
    private AddKeyWordType _keyWord;
    private AddKeyWordType _partialKeyWord;
    private Date _startDateTime;
    private Date _endDateTime;
    private LocalDate _startDate;
    private LocalTime _startTime;
    private LocalDate _endDate;
    private LocalTime _endTime;
    private String[] _tags;
    
    private boolean _hasSpace;
    private boolean _hasKeyWordTo;
    private boolean _hasValidTag;
    
    /**
     * Interpret the given string and separate all the parameters found in the string.
     * 
     * @param userInput     the string with the add command parameters.
     */
    public AddInputSeparater(String userInput) {
        
        AddRegionSeparater breakUserInput = new AddRegionSeparater(userInput);
        
        _partialKeyWord = findPartialKeyWord(userInput);   
        _tags = findTags(breakUserInput.getTagRegion());
       
        AddKeyWordType initialKeyWord = findInitialKeyWord(breakUserInput, _partialKeyWord);
        String startDateRegion = findStartDateRegion(breakUserInput, initialKeyWord);
        String endDateRegion = findEndDateRegion(breakUserInput, initialKeyWord);
        DateInterpreter startDateParameter = new DateInterpreter(startDateRegion);
        DateInterpreter endDateParameter = new DateInterpreter(endDateRegion);
        
        _startDateTime = findStartDateTime(startDateParameter, endDateParameter, initialKeyWord);
        _endDateTime = findEndDateTime(startDateParameter, endDateParameter, initialKeyWord);
        _keyWord = findKeyWord(_startDateTime, startDateRegion, _endDateTime, endDateRegion, initialKeyWord);
        _description = findDesciption(userInput, breakUserInput, _keyWord, _startDateTime, _endDateTime);
        
        _startDate = findLocalDate(_startDateTime, startDateParameter);
        _startTime = findLocalTime(_startDateTime, startDateParameter);
        _endDate = findLocalDate(_endDateTime, endDateParameter);
        _endTime = findLocalTime(_endDateTime, endDateParameter);
   
        _startDateTime = modifyStartDateTimeToAssumption(_startDateTime, _startDate, _startTime, 
                                                         _endDateTime, _endDate, _endTime);
        _endDateTime = modifyEndDateTimeToAssumption(_startDateTime, _startDate, _startTime, 
                                                     _endDateTime, _endDate, _endTime);
     
        _hasKeyWordTo = isKeyWordToPresent(userInput, _keyWord, _startDateTime, _endDateTime);
        _hasSpace = isSpacePresent(userInput, breakUserInput);
        _hasValidTag = isValidTag(breakUserInput.getTagRegion());
    }
    
    /**
     * Return the keyword that partially matched the last word in the string.
     * Return UNKNOWN if no keyword matched.
     * 
     * @param input         the string that user inputted.
     * @return              the keyword that partially matched the last word in the string.
     */
    private AddKeyWordType findPartialKeyWord(String input) {
        if (input.trim().isEmpty()) {
            return AddKeyWordType.UNKNOWN;
        }

        String[] splitInput = input.trim().split(STRING_MULTIPLE_SPACE);
        if (splitInput.length <= MINIMUM_WORD_BEFORE_KEYWORD) {
            return AddKeyWordType.UNKNOWN;
        }
        
        for (AddKeyWordType type : AddKeyWordType.values()) {
            if ((type.toString().startsWith(splitInput[splitInput.length - LAST_INDEX_OFFSET].toUpperCase()))) {
                return type;
            }
        }
        return AddKeyWordType.UNKNOWN;
    }
    
    /**
     * Return the tags found in the tagRegion. Return null if no tags found.
     * 
     * @param tagRegion     the region that contain all the tags.
     * @return              the tags found in the string.
     */
    private String[] findTags(String tagRegion) {
        if (tagRegion.trim().isEmpty()) {
            return null;
        } else {
            return tagRegion.split(STRING_MULTIPLE_SPACE);
        }
    }
    
    /**
     * Return the converted keyword from the keyWordRegion in the AddRegionSeparator.
     * Return UNKNOWN if partialKeyWord is present.
     * 
     * @param breakUserInput    the class that break the input into regions.
     * @param partialKeyWord    the partial keyword already found.
     * @return                  the keyword converted from the keyword region in the breakUserInput.
     */
    private AddKeyWordType findInitialKeyWord(AddRegionSeparater breakUserInput, AddKeyWordType partialKeyWord) {
        if (partialKeyWord != AddKeyWordType.UNKNOWN) {
            return AddKeyWordType.UNKNOWN;
        } else {
            return determineKeyWordType(breakUserInput.getKeyWordRegion());
        }
    }
    
    /**
     * Return the start date region interpreted from the AddRegionSeparator using the keyword found.
     * 
     * @param breakUserInput    the class that break the input into regions.
     * @param keyWord           the keyword already found.
     * @return                  the start date region.
     */
    private String findStartDateRegion(AddRegionSeparater breakUserInput, AddKeyWordType keyWord) {
        switch (keyWord) {
            case ON :
                return breakUserInput.getFirstDateRegion();
            case FROM :
                return removeKeyWordToIfPresent(breakUserInput.getFirstDateRegion());
            default :
                return STRING_EMPTY;
        }
    }
    
    /**
     * Return the end date region interpreted from the AddRegionSeparator using the keyword found.
     * 
     * @param breakUserInput    the class that break the input into regions.
     * @param keyWord           the keyword already found.
     * @return                  the end date region.
     */
    private String findEndDateRegion(AddRegionSeparater breakUserInput, AddKeyWordType keyWord) {
        switch (keyWord) {
            case BY :
                return breakUserInput.getFirstDateRegion();
            case FROM :
                return breakUserInput.getSecondDateRegion();
            default :
                return STRING_EMPTY;
        }
    }
    
    /**
     * Return the start Date object by comparing the start date, end date and keyword.
     * 
     * @param startDateParameter    the class containing the start date parameters used for comparing.
     * @param endDateParameter      the class containing the end date parameters used for comparing.
     * @param initialKeyWord        the keyword used for comparing.
     * @return                      the start Date object.
     */
    private Date findStartDateTime(DateInterpreter startDateParameter, DateInterpreter endDateParameter, AddKeyWordType initialKeyWord) {
        Date startDateTime = startDateParameter.getDateTime();
        Date endDateTime = null;
        if (initialKeyWord != AddKeyWordType.FROM || startDateTime != null) {
            endDateTime = endDateParameter.getDateTime();
        } 
        if (initialKeyWord == AddKeyWordType.FROM && endDateTime == null) {
            if (!endDateParameter.getDateRegion().isEmpty() || hasTag()) {
                return null;
            }
        }
        return startDateTime;
    }
    
    /**
     * Return the end Date object by comparing the start date, end date and keyword.
     * 
     * @param startDateParameter    the class containing the start date parameters used for comparing.
     * @param endDateParameter      the class containing the end date parameters used for comparing.
     * @param initialKeyWord        the keyword used for comparing.
     * @return                      the end Date object.
     */
    private Date findEndDateTime(DateInterpreter startDateParameter, DateInterpreter endDateParameter, AddKeyWordType initialKeyWord) {
        Date startDateTime = startDateParameter.getDateTime();
        Date endDateTime = null;
        if (initialKeyWord != AddKeyWordType.FROM || startDateTime != null) {
            endDateTime = endDateParameter.getDateTime();
        }
    
        return endDateTime;
    }
    
    /**
     * Return the valid keyword in the input by checking whether there are other invalid within the dates region.
     * 
     * @param startDateTime     the start date found in the start date region.
     * @param startDateRegion   the start date region.
     * @param endDateTime       the end date found in the start date region.
     * @param endDateRegion     the end date region.
     * @param initialKeyWord    the keyword used for previously found.
     * @return                  the valid keyword.
     */
    private AddKeyWordType findKeyWord(Date startDateTime, String startDateRegion, 
                                      Date endDateTime, String endDateRegion, AddKeyWordType initialKeyWord) {
        if (startDateTime == null  && endDateTime == null) {
            if (!startDateRegion.isEmpty() || hasTag()) {
                return AddKeyWordType.UNKNOWN;
            }
        }
        if (initialKeyWord == AddKeyWordType.FROM && endDateTime == null) {
            if (!endDateRegion.isEmpty() || hasTag()) {
                return AddKeyWordType.UNKNOWN;
            }
        }
        return initialKeyWord;
    }
    
    /**
     * Return the description interpreted after checking for valid dates and keyword.
     * 
     * @param userInput         the user inputed string.
     * @param breakUserInput    the class that break the input into regions.
     * @param keyWord           the keyword used for comparing.
     * @param startDateTime     the start date used for comparing.
     * @param endDateTime       the end date used for comparing.
     * @return                  the description interpreted.
     */
    private String findDesciption(String userInput, AddRegionSeparater breakUserInput, AddKeyWordType keyWord, 
                                 Date startDateTime, Date endDateTime) {
        if ((startDateTime == null && endDateTime == null) || (keyWord == AddKeyWordType.FROM && endDateTime == null)) {
            return userInput.substring(INITIAL_INDEX, userInput.length() - breakUserInput.getTagRegion().length()).trim();
        } else {
            return breakUserInput.getDescriptionRegion();
        }
    }
    
    /**
     * Return LocalDate object found in the given Date after interpreting the date region.
     * Return null date is not present.
     * 
     * @param dateTime          the Date object containing the date.
     * @param breakDateRegion   the class interpreting the date region to check for the presence of date.
     * @return                  the LocalDate object.
     */
    private LocalDate findLocalDate(Date dateTime, DateInterpreter breakDateRegion) {
        if (dateTime == null || breakDateRegion.getDateTime() == null || !breakDateRegion.hasDate()) {
            return null;
        } else {
            return breakDateRegion.getDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }
    }
    
    /**
     * Return LocalTime object found in the given Date after interpreting the date region.
     * Return null date is not present.
     * 
     * @param dateTime          the Date object containing the time.
     * @param breakDateRegion   the class interpreting the date region to check for the presence of time.
     * @return                  the LocalTime object.
     */
    private LocalTime findLocalTime(Date dateTime, DateInterpreter breakDateRegion) {
        if (dateTime == null || breakDateRegion.getDateTime() == null || !breakDateRegion.hasTime()) {
            return null;
        } else {
            return breakDateRegion.getDateTime().toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
        }
    }
    
    /**
     * Modify the start Date object to the assumed value if the start/end date or time is not present.
     * 
     * @param startDateTime     the start Date object.
     * @param startDate         the start LocalDate.
     * @param startTime         the start LocalTime.
     * @param endDateTime       the end Date object.
     * @param endDate           the end LocalDate.
     * @param endTime           the end LocalTime.
     * @return                  the modified start Date object.
     */
    private Date modifyStartDateTimeToAssumption(Date startDateTime, LocalDate startDate, LocalTime startTime, 
                                                 Date endDateTime, LocalDate endDate, LocalTime endTime) {
        if (startDateTime != null && endDateTime != null) {
            if (startTime == null && endTime != null) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(startDateTime);
                cal.set(Calendar.HOUR_OF_DAY, FIRST_HOUR_OF_DAY);
                cal.set(Calendar.MINUTE, FIRST_MINUTE_OF_HOUR);
                cal.set(Calendar.SECOND, FIRST_SECOND_OF_MINUTE);
                return cal.getTime();
            }
        }
        return startDateTime;
    }
    
    /**
     * Modify the end Date object to the assumed value if the start/end date or time is not present.
     * 
     * @param startDateTime     the start Date object.
     * @param startDate         the start LocalDate.
     * @param startTime         the start LocalTime.
     * @param endDateTime       the end Date object.
     * @param endDate           the end LocalDate.
     * @param endTime           the end LocalTime.
     * @return                  the modified end Date object.
     */
    private Date modifyEndDateTimeToAssumption(Date startDateTime, LocalDate startDate, LocalTime startTime, 
                                               Date endDateTime, LocalDate endDate, LocalTime endTime) {
        if (startDateTime != null && endDateTime != null) {
            if (startDate != null && startTime != null && endDate == null && endTime != null) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(endDateTime);
                cal.set(Calendar.DATE, startDate.getDayOfMonth());
                cal.set(Calendar.MONTH, startDate.getMonthValue() - DATE_TO_CALENDAR_MONTH_OFFSET);
                cal.set(Calendar.YEAR, startDate.getYear());
                return cal.getTime();
            } else if (startTime != null && endTime == null) {
                Calendar cal = Calendar.getInstance();
                cal.setTime(_endDateTime);
                cal.set(Calendar.HOUR_OF_DAY, LAST_HOUR_OF_DAY);
                cal.set(Calendar.MINUTE, LAST_MINUTE_OF_HOUR);
                cal.set(Calendar.SECOND, LAST_SECOND_OF_MINUTE);
                return cal.getTime();
            }
        }
        return endDateTime;
    }
    
    /**
     * Check if the keyword 'to' is present in the user input.
     * 
     * @param userInput     the user inputed string.
     * @param keyWord       the keyword use to determine if the keyword 'to' is present.
     * @param startDateTime the start date use to determine if the keyword 'to' is present.
     * @param endDateTime   the end date use to determine if the keyword 'to' is present.
     * @return              the modified start Date object.
     */
    private boolean isKeyWordToPresent(String userInput, AddKeyWordType keyWord, Date startDateTime, Date endDateTime) {
        if (keyWord == AddKeyWordType.FROM && startDateTime != null && endDateTime == null && getPartialToIndex(userInput) != NOT_FOUND) {
            return true;
        } else if (keyWord == AddKeyWordType.FROM && startDateTime != null && endDateTime != null) {
            return true;
        } else {
            return false;
        }
    }
    
    private boolean isSpacePresent(String userInput, AddRegionSeparater breakUserInput) {
        if (!breakUserInput.getTagRegion().isEmpty()) {
            return true;
        }
        if (userInput.trim().length() < PARAMETERS_MIN_NUM) {
            return false;
        }
        return userInput.substring(userInput.length() - LAST_INDEX_OFFSET).equals(STRING_SINGLE_SPACE);
    }
    
    /**
     * Check if the tag in the tag region contains all valid tags.
     * 
     * @param tagRegion     the tag region containing the tags
     * @return              whether if all tags are valid.
     */
    private boolean isValidTag(String tagRegion) {
        if (tagRegion.startsWith(INVALID_TAG_1) || tagRegion.contains(INVALID_TAG_2)) {
            return false;
        }
        String[] tags = tagRegion.split(STRING_MULTIPLE_SPACE);
        for (int i = INITIAL_INDEX; i < tags.length; i++) {
            if(!tags[i].startsWith(KEYWORD_TAG)) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Remove the keyword 'to' in the start date region if it is found.
     * 
     * @param startDateRegion   the region containing the start date time.
     * @return                  the start date region without the keyword.
     */
    private String removeKeyWordToIfPresent(String startDateRegion) {
        int indexOfPartialTo =  getPartialToIndex(startDateRegion);
        if (indexOfPartialTo == NOT_FOUND) {
            return startDateRegion;
        } else {
            return startDateRegion.substring(INITIAL_INDEX, indexOfPartialTo).trim();
        }
    }
    
    /**
     * Return the index of the keyword 'to' in the input string. Return -1 if keyword is not found.
     * 
     * @param input the string containing the keyword.
     * @return      the index of the keyword 'to'.
     */
    private int getPartialToIndex(String input) {
        if (input.trim().isEmpty()) {
            return NOT_FOUND;
        }
        input = input.toLowerCase();
        String[] splitInput = input.trim().split(STRING_MULTIPLE_SPACE);
        if (splitInput.length <= MINIMUM_WORD_BEFORE_KEYWORD) {
            return NOT_FOUND;
        }
        if (KEYWORD_TO.startsWith(splitInput[splitInput.length - LAST_INDEX_OFFSET])) {
            return input.lastIndexOf(PARTIAL_KEYWORD_TO);
        } else {
            return NOT_FOUND;
        }
    }    
    
    /**
     * Return the KeyWordType from the key word string.
     * 
     * @param KeyWordString     the string of the keyword.
     * @return                  the KeyWordType interpreted from the string.
     */
    private AddKeyWordType determineKeyWordType(String KeyWordString) {
        if (KeyWordString.isEmpty()) {
            return AddKeyWordType.UNKNOWN;
        }
        
        for (AddKeyWordType type : AddKeyWordType.values()) {
            if (KeyWordString.equalsIgnoreCase(type.toString())) {
                return type;
            }
        }
        return AddKeyWordType.UNKNOWN;
    }
    
    /**
     * Return true if a space is found in the user input.
     * 
     * @return  true if a space is found.
     */
    public boolean hasSpace() {
        return _hasSpace;
    }
    
    /**
     * Return true if description is found in the user input.
     * 
     * @return  true if description is found.
     */
    public boolean hasDescription() {
        return _description != null;
    }
    
    /**
     * Return true if keyword is found in the user input.
     * 
     * @return  true if keyword is found.
     */
    public boolean hasKeyWord() {
        return _keyWord != AddKeyWordType.UNKNOWN;
    }
    
    /**
     * Return true if a partial keyword is found in the user input.
     * 
     * @return  true if partial keyword is found.
     */
    public boolean hasPartialKeyWord() {
        return _partialKeyWord != AddKeyWordType.UNKNOWN;
    }
    
    /**
     * Return true if the keyword 'to' is found in the user input.
     * 
     * @return  true if the keyword 'to' is found.
     */
    public boolean hasKeyWordTo() {
        return _hasKeyWordTo;
    }
    
    /**
     * Return true if the start date is found in the user input.
     * 
     * @return  true if the start date is found.
     */
    public boolean hasStartDate() {
        return _startDate != null;
    }
    
    /**
     * Return true if the start time is found in the user input.
     * 
     * @return  true if the start time is found.
     */
    public boolean hasStartTime() {
        return _startTime != null;
    }
    
    /**
     * Return true if the end date is found in the user input.
     * 
     * @return  true if the end date is found.
     */
    public boolean hasEndDate() {
        return _endDate != null;
    }
    
    /**
     * Return true if the end time is found in the user input.
     * 
     * @return  true if the end time is found.
     */
    public boolean hasEndTime() {
        return _endTime != null;
    }
    
    /**
     * Return true if there are tags found in the user input.
     * 
     * @return  true if tags are found.
     */
    public boolean hasTag() {
        return  _tags != null;
    }
    
    /**
     * Return true if the tags found in the user input is valid.
     * 
     * @return  true if the tags found in the user input is valid.
     */
    public boolean hasValidTag() {
        return _hasValidTag;
    }
    
    /**
     * Return true if both start and end date is present and the start date is before the end date.
     * 
     * @return  true if both start and end date is present and the start date is before the end date.
     */
    public boolean hasValidDateRange() {
        if (_startDateTime == null || _endDateTime == null) {
            return false;
        } else {
           return _startDateTime.before(_endDateTime);
        }
    }
    
    /**
     * Return the description found in the user input.
     * 
     * @return  the description found in the user input.
     */
    public String getDescription() {
        return _description;
    }
    
    /**
     * Return the keyword found in the user input.
     * 
     * @return  the keyword found in the user input.
     */
    public AddKeyWordType getKeyWord() {
        return _keyWord;
    }
    
    /**
     * Return the partial keyword found in the user input.
     * 
     * @return  the partial keyword found in the user input.
     */
    public AddKeyWordType getPartialKeyWord() {
        return _partialKeyWord;
    }
    
    /**
     * Return the start Date Object found in the user input.
     * 
     * @return  the start Date Object found in the user input.
     */
    public Date getStartDateTime() {
        return _startDateTime;
    }
    
    /**
     * Return the end Date Object found in the user input.
     * 
     * @return  the end Date Object found in the user input.
     */
    public Date getEndDateTime() {
        return _endDateTime;
    }
    
    /**
     * Return the start LocalDate Object found in the user input.
     * 
     * @return  the start LocalDate Object found in the user input.
     */
    public LocalDate getStartDate() {
        return _startDate;
    }
    
    /**
     * Return the start LocalTime Object found in the user input.
     * 
     * @return  the start LocalTime Object found in the user input.
     */
    public LocalTime getStartTime() {
        return _startTime;
    }
    
    /**
     * Return the end LocalDate Object found in the user input.
     * 
     * @return  the end LocalDate Object found in the user input.
     */
    public LocalDate getEndDate() {
        return _endDate;
    }
    
    /**
     * Return the end LocalTime Object found in the user input.
     * 
     * @return  the end LocalTime Object found in the user input.
     */
    public LocalTime getEndTime() {
        return _endTime;
    }
    
    /**
     * Return the tags found in the user input.
     * 
     * @return  the tags found in the user input.
     */
    public String[] getTags() {
        return _tags;
    }
}
```
###### \ArchPlanner\interpreter\separater\AddRegionSeparater.java
``` java
 */
public class AddRegionSeparater {
   
    private static final int ONE_SPACE = 1;
    private static final int TWO_SPACE = 2;
    private static final int NOT_FOUND = -1;
    private static final int INDEX_INITIAL = 0;
    private static final int INDEX_INVALID_TAG = 0;
    
    private static final String STRING_EMPTY = "";
    private static final String STRING_SINGLE_SPACE = " ";
    
    private static final String KEYWORD_TAG = " #";
    private static final String KEYWORD_TO = " to ";
    
    private String _descriptionRegion;
    private String _keyWordRegion;
    private String _firstDateRegion;
    private String _secondDateRegion;
    private String _tagRegion;
    
    /**
     * Separate the given string into 5 regions: descriptionRegion, keywordRegion, 
     * firstDateRegion, secondDateRegion, tagsRegion.
     * 
     * @param userInput    the string that will be separated to the different regions.
     */
    public AddRegionSeparater(String userInput) {
        _keyWordRegion = extractKeyWordRegion(userInput);
        _tagRegion = extractTagRegion(userInput, _keyWordRegion);
        _descriptionRegion = extractDescriptionRegion(userInput, _keyWordRegion, _tagRegion);
        
        String dateRegion = extractDateRegion(userInput, _keyWordRegion, _tagRegion);
        _firstDateRegion = extractFirstDateRegion(dateRegion, _keyWordRegion);
        _secondDateRegion = extractSecondDateRegion(dateRegion, _firstDateRegion);
        
        _descriptionRegion = _descriptionRegion.trim();
        _keyWordRegion = _keyWordRegion.trim();
        _firstDateRegion = _firstDateRegion.trim();
        _secondDateRegion = _secondDateRegion.trim();
    }
    
    /**
     * Extract the keyWordRegion by finding the last occurrence of a keyWord.
     * Return empty string if keyWord cannot be found.
     * 
     * @param input     the string used to extract the keyWordRegion.
     * @return          the keyWordRegion extracted from input.
     */
    private String extractKeyWordRegion(String input) {
        int position = INDEX_INITIAL;
        AddKeyWordType keyWord = AddKeyWordType.UNKNOWN;
        input = input.toUpperCase();
        
        for (AddKeyWordType type : AddKeyWordType.values()) {
            String typeInString = STRING_SINGLE_SPACE + type.toString() + STRING_SINGLE_SPACE;
            if (input.contains(typeInString) && input.lastIndexOf(typeInString) > position) {
                position = input.lastIndexOf(type.toString());
                keyWord = type;
            }
        }

        if (keyWord == AddKeyWordType.UNKNOWN) {
            return STRING_EMPTY;
        } else {
            return keyWord.toString().toLowerCase();
        }
    }
    
    /**
     * Extract the tagRegion by finding the first occurrence of a " #" after the keyWordRegion.
     * If there is no KeyWordRegion, the first occurrence of a " #" in the given string will be return.
     * Return empty string if " #" cannot be found.
     * 
     * @param input             the string used to extract the tagRegion.
     * @param keyWordRegion     the string that separate the descriptionRegion from the tagRegion.
     * @return                  the tagRegion extracted from input.
     */
    private String extractTagRegion(String input, String keyWordRegion) {
        int indexOfTag = getTagRegionIndex(input);
        int indexOfKeyWord = input.lastIndexOf(STRING_SINGLE_SPACE + keyWordRegion + STRING_SINGLE_SPACE);
        if (indexOfTag <= INDEX_INVALID_TAG) {
            return STRING_EMPTY;
        }
        if (keyWordRegion.isEmpty()) {
            return input.substring(indexOfTag + ONE_SPACE);
        }
        
        String afterKeyWord = input.substring(indexOfKeyWord + keyWordRegion.length() + ONE_SPACE);
        indexOfTag = getTagRegionIndex(afterKeyWord);
        if (indexOfTag <= NOT_FOUND) {
            return STRING_EMPTY;
        } else {
            return afterKeyWord.substring(indexOfTag + ONE_SPACE);
        }
    }
    
    /**
     * Extract the descriptionRegion by getting the string before the keyWordRegion.
     * If there is no keyWordRegion, the string before the TagRegion will be return.
     * If there is no keyWordRegion and TagRegion, the given string will be return.
     * 
     * @param input             the string used to extract the descriptionRegion.
     * @param keyWordRegion     the string used to determine the ending point of the descriptionRegion.
     * @param tagRegion         the string used to determine the ending point of the descriptionRegion.
     * @return                  the descriptionRegion extracted from input.
     */
    private String extractDescriptionRegion(String input, String keyWordRegion, String tagRegion) {
        if (keyWordRegion.isEmpty()) {
            if (tagRegion.isEmpty()) {
                return input;
            } else {
                return input.substring(INDEX_INITIAL, input.lastIndexOf(tagRegion));
            }
        } else {
            int indexOfKeyWord = input.lastIndexOf(STRING_SINGLE_SPACE + keyWordRegion + STRING_SINGLE_SPACE);
            return input.substring(INDEX_INITIAL, indexOfKeyWord);
        }
    }
    
    /**
     * Extract the dateRegion by getting the string after the keyWordRegion to before the tagRegion.
     * If there is no keyWordRegion, empty string will be return as dateRegion cannot exist with keyWordRegion
     * 
     * @param input             the string used to extract the dateRegion.
     * @param keyWordRegion     the string used to determine the starting point of the dateRegion.
     * @param tagRegion         the string that ends the dateRegion.
     * @return                  the dateRegion extracted from input.
     */
    private String extractDateRegion(String input, String keyWordRegion, String tagRegion) {
        if (keyWordRegion.isEmpty()) {
            return STRING_EMPTY;
        }
        
        int indexOfTag = input.lastIndexOf(tagRegion);
        int indexOfKeyWord = input.substring(INDEX_INITIAL, indexOfTag).lastIndexOf(STRING_SINGLE_SPACE + keyWordRegion + STRING_SINGLE_SPACE);
        if (tagRegion.isEmpty()) {
            return input.substring(indexOfKeyWord + keyWordRegion.length() + TWO_SPACE);
        } else {
            return input.substring(indexOfKeyWord + keyWordRegion.length() + TWO_SPACE, indexOfTag);
        }
    }
    
    /**
     * Extract the firstDateRegion by getting the string in dateRegion before the "to" inclusive.
     * If the keyWordRegion is not "from", firstDateRegion is assumed to be dateRegion.
     * If "to" is not found in the dateRegion, firstDateRegion is assumed to be dateRegion.
     * 
     * @param dateRegion        the string used to extract the firstDateRegion.
     * @param keyWordRegion     the string that determine if a secondDate might be present.
     * @return                  the firstDateRegion extracted from dateRegion.
     */
    private String extractFirstDateRegion(String dateRegion, String keyWordRegion) {
        if (keyWordRegion.equalsIgnoreCase(AddKeyWordType.FROM.toString())) {
            int keyWordToPosition = dateRegion.indexOf(KEYWORD_TO);
            if (keyWordToPosition > INDEX_INITIAL) {
                return dateRegion.substring(INDEX_INITIAL, keyWordToPosition + KEYWORD_TO.length());
            } else {
                return dateRegion;
            }
        } else {
            return dateRegion;
        }
    }
    
    /**
     * Extract the secondDateRegion by getting the string in dateRegion after the firstDateRegion.
     * 
     * @param dateRegion        the string used to extract the firstDateRegion.
     * @param firstDateRegion   the string used to determine the starting point of the secondDateRegion.
     * @return                  the secondDateRegion extracted from dateRegion.
     */
    private String extractSecondDateRegion(String dateRegion, String firstDateRegion) {
        if (dateRegion.length() <= firstDateRegion.length()) {
            return STRING_EMPTY;
        }
        return dateRegion.substring(firstDateRegion.length());
    }
    
    /**
     * Return the index of the tagRegion in the given string.
     * Return -1 if no tagRegion is found.
     * 
     * @param input        the string used to find the index of the tagRegion.
     * @return             the index of the tagRegion in the given string.
     */
    private int getTagRegionIndex(String input) {
        if (input.contains(KEYWORD_TAG)) {
            return input.indexOf(KEYWORD_TAG);
        } else {
            return NOT_FOUND;
        }
    }
    
    /**
     * Return the descriptionRegion extracted form the string.
     * 
     * @return  the descriptionRegion.
     */
    public String getDescriptionRegion() {
        return _descriptionRegion;
    }
    
    /**
     * Return the keyWordRegion extracted form the string.
     * 
     * @return  the keyWordRegion.
     */
    public String getKeyWordRegion() {
        return _keyWordRegion;
    }
    
    /**
     * Return the firstDateRegion extracted form the string.
     * 
     * @return  the firstDateRegion.
     */
    public String getFirstDateRegion() {
        return _firstDateRegion;
    }
    
    /**
     * Return the secondDateRegion extracted form the string.
     * 
     * @return  the secondDateRegion.
     */
    public String getSecondDateRegion() {
        return _secondDateRegion;
    }
    
    /**
     * Return the tagRegion extracted form the string.
     * 
     * @return  the tagRegion.
     */
    public String getTagRegion() {
        return _tagRegion;
    }
}
```
###### \ArchPlanner\interpreter\separater\DateInterpreter.java
``` java
 */
public class DateInterpreter {
    static Logger log = Logger.getLogger(DateInterpreter.class.getName());
    
    private static final String LOG_MESSAGE_MORE_THAN_ONE_DATE_FOUND = "More than one date found: ";
    private static final String LOG_MESSAGE_EXTRA_WORDS_ARE_FOUND = "Extra words found: ";
    private static final String LOG_MESSAGE_DATE_FOUND = "Valid Date found: ";
    private static final String LOG_MESSAGE_NO_DATE_FOUND = "No Date found: ";
    
    private static final int INDEX_OF_FIRST_DATE = 0;
    
    private String _dateRegion;
    private Date _dateTime;
    private boolean _hasDate;
    private boolean _hasTime;
    
    /**
     * Interpret the given string to a Date Object and checking if date and time is present in the Date.
     * No Date is present if the string contains other words that do not represent date or time.
     * 
     * @param dateRegion    the string that will be interpreted to Date Object
     */
    public DateInterpreter(String dateRegion) {
        _dateRegion = dateRegion.trim();
        DateGroup dateGroup = getDateGroup(dateRegion.toLowerCase());
        _dateTime = getDate(dateGroup);
        _hasDate = isDatePresent(dateGroup);
        _hasTime = isTimePresent(dateGroup);
    }
    
    /**
     * Interpret the given string to a Date Group. 
     * null will be return:
     * 1. no Date is found
     * 2. more than one Date is found
     * 3. additional words not representing the date is in the string
     * 
     * @param dateRegion    the string to be interpreted.
     * @return              the DateGroup containing the Date.
     */
    private DateGroup getDateGroup(String dateRegion) {
        Parser parser = new Parser();
        try {
            DateGroup dateGroup = parser.parse(dateRegion).get(INDEX_OF_FIRST_DATE);
            if (dateGroup.getText().equals(dateRegion)) {
                if (dateGroup.getDates().size() == 1) {
                    log.info(LOG_MESSAGE_DATE_FOUND + dateRegion);
                    return dateGroup;
                } else {
                    log.info(LOG_MESSAGE_MORE_THAN_ONE_DATE_FOUND + dateRegion);
                    return null;
                }
            } else {
                log.info(LOG_MESSAGE_EXTRA_WORDS_ARE_FOUND + dateRegion);
                return null;
            }
        } catch (IndexOutOfBoundsException e) {
            log.info(LOG_MESSAGE_NO_DATE_FOUND + dateRegion);
            return null;
        }
    }
    
    /**
     * Return the Date object in the DateGroup.
     * Return null if DateGroup is null.
     * 
     * @param dateGroup     the DateGroup containing the Date.
     * @return              Date object found in DateGroup
     */
    private Date getDate(DateGroup dateGroup) {
        if (dateGroup != null) {
            return dateGroup.getDates().get(INDEX_OF_FIRST_DATE);
        } else {
            return null;
        }
    }
    
    /**
     * Check if the date is interpreted from the string in the DateGroup
     * Return false if DateGroup is null.
     * 
     * @param dateGroup     the DateGroup containing the Date.
     * @return              whether interpreted date from the string in the DateGroup
     */
    private boolean isDatePresent(DateGroup dateGroup) {
        if (dateGroup != null && !dateGroup.isDateInferred())  {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Check if the time is interpreted from the string in the DateGroup
     * Return null if DateGroup is null.
     * 
     * @param dateGroup     the DateGroup containing the Date.
     * @return              whether interpreted time from the string in the DateGroup
     */
    private boolean isTimePresent(DateGroup dateGroup) {
        if (dateGroup != null && !dateGroup.isTimeInferred())  {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * Return the interpreted Date.
     *
     * @return  the interpreted Date.
     */
    public boolean hasDate() {
        return _hasDate;
    }
    
    /**
     * Return whether date is found in string.
     *
     * @return  whether date is found in string.
     */
    public boolean hasTime() {
        return _hasTime;
    }
    
    /**
     * Return whether time is found in string.
     *
     * @return  whether time is found in string.
     */
    public Date getDateTime() {
        return _dateTime;
    }
    
    /**
     * Return original string.
     *
     * @return  original string.
     */
    public String getDateRegion() {
        return _dateRegion;
    }
}
```
###### \ArchPlanner\test\prompt\AddPromptTest.java
``` java
 */
public class AddPromptTest {
    ArrayList<String> prompts;
    Prompt promptObj;
    
    @Before
    public void setUp() throws Exception {
        prompts = new ArrayList<String>();
        promptObj = new Prompt();
    }
    
    @Test
    public void testDescriptionRegion() {
        prompts = promptObj.getPrompts("add ");
        assertEquals(1, prompts.size());
        assertEquals("add <Description>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description ");
        assertEquals(4, prompts.size());
        assertEquals("add <Description> #<Tag>", prompts.get(0));
        assertEquals("add <Description> on <Start Date>", prompts.get(1));
        assertEquals("add <Description> by <End Date>", prompts.get(2));
        assertEquals("add <Description> from <Start Date> to <End Date>", prompts.get(3));
    }
    
    @Test
    public void testKeyWordRegion() {
        prompts = promptObj.getPrompts("add description on ");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> on <Start Date>", prompts.get(0));
        assertEquals("add <Description> on <Start Time>", prompts.get(1));
        
        prompts = promptObj.getPrompts("add description by ");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> by <End Date>", prompts.get(0));
        assertEquals("add <Description> by <End Time>", prompts.get(1));
        
        prompts = promptObj.getPrompts("add description from ");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> from <Start Date>", prompts.get(0));
        assertEquals("add <Description> from <Start Time>", prompts.get(1));
    }
    
    @Test
    public void testKeyWordOnFirstDateRegion() {
        prompts = promptObj.getPrompts("add description on today");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> on <Start Date>", prompts.get(0));
        assertEquals("add <Description> on <Start Date> #<Tag>", prompts.get(1));
        assertEquals("add <Description> on <Start Date> <Start Time>", prompts.get(2));
        
        prompts = promptObj.getPrompts("add description on 1pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> on <Start Time>", prompts.get(0));
        assertEquals("add <Description> on <Start Time> #<Tag>", prompts.get(1));
        
        prompts = promptObj.getPrompts("add description on today 1pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> on <Start Date> <Start Time>", prompts.get(0));
        assertEquals("add <Description> on <Start Date> <Start Time> #<Tag>", prompts.get(1));
    }
    
    @Test
    public void testKeyWordByFirstDateRegion() {
        prompts = promptObj.getPrompts("add description by today");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> by <End Date>", prompts.get(0));
        assertEquals("add <Description> by <End Date> #<Tag>", prompts.get(1));
        assertEquals("add <Description> by <End Date> <End Time>", prompts.get(2));
        
        prompts = promptObj.getPrompts("add description by 1pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> by <End Time>", prompts.get(0));
        assertEquals("add <Description> by <End Time> #<Tag>", prompts.get(1));
        
        prompts = promptObj.getPrompts("add description by today 1pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> by <End Date> <End Time>", prompts.get(0));
        assertEquals("add <Description> by <End Date> <End Time> #<Tag>", prompts.get(1));
    }
    
    @Test
    public void testKeyWordFromFirstDateRegion() {
        prompts = promptObj.getPrompts("add description from today");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> from <Start Date> to <End Date>", prompts.get(0));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Time>", prompts.get(1));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time>", prompts.get(2));
        
        prompts = promptObj.getPrompts("add description from 1pm");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> from <Start Time> to <End Time>", prompts.get(0));
        assertEquals("add <Description> from <Start Time> to <End Date>", prompts.get(1));
        assertEquals("add <Description> from <Start Time> to <End Date> <End Time>", prompts.get(2));
        
        prompts = promptObj.getPrompts("add description from today 1pm");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Time>", prompts.get(0));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date>", prompts.get(1));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time>", prompts.get(2));
    }
    
    @Test
    public void testKeyWordFromSecondDateRegion() {
        prompts = promptObj.getPrompts("add description from today 1pm to tomorrow");
        assertEquals(3, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date>", prompts.get(0));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> #<Tag>", prompts.get(1));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time>", prompts.get(2));
        
        prompts = promptObj.getPrompts("add description from today 1pm to 2pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Time>", prompts.get(0));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Time> #<Tag>", prompts.get(1));
        
        prompts = promptObj.getPrompts("add description from today 1pm to tomorrow 2pm");
        assertEquals(2, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time>", prompts.get(0));
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time> #<Tag>", prompts.get(1));
    }
    
    @Test
    public void testTagRegion() {
        prompts = promptObj.getPrompts("add description #tag");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description on today #tag");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> on <Start Date> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description by today 1pm #tag");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> by <End Date> <End Time> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description from today 1pm to tomorrow #tag");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description from today 1pm to tomorrow 2pm #tag");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> from <Start Date> <Start Time> to <End Date> <End Time> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description #tag #tag2");
        assertEquals(1, prompts.size());
        assertEquals("add <Description> #<Tag> #<Tag>", prompts.get(0));
    }
    
    @Test
    public void testInvalidTag() {
        prompts = promptObj.getPrompts("add description # ");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Tag: add <Description> #<Tag>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description #tag invalid");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Tag: add <Description> #<Tag> #<Tag>", prompts.get(0));
    }
    
    @Test
    public void testInvalidDateRange() {
        prompts = promptObj.getPrompts("add description from tomorrow to today");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Date Range: add <Description> from <Start Date> to <End Date>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description from tomorrow 1pm to 12pm");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Date Range: add <Description> from <Start Date> <Start Time> to <End Time>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description from 1pm to today 12pm");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Date Range: add <Description> from <Start Time> to <End Date> <End Time>", prompts.get(0));
        
        prompts = promptObj.getPrompts("add description from 1pm to 12pm");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Date Range: add <Description> from <Start Time> to <End Time>", prompts.get(0));
    }
    
    @Test
    public void testInvalidDateRangeAndTag() {
        prompts = promptObj.getPrompts("add description from tomorrow to today # ");
        assertEquals(1, prompts.size());
        assertEquals("Invalid Date Range and Tag: add <Description> from <Start Date> to <End Date> #<Tag>", prompts.get(0));
    }
}
```
###### \ArchPlanner\test\prompt\CommandPromptTest.java
``` java
 */
public class CommandPromptTest {

    ArrayList<String> prompts;
    Prompt promptObj;
    
    @Before
    public void setUp() throws Exception {
        prompts = new ArrayList<String>();
        promptObj = new Prompt();
    }
    
    @Test
    public void testCommandPrompts() {
        prompts = promptObj.getPrompts("a");
        assertEquals(1, prompts.size());
        assertEquals("add", prompts.get(0));
     
        prompts = promptObj.getPrompts("s");
        assertEquals(1, prompts.size());
        assertEquals("set", prompts.get(0));
        
        prompts = promptObj.getPrompts("r");
        assertEquals(1, prompts.size());
        assertEquals("redo", prompts.get(0));
   
        prompts = promptObj.getPrompts("v");
        assertEquals(1, prompts.size());
        assertEquals("view", prompts.get(0));
        
        prompts = promptObj.getPrompts("u");
        assertEquals(2, prompts.size());
        assertEquals("undone", prompts.get(0));
        assertEquals("undo", prompts.get(1));
        
        prompts = promptObj.getPrompts("undon");
        assertEquals(1, prompts.size());
        assertEquals("undone", prompts.get(0));
        
        prompts = promptObj.getPrompts("d");
        assertEquals(2, prompts.size());
        assertEquals("delete", prompts.get(0));
        assertEquals("done", prompts.get(1));
        
        prompts = promptObj.getPrompts("de");
        assertEquals(1, prompts.size());
        assertEquals("delete", prompts.get(0));
        
        prompts = promptObj.getPrompts("do");
        assertEquals(1, prompts.size());
        assertEquals("done", prompts.get(0));
        
        prompts = promptObj.getPrompts("e");
        assertEquals(2, prompts.size());
        assertEquals("edit", prompts.get(0));
        assertEquals("exit", prompts.get(1));
        
        prompts = promptObj.getPrompts("ed");
        assertEquals(1, prompts.size());
        assertEquals("edit", prompts.get(0));
        
        prompts = promptObj.getPrompts("ex");
        assertEquals(1, prompts.size());
        assertEquals("exit", prompts.get(0));
    }

}
```
