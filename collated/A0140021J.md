# A0140021J
###### \ArchPlanner\logic\commands\AddCommand.java
``` java
 *
 */
public class AddCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the taskParameters of an AddCommand object.
	private TaskParameters _taskParameters;

	//This is the message of an AddCommand object to be displayed.
	private String _message;

	//This constant string variable is the standard format for display message upon adding of task successfully.
	private final String MESSAGE_ADD_COMMAND = "added \"%1$s\"";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_ADD_COMMAND = "Executing add command...";
	private final String  LOGGER_MESSAGE_COMPLETED_ADD_COMMAND = "Completed add command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public AddCommand(TaskParameters newTaskParameters) {
		_taskParameters = new TaskParameters();
		_taskParameters = newTaskParameters;
		_message = STRING_EMPTY;
	}

	/**
	 * This is setter method for AddCommand's taskParameters.
	 * 
	 * @param taskParameters	This will be the taskParameters of the AddCommand.
	 */
	public void setTaskParameters(Task taskParameters) {
		_taskParameters = taskParameters;
	}

	/**
	 * This is setter method for AddCommand's message.
	 * 
	 * @param message	This will be the message of the AddCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for AddCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This is getter method for AddCommand's taskParameters.
	 * 
	 * @return	taskParameters.
	 */
	public TaskParameters getTaskParameters() {
		return _taskParameters;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute add command and add the task followed by updating the relevant lists.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		log.info(LOGGER_MESSAGE_EXECUTING_ADD_COMMAND);
		clearIndexList(listsManager);
		Task newTask = new Task(getTaskParameters().getDescription(), getTaskParameters().getTagsList(), 
				getTaskParameters().getStartDate(), getTaskParameters().getStartTime(), 
				getTaskParameters().getEndDate(), getTaskParameters().getEndTime());
		setMessage(String.format(MESSAGE_ADD_COMMAND, getTaskParameters().getDescription()));
		updateManagers(listsManager, historyManager, newTask);
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_ADD_COMMAND);
		return null;
	}

	/**
	 * This method is used to update ListsManager and HistoryManager.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param historyManager	This is the HistoryManager.
	 * @param newTask			This is the task to be added.
	 */
	private void updateManagers(ListsManager listsManager, HistoryManager historyManager, Task newTask) {
		updateListsManager(listsManager, newTask);
		updateHistoryManager(historyManager, newTask);
	}

	/**
	 * This method is used to clear the index list in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to update HistoryManager.
	 * 
	 * @param historyManager	This is the HistoryManager.
	 * @param newTask			This is the task to be added.
	 */
	private void updateHistoryManager(HistoryManager historyManager, Task newTask) {
		RollbackItem rollbackItem = new RollbackItem(COMMAND_TYPE.ADD, null, newTask);
		historyManager.getUndoList().add(rollbackItem);
		historyManager.setRedoList(new ArrayList<RollbackItem>());
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param newTask		This is the task to be added.
	 */
	private void updateListsManager(ListsManager listsManager, Task newTask) {
		listsManager.getMainList().add(newTask);
		listsManager.getSelectedTagsList().clear();
		listsManager.setViewType(VIEW_TYPE.ALL);
		listsManager.setCategoryType(CATEGORY_TYPE.ALL);
		listsManager.updateLists();
		listsManager.updateIndexList(newTask);
	}
}
```
###### \ArchPlanner\logic\commands\CommandInterface.java
``` java
 *
 */
public interface CommandInterface {
	CommandInterface execute();
	CommandInterface execute(ListsManager listsManager, Storage storage);
	CommandInterface execute(ListsManager listsManager, HistoryManager historyManager);
	String getMessage();
}
```
###### \ArchPlanner\logic\commands\DeleteCommand.java
``` java
 *
 */
public class DeleteCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the first index of task in the list to be deleted.
	private int _firstIndex;

	//This is the last index of task in the list to be deleted.
	private int _lastIndex;

	//This is the message of an DeleteCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message upon deleting of tasks successfully.
	private final String MESSAGE_DELETE_COMMAND = "deleted \"%1$s\"";
	private final String MESSAGE_MULTIPLE_DELETE_COMMAND = "deleted multiple tasks";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_DELETE_COMMAND = "Executing delete command...";
	private final String  LOGGER_MESSAGE_COMPLETED_DELETE_COMMAND = "Completed delete command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public DeleteCommand(int index) {
		_firstIndex = index - 1;
		_lastIndex = index - 1;
		_message = STRING_EMPTY;
	}

	//This is constructor of the class.
	public DeleteCommand(int firstIndex, int lastIndex) {
		_firstIndex = firstIndex - 1;
		_lastIndex = lastIndex - 1;
		_message = "";
	}

	/**
	 * This is setter method for DeleteCommand's firstIndex.
	 * 
	 * @param index	This will be firstIndex of the DeleteCommand.
	 */
	public void setFirstIndex(int index) {
		_firstIndex = index;
	}

	/**
	 *  This is setter method for DeleteCommand's lastIndex.
	 *  
	 * @param index	This will be lastIndex of the DeleteCommand.
	 */
	public void setLastIndex(int index) {
		_lastIndex = index;
	}

	/**
	 * This is setter method for DeleteCommand's message.
	 * 
	 * @param message	This will be the message of the DeleteCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for DeleteCommand's firstIndex.
	 * 
	 * @return	firstIndex.
	 */
	public int getFirstIndex() {
		return _firstIndex;
	}

	/**
	 * This is getter method for DeleteCommand's lastIndex.
	 * 
	 * @return	lastIndex.
	 */
	public int getLastIndex() {
		return _lastIndex;
	}

	/**
	 * This is getter method for DeleteCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute delete command and delete the task followed by updating the relevant lists.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert(getFirstIndex() >= 0 && getFirstIndex() < listsManager.getViewList().size());
		assert(getLastIndex() >= 0 && getLastIndex() < listsManager.getViewList().size());

		log.info(LOGGER_MESSAGE_EXECUTING_DELETE_COMMAND);
		clearIndexList(listsManager);

		Task oldTask = null;
		int numOfDeletion = getLastIndex() - getFirstIndex() + 1;

		for (int i = 0; i < numOfDeletion; i++) {
			oldTask = listsManager.getViewList().get(getFirstIndex());
			updateManagers(listsManager, historyManager, oldTask, numOfDeletion);
		}
		updateMessage(oldTask, numOfDeletion);
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_DELETE_COMMAND);
		return null;
	}

	/**
	 * This method is used to update message of the DeleteCommand upon deleting of tasks.
	 * 
	 * @param oldTask		This is the task to be deleted.
	 * @param numOfDeletion	This is the number of tasks to be deleted.
	 */
	private void updateMessage(Task oldTask, int numOfDeletion) {
		if (numOfDeletion == 1) {
			setMessage(String.format(MESSAGE_DELETE_COMMAND, oldTask.getDescription()));
		} else {
			setMessage(MESSAGE_MULTIPLE_DELETE_COMMAND);
		}
	}

	/**
	 * This method is used to update the ListsManager and HistoryManager.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param historyManager	This is the HistoryManager.
	 * @param oldTask			This is the task to be deleted.
	 * @param numOfDeletion		This is the number of tasks to be deleted.
	 */
	private void updateManagers(ListsManager listsManager, HistoryManager historyManager, Task oldTask,
			int numOfDeletion) {
		updateListsManager(listsManager, oldTask);
		updateHistoryManager(historyManager, oldTask, numOfDeletion);
	}

	/**
	 * This method is used to clear indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to update HistoryManager.
	 * 
	 * @param historyManager	This is the HistoryManager.
	 * @param oldTask			This is the task to be deleted.
	 * @param numOfDeletion		This is the number of tasks to be deleted.
	 */
	private void updateHistoryManager(HistoryManager historyManager, Task oldTask, int numOfDeletion) {
		RollbackItem rollbackItem = new RollbackItem(COMMAND_TYPE.DELETE, oldTask, null, numOfDeletion);
		historyManager.getUndoList().add(rollbackItem);
		historyManager.setRedoList(new ArrayList<RollbackItem>());
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param oldTask		This is the task to be deleted.
	 */
	private void updateListsManager(ListsManager listsManager, Task oldTask) {
		listsManager.getMainList().remove(oldTask);
		listsManager.updateLists();
	}
}
```
###### \ArchPlanner\logic\commands\DoneCommand.java
``` java
 *
 */
public class DoneCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the first index of task in the list to be done.
	private int _firstIndex;

	//This is the last index of task in the list to be done.
	private int _lastIndex;

	//This is the message of an DoneCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message when tasks are set to done successfully.
	private final String MESSAGE_DONE_COMMAND = "done \"%1$s\"";
	private final String MESSAGE_MULTIPLE_DONE_COMMAND = "done multiple tasks";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_DONE_COMMAND = "Executing done command...";
	private final String  LOGGER_MESSAGE_COMPLETED_DONE_COMMAND = "Completed done command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public DoneCommand(int index) {
		_firstIndex = index - 1;
		_lastIndex = index - 1;
		_message = STRING_EMPTY;
	}

	//This is constructor of the class.
	public DoneCommand(int firstIndex, int lastIndex) {
		_firstIndex = firstIndex - 1;
		_lastIndex = lastIndex - 1;
		_message = STRING_EMPTY;
	}

	/**
	 * This is setter method for DoneCommand's firstIndex.
	 * 
	 * @param index	This will be the firstIndex of the DoneCommand.
	 */
	public void setFirstIndex(int index) {
		_firstIndex = index;
	}

	/**
	 * This is setter method for DoneCommand's lastIndex.
	 * 
	 * @param index	This will be the lastIndex of the DoneCommand.
	 */
	public void setLastIndex(int index) {
		_lastIndex = index;
	}

	/**
	 * This is setter method for DoneCommand's message.
	 * 
	 * @param message	This will be the message of the DoneCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for DoneCommand's firstIndex.
	 * 
	 * @return	firstIndex.
	 */
	public int getFirstIndex() {
		return _firstIndex;
	}

	/**
	 * This is getter command for DoneCommand's lastIndex.
	 * 
	 * @return	lastIndex.
	 */
	public int getLastIndex() {
		return _lastIndex;
	}

	/**
	 * This is getter command for DoneCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute done command and the task will be set to done, followed by updating the relevant lists.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert(getFirstIndex() >= 0 && getFirstIndex() < listsManager.getViewList().size());
		assert(getLastIndex() >= 0 && getLastIndex() < listsManager.getViewList().size());

		log.info(LOGGER_MESSAGE_EXECUTING_DONE_COMMAND);
		clearIndexList(listsManager);

		int numOfDone = getLastIndex() - getFirstIndex() + 1;
		Task oldTask = null;
		ArrayList<Task> doneTasksList = new ArrayList<Task>();
		for (int i = 0; i < numOfDone; i++) {
			oldTask = listsManager.getViewList().get(_firstIndex);
			listsManager.getMainList().remove(oldTask);
			Task newTask = new Task();
			initializeNewTask(oldTask, newTask);
			doneTasksList.add(newTask);
			updateManagers(listsManager, historyManager, numOfDone, oldTask, newTask);
		}
		updateIndexList(listsManager, doneTasksList);
		updateMessage(numOfDone, oldTask);
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_DONE_COMMAND);
		return null;

	}

	/**
	 * This method is used to update DoneCommand's message.
	 * 
	 * @param numOfDone	This is the number of tasks to be set to done.
	 * @param oldTask	This is the task before been set to done.
	 */
	private void updateMessage(int numOfDone, Task oldTask) {
		if (numOfDone == 1) {
			setMessage(String.format(MESSAGE_DONE_COMMAND, oldTask.getDescription()));
		} else {
			setMessage(MESSAGE_MULTIPLE_DONE_COMMAND);
		}
	}

	/**
	 * This method is used to update indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param doneTasksList	This is the list of tasks set to done.
	 */
	private void updateIndexList(ListsManager listsManager, ArrayList<Task> doneTasksList) {
		for (int i = 0; i < doneTasksList.size(); i++) {
			Task doneTask = doneTasksList.get(i);
			listsManager.updateIndexList(doneTask);
		}
	}

	/**
	 * This method is used to update ListsManager and HistoryManager.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param historyManager	This is the HistoryManager.
	 * @param numOfDone			This is the number of tasks to be set to done.
	 * @param oldTask			This is the task before been set to done.
	 * @param newTask			This is the task after been set to done.
	 */
	private void updateManagers(ListsManager listsManager, HistoryManager historyManager, int numOfDone, Task oldTask,
			Task newTask) {
		updateListsManager(listsManager, newTask);
		updateHistoryManager(historyManager, oldTask, newTask, numOfDone);
	}

	/**
	 * This method is used to clear indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to update the HistoryManager.
	 * 
	 * @param historyManager	This is the HistoryManager.
	 * @param oldTask			This is the task before been set to done.
	 * @param newTask			This is the task after been set to done.
	 * @param numOfDone			This is the number of tasks to be set to done.
	 */
	private void updateHistoryManager(HistoryManager historyManager, Task oldTask, Task newTask, int numOfDone) {
		RollbackItem rollbackItem = new RollbackItem(COMMAND_TYPE.DONE, oldTask, newTask, numOfDone);
		historyManager.getUndoList().add(rollbackItem);
		historyManager.setRedoList(new ArrayList<RollbackItem>());
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param newTask		This is the task to be set to done.
	 */
	private void updateListsManager(ListsManager listsManager, Task newTask) {
		listsManager.getMainList().add(newTask);
		listsManager.updateLists();
	}

	/**
	 * This method is used to initialize the new task with the properties of old task but done status is set to true.
	 * 
	 * @param oldTask	This is the task before been set to done.
	 * @param newTask	This is the task after been set to done.
	 */
	private void initializeNewTask(Task oldTask, Task newTask) {
		newTask.setDescription(oldTask.getDescription());
		newTask.setTagsList(oldTask.getTagsList());
		newTask.setStartDate(oldTask.getStartDate());
		newTask.setStartTime(oldTask.getStartTime());
		newTask.setEndDate(oldTask.getEndDate());
		newTask.setEndTime(oldTask.getEndTime());
		newTask.setIsOverdue(oldTask.getIsOverdue());
		newTask.setIsDone(true);
	}
}
```
###### \ArchPlanner\logic\commands\EditCommand.java
``` java
 *
 */
public class EditCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the taskParameters of an EditCommand object.
	private TaskParameters _taskParameters;

	//This is the invalidCommand to be initialized if edit command is invalid.
	private InvalidCommand _invalidCommand;

	//This is the index of the task to be edited.
	private int _index;

	//This variable indicates which parameter of the task to be removed.
	private REMOVE_TYPE _removeType;

	//This is the message of an EditCommand object to be displayed.
	private String _message;

	//These are constant string variables of error messages to be displayed if edit command is invalid.
	private final String ERROR_MESSAGE_INVALID_START_DATE = "Invalid start date";
	private final String ERROR_MESSAGE_INVALID_START_DATE_TIME = "Invalid start date and time";
	private final String ERROR_MESSAGE_INVALID_START_TIME = "Invalid start time";
	private final String ERROR_MESSAGE_INVALID_END_DATE = "Invalid end date";
	private final String ERROR_MESSAGE_INVALID_END_DATE_TIME = "Invalid end date and time";
	private final String ERROR_MESSAGE_INVALID_END_TIME = "Invalid end time";
	private final String ERROR_MESSAGE_NO_START_DATE = "The task has no start date";
	private final String ERROR_MESSAGE_NO_END_DATE = "The task has no end date";

	//These constant string variables are used to indicate start and end of date and time.
	private static final int FIRST_HOUR_OF_DAY = 0;
	private static final int FIRST_MINUTE_OF_HOUR = 0;
	private static final int LAST_HOUR_OF_DAY = 23;
	private static final int LAST_MINUTE_OF_HOUR = 59;

	//This constant string variable is the standard format for display message upon editing of task successfully.
	private final String MESSAGE_EDIT_COMMAND = "edited \"%1$s\"";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_EDIT_COMMAND = "Executing edit command...";
	private final String  LOGGER_MESSAGE_COMPLETED_EDIT_COMMAND = "Completed edit command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	public enum REMOVE_TYPE {
		START, START_TIME, END, END_TIME, TAG, NONE
	}

	//This is constructor of the class.
	public EditCommand(int index, TaskParameters newTaskParameters) {
		assert(index >= 1);
		_taskParameters = newTaskParameters;
		_index = index - 1;
		_removeType= REMOVE_TYPE.NONE;
		_message = STRING_EMPTY;
	}

	//This is constructor of the class.
	public EditCommand(int index, TaskParameters newTaskParameters, REMOVE_TYPE removeType) {
		assert(index >= 1);
		_taskParameters = newTaskParameters;
		_index = index - 1;
		_removeType = removeType;
		_message = STRING_EMPTY;
	}

	/**
	 * This is setter method for EditCommand's taskParameters.
	 * 
	 * @param taskParameters	This will be the taskParameters of the EditCommand.
	 */
	public void setTaskParameters(Task taskParameters) {
		_taskParameters = taskParameters;
	}

	/**
	 * This is setter method for EditCommand's invalidCommand.
	 * 
	 * @param invalidCommand	This will be the invalidCommand of the EditCommand.
	 */
	public void setInvalidCommand(InvalidCommand invalidCommand) {
		_invalidCommand = invalidCommand;
	}

	/**
	 * This is setter method for EditCommand's index.
	 * 
	 * @param index	This will be the index of the EditCommand.
	 */
	public void setIndex(int index) {
		_index = index;
	}

	/**
	 * This is setter method for EditCommand's removeType.
	 * 
	 * @param removeType	This will be the removeType of the EditCommand.
	 */
	public void setRemoveType(REMOVE_TYPE removeType) {
		_removeType = removeType;
	}

	/**
	 * This is setter method for EditCommand's message.
	 * 
	 * @param message	This will be the message of EditCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for EditCommand's taskParameters.
	 * 
	 * @return	taskParameters.
	 */
	public TaskParameters getTaskParameters() {
		return _taskParameters;
	}

	/**
	 * This is getter method for EditCommand's invalidCommand.
	 * 
	 * @return	invalidCommand.
	 */
	public InvalidCommand getInvalidCommand() {
		return _invalidCommand;
	}

	/**
	 * This is getter method for EditCommand's index.
	 * 
	 * @return	index.
	 */
	public int getIndex() {
		return _index;
	}

	/**
	 * This is getter method for EditCommand's removeType.
	 * 
	 * @return	removeType.
	 */
	public REMOVE_TYPE getRemoveType() {
		return _removeType;
	}

	/**
	 * This is getter method for EditCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute edit command and edit the task followed by updating the relevant lists.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert((getIndex() >= 0) && (getIndex() < listsManager.getViewList().size()));

		log.info(LOGGER_MESSAGE_EXECUTING_EDIT_COMMAND);
		clearIndexList(listsManager);
		Task oldTask = listsManager.getViewList().get(getIndex());

		Task newTask = new Task();
		initializeNewTask(oldTask, newTask);

		LocalTime startTime = LocalTime.of(FIRST_HOUR_OF_DAY, FIRST_MINUTE_OF_HOUR);
		LocalTime endTime = LocalTime.of(LAST_HOUR_OF_DAY, LAST_MINUTE_OF_HOUR);

		editTask(oldTask, newTask, startTime, endTime);

		if (getInvalidCommand() != null) {
			log.info(getInvalidCommand().getMessage());
			return getInvalidCommand();
		}
		setMessage(String.format(MESSAGE_EDIT_COMMAND, newTask.getDescription()));
		updateListsManager(listsManager, oldTask, newTask);
		updateHistoryManager(historyManager, oldTask, newTask);
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_EDIT_COMMAND);
		return null;
	}

	/**
	 * This method is used to clear indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to update HistoryManager.
	 * 
	 * @param historyManager	This is the HistoryManager.
	 * @param oldTask			This is the task before been edited.
	 * @param newTask			This is the task after been edited.
	 */
	private void updateHistoryManager(HistoryManager historyManager, Task oldTask, Task newTask) {
		RollbackItem rollbackItem = new RollbackItem(COMMAND_TYPE.EDIT, oldTask, newTask);
		historyManager.getUndoList().add(rollbackItem);
		historyManager.setRedoList(new ArrayList<RollbackItem>());
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager		This is the listsManager.
	 * @param oldTask			This is the task before been edited.
	 * @param newTask			This is the task after been edited.
	 */
	private void updateListsManager(ListsManager listsManager, Task oldTask, Task newTask) {
		listsManager.getMainList().remove(oldTask);
		listsManager.getMainList().add(newTask);
		listsManager.updateLists();
		listsManager.updateIndexList(newTask);
	}

	/**
	 * This method is used to initialize the new task with old task properties.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 */
	private void initializeNewTask(Task oldTask, Task newTask) {
		newTask.setDescription(oldTask.getDescription());
		newTask.setTagsList(oldTask.getTagsList());
		newTask.setStartDate(oldTask.getStartDate());
		newTask.setStartTime(oldTask.getStartTime());
		newTask.setEndDate(oldTask.getEndDate());
		newTask.setEndTime(oldTask.getEndTime());
		newTask.setIsDone(oldTask.getIsDone());
		newTask.setIsOverdue(oldTask.getIsOverdue());
	}

	/**
	 * This method is used to edit the tasks based on edit command attributes.
	 * 
	 * @param oldTask		This is the task before been edited.
	 * @param newTask		This is the task after been edited.
	 * @param startTime		This is the start time at 12:00am.
	 * @param endTime		This is the end time at 11:59pm.
	 */
	private void editTask(Task oldTask, Task newTask, LocalTime startTime, LocalTime endTime) {
		editTaskDescription(newTask);
		editTaskTagsList(newTask);
		editTaskStartDateOnly(oldTask, newTask, startTime);
		editTaskStartTimeOnly(oldTask, newTask, endTime);
		editTaskStartDateTime(oldTask, newTask, endTime);
		editTaskEndDateOnly(oldTask, newTask, endTime);
		editTaskEndTimeOnly(oldTask, newTask, startTime);
		editTaskEndDateTime(oldTask, newTask, startTime);
		editTaskStartDateTimeEndDateTime(oldTask, newTask, endTime);
		editTaskStartDateEndDate(oldTask, newTask, endTime);
		removeTaskParameters(oldTask, newTask);
	}

	/**
	 * This method is used to differentiate the removeType and execute the respective method for removing taskParameters.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskParameters(Task oldTask, Task newTask) {
		switch (_removeType) {
		case START : 
			removeTaskStartDate(newTask);
			break;
		case START_TIME :
			removeTaskStartTime(oldTask, newTask);
			break;
		case END :
			removeTaskEndDate(oldTask, newTask);
			break;
		case END_TIME :
			removeTaskEndTime(oldTask, newTask);
			break;
		case TAG :
			removeTaskTagsList(newTask);
			break;
		default :
			break;
		}
	}

	/**
	 * This method is used to clear tagsList of the task.
	 * 
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskTagsList(Task newTask) {
		newTask.getTagsList().clear();
	}

	/**
	 * This method is used to remove end time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskEndTime(Task oldTask, Task newTask) {
		if (oldTask.getStartDate() != null && oldTask.getStartTime() != null && oldTask.getEndDate() != null 
				&& oldTask.getEndTime() != null) {
			newTask.setStartTime(null);
		}
		newTask.setEndTime(null);
	}

	/**
	 * This method is used to remove end time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskEndDate(Task oldTask, Task newTask) {
		newTask.setEndDate(null);
		newTask.setEndTime(null);
	}

	/**
	 *This method is used to remove start time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskStartTime(Task oldTask, Task newTask) {
		if ((oldTask.getStartDate() != null) && (oldTask.getStartTime() != null) && (oldTask.getEndDate() != null)
				&& (oldTask.getEndTime() != null)) {
			newTask.setEndTime(null);
		}
		newTask.setStartTime(null);
	}

	/**
	 * This method is used to remove start date of the task.
	 * 
	 * @param newTask	This is the task after been edited.
	 */
	private void removeTaskStartDate(Task newTask) {
		newTask.setStartDate(null);
		newTask.setStartTime(null);
	}

	/**
	 * This method is used to edit start date and end date of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param endTime	This is the end time at 11:59pm.
	 */
	private void editTaskStartDateEndDate(Task oldTask, Task newTask, LocalTime endTime) {
		if (hasTaskParametersStartDateNotEqualsNullAndStartTimeEqualsNull() 
				&& hasTaskParametersEndDateNotEqualsNullAndEndTimeEqualsNull()) {
			newTask.setStartDate(getTaskParameters().getStartDate());
			newTask.setEndDate(getTaskParameters().getEndDate());
			newTask.setStartTime(null);
			newTask.setEndTime(null);
		}
	}

	/**
	 * This method is used to edit start date time and end date time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param endTime	This is the end time at 11:59pm.
	 */
	private void editTaskStartDateTimeEndDateTime(Task oldTask, Task newTask, LocalTime endTime) {
		if (hasTaskParametersStartDateNotEqualsNullAndStartTimeNotEqualsNull() 
				&& hasTaskParametersEndDateNotEqualsNullAndEndTimeNotEqualsNull()) {
			newTask.setStartDate(getTaskParameters().getStartDate());
			newTask.setStartTime(getTaskParameters().getStartTime());
			newTask.setEndDate(getTaskParameters().getEndDate());
			newTask.setEndTime(getTaskParameters().getEndTime());
		}
	}

	/**
	 * This method is used to edit end date time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param startTime	This is the start time at 12:00am.
	 */
	private void editTaskEndDateTime(Task oldTask, Task newTask, LocalTime startTime) {
		if (hasTaskParametersStartDateEqualsNullAndStartTimeEqualsNull() 
				&& hasTaskParametersEndDateNotEqualsNullAndEndTimeNotEqualsNull()) {
			if (oldTask.getStartDate() != null && oldTask.getStartDate().compareTo(getTaskParameters().getEndDate()) > 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_END_DATE);
			}		

			if (oldTask.getStartDate() != null && oldTask.getStartTime() == null) {
				newTask.setStartTime(startTime);
			}

			if (oldTask.getStartDate() != null && oldTask.getStartTime() != null 
					&& getTaskParameters().getEndDate().isEqual(oldTask.getStartDate())
					&& getTaskParameters().getEndTime().compareTo(oldTask.getStartTime()) < 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_END_DATE_TIME);
			}
			newTask.setEndDate(getTaskParameters().getEndDate());
			newTask.setEndTime(getTaskParameters().getEndTime());
		}
	}

	/**
	 * This method is used to edit start date time of the task
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param endTime	This is the end time at 11:59pm.
	 */
	private void editTaskStartDateTime(Task oldTask, Task newTask, LocalTime endTime) {
		if (hasTaskParametersStartDateNotEqualsNullAndStartTimeNotEqualsNull() 
				&& hasTaskParametersEndDateEqualsNullAndEndTimeEqualsNull()) {
			if (oldTask.getEndDate() != null && 
					getTaskParameters().getStartDate().compareTo(oldTask.getEndDate()) > 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_START_DATE);
			}

			if (oldTask.getEndDate() != null && oldTask.getEndTime() == null) {
				newTask.setEndTime(endTime);
			}

			if (oldTask.getEndDate() != null && oldTask.getEndTime() != null 
					&& getTaskParameters().getStartDate().isEqual(oldTask.getEndDate())
					&& oldTask.getEndTime().compareTo(getTaskParameters().getStartTime()) < 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_START_DATE_TIME);
			}
			newTask.setStartDate(getTaskParameters().getStartDate());
			newTask.setStartTime(getTaskParameters().getStartTime());
		}
	}

	/**
	 * This method is used to edit end time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param startTime	This is the start time at 12:00am.
	 */
	private void editTaskEndTimeOnly(Task oldTask, Task newTask, LocalTime startTime) {
		if (hasTaskParametersStartDateEqualsNullAndStartTimeEqualsNull() 
				&& hasTaskParametersEndDateEqualsNullAndEndTimeNotEqualsNull()) {
			if (oldTask.getEndDate() == null) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_NO_END_DATE);
			}

			if (oldTask.getStartDate() != null && oldTask.getEndDate() != null && oldTask.getStartTime() == null) {
				newTask.setStartTime(startTime);
			}

			if (oldTask.getStartDate() != null && oldTask.getEndDate() != null 
					&& oldTask.getStartTime() != null 
					&& oldTask.getStartDate().isEqual(oldTask.getEndDate())
					&& getTaskParameters().getEndTime().compareTo(oldTask.getStartTime()) < 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_END_TIME);
			}
			newTask.setEndTime(_taskParameters.getEndTime());
		}
	}

	/**
	 * This method is used to edit end date of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param endTime	This is the end time at 11:59pm.
	 */
	private void editTaskEndDateOnly(Task oldTask, Task newTask, LocalTime endTime) {
		if (hasTaskParametersStartDateEqualsNullAndStartTimeEqualsNull() 
				&& hasTaskParametersEndDateNotEqualsNullAndEndTimeEqualsNull()) {
			if (oldTask.getStartDate() != null && getTaskParameters().getEndDate().compareTo(oldTask.getStartDate()) < 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_END_DATE);
			}
			if ((oldTask.getStartDate() != null && oldTask.getStartTime() != null && oldTask.getEndDate() == null 
					&& oldTask.getEndTime() == null) || (oldTask.getStartDate() != null && oldTask.getStartTime() != null 
					&& oldTask.getEndDate() != null && oldTask.getEndTime() != null 
					&& getTaskParameters().getEndDate().isEqual(oldTask.getStartDate())
					&& oldTask.getStartTime().isAfter(oldTask.getEndTime()))) {
				newTask.setEndTime(endTime);
			}
			newTask.setEndDate(getTaskParameters().getEndDate());
		}
	}

	/**
	 * This method is used to edit start time of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param endTime	This is the end time at 11:59pm.
	 */
	private void editTaskStartTimeOnly(Task oldTask, Task newTask, LocalTime endTime) {
		if (hasTaskParametersStartDateEqualsNullAndStartTimeNotEqualsNull() 
				&& hasTaskParametersEndDateEqualsNullAndEndTimeEqualsNull()) {
			if (oldTask.getStartDate() == null) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_NO_START_DATE);
			}

			if (oldTask.getStartDate() != null && oldTask.getEndDate() != null && oldTask.getEndTime() == null) {
				newTask.setEndTime(endTime);
			}

			if (oldTask.getStartDate() != null && oldTask.getEndDate() != null && oldTask.getEndTime() != null 
					&& oldTask.getStartDate().isEqual(oldTask.getEndDate()) 
					&& getTaskParameters().getStartTime().compareTo(oldTask.getEndTime()) > 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_START_TIME);
			}
			newTask.setStartTime(getTaskParameters().getStartTime());
		}
	}

	/**
	 * This method is used to edit start date of the task.
	 * 
	 * @param oldTask	This is the task before been edited.
	 * @param newTask	This is the task after been edited.
	 * @param startTime	This is the start time at 12:00am.
	 */
	private void editTaskStartDateOnly(Task oldTask, Task newTask, LocalTime startTime) {
		if (getTaskParameters().getStartDate() != null && getTaskParameters().getStartTime() == null 
				&& getTaskParameters().getEndDate() == null && getTaskParameters().getEndTime() == null) {
			if (oldTask.getEndDate() != null && 
					getTaskParameters().getStartDate().compareTo(oldTask.getEndDate()) > 0) {
				_invalidCommand = new InvalidCommand(ERROR_MESSAGE_INVALID_START_DATE);
			}
			if ((oldTask.getStartDate() == null && oldTask.getStartTime() == null 
					&& oldTask.getEndDate() != null && oldTask.getEndTime() != null) 
					|| (oldTask.getStartDate() != null && oldTask.getStartTime() != null 
					&& oldTask.getEndDate() != null && oldTask.getEndTime() != null 
					&& oldTask.getEndDate().isEqual(getTaskParameters().getStartDate())
					&& oldTask.getStartTime().isAfter(oldTask.getEndTime()))) {
				newTask.setStartTime(startTime);
			}
			newTask.setStartDate(getTaskParameters().getStartDate());
		}
	}

	/**
	 * This method is used to edit the tags list of the task.
	 * 
	 * @param newTask	This is the task after been edited.
	 */
	private void editTaskTagsList(Task newTask) {
		if (getTaskParameters().getTagsList() != null) {
			newTask.setTagsList(getTaskParameters().getTagsList());
		}
	}

	/**
	 * This method is used to edit the description of the task.
	 * 
	 * @param newTask	This is the task after been edited.
	 */
	private void editTaskDescription(Task newTask) {
		if (getTaskParameters().getDescription() != null) {
			newTask.setDescription(getTaskParameters().getDescription());
		}
	}

	/**
	 * This method is used to check whether taskParameters' end date is not null and taskParameters' end time is null.
	 * 
	 * @return	true if taskParameters' end date is not null and taskParameters' end time is null or else return false.
	 */
	private boolean hasTaskParametersEndDateNotEqualsNullAndEndTimeEqualsNull() {
		return getTaskParameters().getEndDate() != null && getTaskParameters().getEndTime() == null;
	}

	/**
	 * This method is used to check whether taskParameters' start date is not null and taskParameters' start time is null.
	 * 
	 * @return	true if taskParameters' start date is not null and taskParameters' start time is null or else return false.
	 */
	private boolean hasTaskParametersStartDateNotEqualsNullAndStartTimeEqualsNull() {
		return getTaskParameters().getStartDate() != null && getTaskParameters().getStartTime() == null;
	}

	/**
	 * This method is used to check whether taskParameters' end date is not null and taskParameters' end time is not null.
	 * 
	 * @return	true if taskParameters' end date is not null and taskParameters' end time is not null or else return false.
	 */
	private boolean hasTaskParametersEndDateNotEqualsNullAndEndTimeNotEqualsNull() {
		return getTaskParameters().getEndDate() != null && getTaskParameters().getEndTime() != null;
	}

	/**
	 * This method is used to check whether taskParameters' start date is not null and taskParameters' start time is not null.
	 * 
	 * @return	true if taskParameters' start date is not null and taskParameters' start time is not null or else return false.
	 */
	private boolean hasTaskParametersStartDateNotEqualsNullAndStartTimeNotEqualsNull() {
		return getTaskParameters().getStartDate() != null && getTaskParameters().getStartTime() != null;
	}

	/**
	 * This method is used to check whether taskParameters' start date is null and taskParameters' start time is null.
	 * 
	 * @return	true if taskParameters' start date is null and taskParameters' start time is null or else return false.
	 */
	private boolean hasTaskParametersStartDateEqualsNullAndStartTimeEqualsNull() {
		return getTaskParameters().getStartDate() == null && getTaskParameters().getStartTime() == null;
	}

	/**
	 * This method is used to check whether taskParameters' end date is null and taskParameters' end time is null.
	 * 
	 * @return	true if taskParameters' end date is null and taskParameters' end time is null or else return false.
	 */
	private boolean hasTaskParametersEndDateEqualsNullAndEndTimeEqualsNull() {
		return getTaskParameters().getEndDate() == null && getTaskParameters().getEndTime() == null;
	}

	/**
	 * This method is used to check whether taskParameters' end date is null and taskParameters' end time is not null.
	 * 
	 * @return	true if taskParameters' end date is null and taskParameters' end time is not null or else return false.
	 */
	private boolean hasTaskParametersEndDateEqualsNullAndEndTimeNotEqualsNull() {
		return getTaskParameters().getEndDate() == null && getTaskParameters().getEndTime() != null;
	}

	/**
	 * This method is used to check whether taskParameters' start date is null and taskParameters' start time is not null.
	 * 
	 * @return	true if taskParameters' start date is null and taskParameters' start time is not null or else return false.
	 */
	private boolean hasTaskParametersStartDateEqualsNullAndStartTimeNotEqualsNull() {
		return getTaskParameters().getStartDate() == null && getTaskParameters().getStartTime() != null;
	}
}
```
###### \ArchPlanner\logic\commands\ExitCommand.java
``` java
 *
 */
public class ExitCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_EXIT_COMMAND = "Executing exit command...";
	private final String  LOGGER_MESSAGE_COMPLETED_EXIT_COMMAND = "Program has ended.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	/**
	 * This is getter method for ExitCommand's message.
	 * 
	 * @return	empty string.
	 */
	public String getMessage() {
		return STRING_EMPTY;
	}

	/**
	 * This method is used to execute exit command and exit from the program.
	 */
	public CommandInterface execute() {
		log.info(LOGGER_MESSAGE_EXECUTING_EXIT_COMMAND);
		log.info(LOGGER_MESSAGE_COMPLETED_EXIT_COMMAND);
		System.exit(0);
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		return null;
	}
}
```
###### \ArchPlanner\logic\commands\InvalidCommand.java
``` java
 *
 */
public class InvalidCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the message of an InvalidCommand object to be displayed.
	private String _message;

	//This is constructor of the class.
	public InvalidCommand(String message) {
		_message = message;
	}
	/**
	 * This is setter method for InvalidCommand's message.
	 * 
	 * @param message	This will be the message of the InvalidCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for InvalidCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsmanager, HistoryManager historyManager) {
		return null;
	}
}
```
###### \ArchPlanner\logic\commands\RedoCommand.java
``` java
 *
 */
public class RedoCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the number of times of redo.
	private int _times;

	//This is the message of an RedoCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message when tasks are redo-ed successfully.
	private final String MESSAGE_REDO_ADD_COMMAND = "deleted \"%1$s\"";
	private final String MESSAGE_REDO_DELETE_COMMAND = "added \"%1$s\"";
	private final String MESSAGE_REDO_EDIT_COMMAND = "edited \"%1$s\"";
	private final String MESSAGE_REDO_DONE_COMMAND = "undone \"%1$s\"";
	private final String MESSAGE_REDO_UNDONE_COMMAND = "done \"%1$s\"";
	private final String MESSAGE_REDO_MULTIPLE_ADD_COMMAND = "deleted multiple tasks";
	private final String MESSAGE_REDO_MULTIPLE_DELETE_COMMAND = "added multiple tasks";
	private final String MESSAGE_REDO_MULTIPLE_EDIT_COMMAND = "edited multiple tasks";
	private final String MESSAGE_REDO_MULTIPLE_DONE_COMMAND = "undone multiple tasks";
	private final String MESSAGE_REDO_MULTIPLE_UNDONE_COMMAND = "done multiple tasks";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_REDO_COMMAND = "Executing redo command...";
	private final String  LOGGER_MESSAGE_COMPLETED_REDO_COMMAND = "Completed redo command.";

	//This constant string variable is used to append messages for readability.
	private final String EMPTY_STRING = "";

	//This is constructor of the class.
	public RedoCommand() {
		_times = 1;
		_message = EMPTY_STRING;
	}

	//This is constructor of the class.
	public RedoCommand(int times) {
		_times = times;
		_message = EMPTY_STRING;
	}

	/**
	 * This is setter method for RedoCommand's times.
	 * 
	 * @param times This will be the times of the RedoCommand.
	 */
	public void setTimes(int times) {
		_times = times;
	}

	/**
	 * This is setter method for RedoCommand's message.
	 * 
	 * @param message This will be the message of the RedoCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for RedoCommand's times.
	 * 
	 * @return the number of times of redo.
	 */
	public int getTimes() {
		return _times;
	}

	/**
	 * This is getter method for RedoCommand's message.
	 * 
	 * @return message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}


	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute redo command.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert(getTimes() > 0 && getTimes() <= historyManager.getRedoList().size());

		log.info(LOGGER_MESSAGE_EXECUTING_REDO_COMMAND);
		clearIndexList(listsManager);

		for (int i = 0; i < getTimes(); i++) {
			executeRedoCommand(listsManager, historyManager);
		}
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_REDO_COMMAND);
		return null;
	}

	/**
	 * This method is used to clear the indexList in the ListsManager.
	 * 
	 * @param listsManager This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method differentiate the command type and execute the redo command based on the command type, followed by
	 * updating the relevant lists.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param historyManager This is the HistoryManager.
	 */
	private void executeRedoCommand(ListsManager listsManager, HistoryManager historyManager) {
		RollbackItem rollbackItem = new RollbackItem(null, null, null);
		rollbackItem = historyManager.getRedoList().remove(historyManager.getRedoList().size() - 1);
		int redoNumOfTimes = rollbackItem.getTimes();
		ArrayList<Task> redoTasksList = new ArrayList<Task>();

		for (int i = 0; i < rollbackItem.getTimes(); i++) {
			COMMAND_TYPE commandType = rollbackItem.getCommandType();

			switch (commandType) {

			case ADD : 
				redoAddCommand(listsManager, rollbackItem, redoNumOfTimes);
				break;
			case DELETE : 
				redoDeleteCommand(listsManager, rollbackItem, redoNumOfTimes);
				break;
			case EDIT : 
				redoEditCommand(listsManager, rollbackItem, redoNumOfTimes);
				break;
			case DONE : 
				redoDoneCommand(listsManager, rollbackItem, redoNumOfTimes);
				break;
			case UNDONE : 
				redoUndoneCommand(listsManager, rollbackItem, redoNumOfTimes);
				break;
			default : 
				break;
			}
			redoTasksList.add(rollbackItem.getNewTask());
			historyManager.getUndoList().add(rollbackItem);
			updateListsManager(listsManager);
			if (i < rollbackItem.getTimes() - 1) {
				rollbackItem = historyManager.getRedoList().remove(historyManager.getRedoList().size() - 1);
			}
		}
		updateIndexList(listsManager, redoTasksList);
	}

	/**
	 * This method is used to update the indexList in ListsManager.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param redoTasksList This is the list of tasks that are redo-ed.
	 */
	private void updateIndexList(ListsManager listsManager, ArrayList<Task> redoTasksList) {
		for (int i = 0; i < redoTasksList.size(); i++) {
			Task doneTask = redoTasksList.get(i);
			listsManager.updateIndexList(doneTask);
		}
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager this is the ListsManager.
	 */
	private void updateListsManager(ListsManager listsManager) {
		listsManager.getSelectedTagsList().clear();
		listsManager.setViewType(VIEW_TYPE.ALL);
		listsManager.setCategoryType(CATEGORY_TYPE.ALL);
		listsManager.updateLists();
	}

	/**
	 * This method is used to redo an undone command.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void redoUndoneCommand(ListsManager listsManager, RollbackItem rollbackItem, int redoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.DONE);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String redoUndoneCommandMessage = String.format(MESSAGE_REDO_UNDONE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(redoUndoneCommandMessage, MESSAGE_REDO_MULTIPLE_UNDONE_COMMAND, rollbackItem, redoNumOfTimes);
	}

	/**
	 * This method is used to redo a done command.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void redoDoneCommand(ListsManager listsManager, RollbackItem rollbackItem, int redoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.UNDONE);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String redoDoneCommandMessage = String.format(MESSAGE_REDO_DONE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(redoDoneCommandMessage, MESSAGE_REDO_MULTIPLE_DONE_COMMAND, rollbackItem, redoNumOfTimes);
	}

	/**
	 * This method is used to redo a edit command.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void redoEditCommand(ListsManager listsManager, RollbackItem rollbackItem, int redoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.EDIT);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String redoEditCommandMessage = String.format(MESSAGE_REDO_EDIT_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(redoEditCommandMessage, MESSAGE_REDO_MULTIPLE_EDIT_COMMAND, rollbackItem, redoNumOfTimes);
	}

	/**
	 * This method is used to redo a delete command.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void redoDeleteCommand(ListsManager listsManager, RollbackItem rollbackItem, int redoNumOfTimes) {
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.ADD);
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(null);
		String redoDeleteCommandMessage = String.format(MESSAGE_REDO_DELETE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(redoDeleteCommandMessage, MESSAGE_REDO_MULTIPLE_DELETE_COMMAND, rollbackItem, redoNumOfTimes);
	}

	/**
	 * This method is used to redo a add command.
	 * 
	 * @param listsManager This is the ListsManager.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void redoAddCommand(ListsManager listsManager, RollbackItem rollbackItem, int redoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		rollbackItem.setCommandType(COMMAND_TYPE.DELETE);
		rollbackItem.setOldTask(rollbackItem.getNewTask());
		rollbackItem.setNewTask(null);
		String redoAddCommandMessage = String.format(MESSAGE_REDO_ADD_COMMAND, rollbackItem.getOldTask().getDescription());
		updateMessage(redoAddCommandMessage, MESSAGE_REDO_MULTIPLE_ADD_COMMAND, rollbackItem, redoNumOfTimes);
	}

	/**
	 * This method is used to update and set the message of RedoCommand.
	 * 
	 * @param redoOneTaskMessage This will be the message of one task been redo-ed.
	 * 
	 * @param redoMultipleTasksMessage This will be the message of multiple tasks been redo-ed.
	 * 
	 * @param rollbackItem This is the RollbackItem used for redo command.
	 * 
	 * @param redoNumOfTimes This is the number of times of redo.
	 */
	private void updateMessage(String redoOneTaskMessage, String redoMultipleTasksMessage, RollbackItem rollbackItem, int redoNumOfTimes) {
		if (redoNumOfTimes == 1) {
			setMessage(redoOneTaskMessage);
		} else {
			setMessage(redoMultipleTasksMessage);
		}
	}
}
```
###### \ArchPlanner\logic\commands\SetCommand.java
``` java
 *
 */
public class SetCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the file path of the storage file.
	private String _filePath;

	//This is the invalidCommand to be initialized if set command is invalid.
	private InvalidCommand _invalidCommand;

	//This is the message of an SetCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message when  set command is executed successfully.
	private final String MESSAGE_SET_NEW_FILE_PATH = "created \"%1$s\"";
	private final String MESSAGE_SET_EXISTING_FILE_PATH = "set filepath to \"%1$s\"";
	private final String MESSAGE_SET_DEFAULT_FILE_PATH= "The filepath has been set to default";

	//These are constant string variables of error messages to be displayed if set command is invalid.
	private final String INVALID_DIRECTORY = "File Directory does not exist.";
	private final String INVALID_FILE_PATH = "Invalid file path";
	private final String INVALID_FILE = "Invalid file. Please confirm.";

	//This constant string variable is file extension of the storage file.
	private final String FILE_EXTENSION = ".txt";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_SET_COMMAND = "Executing set command...";
	private final String  LOGGER_MESSAGE_COMPLETED_SET_COMMAND = "Completed set command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public SetCommand(String filePath) {
		setFilePath(filePath);
		_message = STRING_EMPTY;
	}

	public void setFilePath(String filePath) {
		if (filePath != null) {
			_filePath = filePath + FILE_EXTENSION;
		}
	}

	/**
	 * This is setter method for SetCommand's invalidCommand
	 * 
	 * @param invalidCommand	This will be the invalidCommand of the SetCommand.
	 */
	public void setInvalidCommand(InvalidCommand invalidCommand) {
		_invalidCommand = invalidCommand;
	}

	/**
	 * This is setter method for SetCommand's message.
	 * 
	 * @param message	This will be the message of the SetCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for SetCommand's filePath.
	 * 
	 * @return	file path.
	 */
	public String getFilePath() {
		return _filePath;
	}

	/**
	 * This is getter method for SetCommand's invalidCommand.
	 * 
	 * @return	invalidCommand.
	 */
	public InvalidCommand getInvalidCommand() {
		return _invalidCommand;
	}

	/**
	 * This method is getter method SetCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		return null;
	}

	/**
	 * This method is used to execute set command.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		log.info(LOGGER_MESSAGE_EXECUTING_SET_COMMAND);
		clearIndexList(listsManager);
		setFilePath(listsManager, storage);
		if (getInvalidCommand() != null) {
			log.info(getInvalidCommand().getMessage());
			return getInvalidCommand();
		}
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_SET_COMMAND);
		return null;
	}

	/**
	 * This method is used to clear indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to set file path.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param storage		This is the Storage.
	 */
	private void setFilePath(ListsManager listsManager, Storage storage) {
		if (_filePath == null) {
			setDefaultFilePath(listsManager, storage);
			return;
		}

		try {
			File file = null;
			file = new File(_filePath);
			if (!file.exists()) {
				setNewFilePathIfDirectoryExists(storage, file.getParent());
				setMessage(String.format(MESSAGE_SET_NEW_FILE_PATH, file.getCanonicalPath()));
			} else if (file.isFile()) {
				setFilePathToExistingFilePath(listsManager, storage, file);
			}
		} catch (Exception e) {
			_invalidCommand = new InvalidCommand(INVALID_FILE_PATH);
		}

	}

	/**
	 * This method is used to file path to the default file path.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param storage		This is the Storage.
	 */
	private void setDefaultFilePath(ListsManager listsManager, Storage storage) {
		storage.setDefaultFilePath();
		listsManager.setUpLists(storage.getMasterList());
		setMessage(MESSAGE_SET_DEFAULT_FILE_PATH);
	}

	/**
	 * This method is used to set file path to an existing file path.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param storage		This is the Storage.
	 * @param file			This is the file of the filePath.
	 */
	private void setFilePathToExistingFilePath(ListsManager listsManager, Storage storage, File file) {
		Gson gson = new Gson();
		BufferedReader bufferedReader;
		try {
			bufferedReader = new BufferedReader(new FileReader(_filePath));
			gson.fromJson(bufferedReader, new TypeToken<ArrayList<Task>>(){}.getType());
			bufferedReader.close();
			storage.setExistingFilePath(_filePath);
			listsManager.setUpLists(storage.getMasterList());
			setMessage(String.format(MESSAGE_SET_EXISTING_FILE_PATH, file.getCanonicalPath()));
		} catch (Exception e) {
			_invalidCommand = new InvalidCommand(INVALID_FILE);
		}
	}

	/**
	 * This method is used to set new file path if directory exists.
	 * 
	 * @param storage	This is the Storage.
	 * @param directory	This is the parent directory of the file path.
	 */
	private void setNewFilePathIfDirectoryExists(Storage storage, String directory) {
		File filePathDirectory = new File(directory);
		if (filePathDirectory.exists() && filePathDirectory.isDirectory()) {
			storage.setNewFilePath(_filePath);
		} else {
			_invalidCommand = new InvalidCommand(INVALID_DIRECTORY);
		}
	}
}
```
###### \ArchPlanner\logic\commands\UndoCommand.java
``` java
 *
 */
public class UndoCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the number of times of undo.
	private int _times;

	//This is the message of an UndoCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message when tasks are undo-ed successfully.
	private final String MESSAGE_UNDO_ADD_COMMAND = "deleted \"%1$s\"";
	private final String MESSAGE_UNDO_DELETE_COMMAND = "added \"%1$s\"";
	private final String MESSAGE_UNDO_EDIT_COMMAND = "edited \"%1$s\"";
	private final String MESSAGE_UNDO_DONE_COMMAND = "undone \"%1$s\"";
	private final String MESSAGE_UNDO_UNDONE_COMMAND = "done \"%1$s\"";
	private final String MESSAGE_UNDO_MULTIPLE_ADD_COMMAND = "deleted multiple tasks";
	private final String MESSAGE_UNDO_MULTIPLE_DELETE_COMMAND = "added multiple tasks";
	private final String MESSAGE_UNDO_MULTIPLE_EDIT_COMMAND = "edited multiple tasks";
	private final String MESSAGE_UNDO_MULTIPLE_DONE_COMMAND = "undone multiple tasks";
	private final String MESSAGE_UNDO_MULTIPLE_UNDONE_COMMAND = "done multiple tasks";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_UNDO_COMMAND = "Executing undo command...";
	private final String  LOGGER_MESSAGE_COMPLETED_UNDO_COMMAND = "Completed undo command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public UndoCommand() {
		_times = 1;
		_message = STRING_EMPTY;
	}

	//This is constructor of the class.
	public UndoCommand(int times) {
		_times = times;
		_message = STRING_EMPTY;
	}

	/**
	 * This is setter method for UndoCommand's times.
	 * 
	 * @param times	This will be the times of the UndoCommand.
	 */
	public void setTimes(int times) {
		_times = times;
	}

	/**
	 * This is setter method for UndoCommand's message.
	 * 
	 * @param message	This will be the message of the UndoCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for UndoCommand's times.
	 * 
	 * @return	the number of times of undo.
	 */
	public int getTimes() {
		return _times;
	}

	/**
	 * This is getter method for UndoCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute undo command.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert(getTimes() > 0 && getTimes() <= historyManager.getUndoList().size());
		
		log.info(LOGGER_MESSAGE_EXECUTING_UNDO_COMMAND);
		clearIndexList(listsManager);
		for (int i = 0; i < getTimes(); i++) {
			executeUndoCommand(listsManager, historyManager);
		}
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_UNDO_COMMAND);
		return null;
	}

	/**
	 * This method is used to clear the indexList in the ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method differentiate the command type and execute the undo command based on the command type, followed by
	 * updating the relevant lists.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param historyManager	This is the HistoryManager.
	 */
	private void executeUndoCommand(ListsManager listsManager, HistoryManager historyManager) {
		RollbackItem rollbackItem = new RollbackItem(null, null, null);
		rollbackItem = historyManager.getUndoList().remove(historyManager.getUndoList().size() - 1);
		int undoNumOfTimes = rollbackItem.getTimes();
		ArrayList<Task> undoTasksList = new ArrayList<Task>();
		for (int i = 0; i < undoNumOfTimes; i++) {
			COMMAND_TYPE commandType = rollbackItem.getCommandType();
			switch (commandType) {

			case ADD : 
				undoAddCommand(listsManager, rollbackItem, undoNumOfTimes);
				break;
			case DELETE : 
				undoDeleteCommand(listsManager, rollbackItem, undoNumOfTimes);
				break;
			case EDIT : 
				undoEditCommand(listsManager, rollbackItem, undoNumOfTimes);
				break;
			case DONE : 
				undoDoneCommand(listsManager, rollbackItem, undoNumOfTimes);
				break;
			case UNDONE : 
				undoUndoneCommand(listsManager, rollbackItem, undoNumOfTimes);
				break;
			default : 
				break;
			}
			undoTasksList.add(rollbackItem.getNewTask());
			historyManager.getRedoList().add(rollbackItem);
			updateListsManager(listsManager);
			if (i < rollbackItem.getTimes() - 1) {
				rollbackItem = historyManager.getUndoList().remove(historyManager.getUndoList().size() - 1);
			}
		}
		updateIndexList(listsManager, undoTasksList);
	}

	/**
	 * This method is used to update the indexList in ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param undoTasksList	This is the list of tasks that are undo-ed.
	 */
	private void updateIndexList(ListsManager listsManager, ArrayList<Task> undoTasksList) {
		for (int i = 0; i < undoTasksList.size(); i++) {
			Task doneTask = undoTasksList.get(i);
			listsManager.updateIndexList(doneTask);
		}
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void updateListsManager(ListsManager listsManager) {
		listsManager.getSelectedTagsList().clear();
		listsManager.setViewType(VIEW_TYPE.ALL);
		listsManager.setCategoryType(CATEGORY_TYPE.ALL);
		listsManager.updateLists();
	}

	/**
	 * This method is used to undo an undone command.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param rollbackItem		This is the RollbackItem used for undo command.
	 * @param undoNumOfTimes	This is the number of times of undo.
	 */
	private void undoUndoneCommand(ListsManager listsManager, RollbackItem rollbackItem, int undoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.DONE);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String undoUndoneCommandMesage = String.format(MESSAGE_UNDO_UNDONE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(undoUndoneCommandMesage, MESSAGE_UNDO_MULTIPLE_UNDONE_COMMAND, rollbackItem, undoNumOfTimes);
	}

	/**
	 * This method is used to undo a done command.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param rollbackItem		This is the RollbackItem used for undo command.
	 * @param undoNumOfTimes	This is the number of times of undo.
	 */
	private void undoDoneCommand(ListsManager listsManager, RollbackItem rollbackItem, int undoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.UNDONE);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String undoDoneCommandMesage = String.format(MESSAGE_UNDO_DONE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(undoDoneCommandMesage, MESSAGE_UNDO_MULTIPLE_DONE_COMMAND, rollbackItem, undoNumOfTimes);
	}

	/**
	 * This method is used to undo a edit command.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param rollbackItem		This is the RollbackItem used for undo command.
	 * @param undoNumOfTimes	This is the number of times of undo.
	 */
	private void undoEditCommand(ListsManager listsManager, RollbackItem rollbackItem, int undoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.EDIT);
		Task tempTask = rollbackItem.getNewTask();
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(tempTask);
		String undoEditCommandMesage = String.format(MESSAGE_UNDO_EDIT_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(undoEditCommandMesage, MESSAGE_UNDO_MULTIPLE_EDIT_COMMAND, rollbackItem, undoNumOfTimes);
	}

	/**
	 * This method is used to undo a delete command.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param rollbackItem		This is the RollbackItem used for undo command.
	 * @param undoNumOfTimes	This is the number of times of undo.
	 */
	private void undoDeleteCommand(ListsManager listsManager, RollbackItem rollbackItem, int undoNumOfTimes) {
		listsManager.getMainList().add(rollbackItem.getOldTask());
		rollbackItem.setCommandType(COMMAND_TYPE.ADD);
		rollbackItem.setNewTask(rollbackItem.getOldTask());
		rollbackItem.setOldTask(null);
		String undoDeleteCommandMesage = String.format(MESSAGE_UNDO_DELETE_COMMAND, rollbackItem.getNewTask().getDescription());
		updateMessage(undoDeleteCommandMesage, MESSAGE_UNDO_MULTIPLE_DELETE_COMMAND, rollbackItem, undoNumOfTimes);
	}

	/**
	 * This method is used to undo a add command.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param rollbackItem		This is the RollbackItem used for undo command.
	 * @param undoNumOfTimes	This is the number of times of undo.
	 */
	private void undoAddCommand(ListsManager listsManager, RollbackItem rollbackItem, int undoNumOfTimes) {
		listsManager.getMainList().remove(rollbackItem.getNewTask());
		rollbackItem.setCommandType(COMMAND_TYPE.DELETE);
		rollbackItem.setOldTask(rollbackItem.getNewTask());
		rollbackItem.setNewTask(null);
		String undoAddCommandMesage = String.format(MESSAGE_UNDO_ADD_COMMAND, rollbackItem.getOldTask().getDescription());
		updateMessage(undoAddCommandMesage, MESSAGE_UNDO_MULTIPLE_ADD_COMMAND, rollbackItem, undoNumOfTimes);
	}

	/**
	 * This method is used to update and set the message of UndoCommand.
	 * 
	 * @param undoOneTaskMessage		This will be the message of one task been undo-ed.
	 * @param undoMultipleTasksMessage	This will be the message of multiple tasks been undo-ed.
	 * @param rollbackItem				This is the RollbackItem used for redo command.
	 * @param undoNumOfTimes			This is the number of times of undo.
	 */
	private void updateMessage(String undoOneTaskMessage, String undoMultipleTasksMessage, RollbackItem rollbackItem, int undoNumOfTimes) {
		if (undoNumOfTimes == 1) {
			setMessage(undoOneTaskMessage);
		} else {
			setMessage(undoMultipleTasksMessage);
		}
	}
}
```
###### \ArchPlanner\logic\commands\UndoneCommand.java
``` java
 *
 */
public class UndoneCommand implements CommandInterface {

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the first index of task in the list to be undone.
	private int _firstIndex;

	//This is the last index of task in the list to be undone.
	private int _lastIndex;

	//This is the message of an UndoneCommand object to be displayed.
	private String _message;

	//These constant string variables are the standard format for display message when tasks are set to undone successfully.
	private final String MESSAGE_UNDONE_COMMAND = "undone \"%1$s\"";
	private final String MESSAGE_MULTIPLE_UNDONE_COMMAND = "undone multiple tasks";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_UNDONE_COMMAND = "Executing undone command...";
	private final String  LOGGER_MESSAGE_COMPLETED_UNDONE_COMMAND = "Completed undone command.";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public UndoneCommand(int index) {
		_firstIndex = index - 1;
		_lastIndex = index - 1;
		_message = STRING_EMPTY;
	}

	//This is constructor of the class.
	public UndoneCommand(int firstIndex, int lastIndex) {
		_firstIndex = firstIndex - 1;
		_lastIndex = lastIndex - 1;
		_message = STRING_EMPTY;
	}

	/**
	 * This is setter method for UndoneCommand's firstIndex.
	 * 
	 * @param index	This will be the firstIndex of the UndoneCommand.
	 */
	public void setFirstIndex(int index) {
		_firstIndex = index;
	}

	/**
	 * This is setter method for UndoneCommand's lastIndex.
	 * 
	 * @param index	This will be the lastIndex of the UndoneCommand.
	 */
	public void setLastIndex(int index) {
		_lastIndex = index;
	}

	/**
	 * This is setter method for UndoneCommand's message.
	 * 
	 * @param message	This will be the message of the UndoneCommand.
	 */
	public void setMessage(String message) {
		_message = message;
	}

	/**
	 * This is getter method for UndoneCommand's firstIndex.
	 * 
	 * @return	firstIndex.
	 */
	public int getFirstIndex() {
		return _firstIndex;
	}

	/**
	 * This is getter method for UndoneCommand's lastIndex.
	 * 
	 * @return	lastIndex.
	 */
	public int getLastIndex() {
		return _lastIndex;
	}

	/**
	 * This is getter command for UndoneCommand's message.
	 * 
	 * @return	message.
	 */
	public String getMessage() {
		return _message;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to execute undone command.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {
		assert(getFirstIndex() >= 0 && getFirstIndex() < listsManager.getViewList().size());
		assert(getLastIndex() >= 0 && getLastIndex() < listsManager.getViewList().size());

		log.info(LOGGER_MESSAGE_EXECUTING_UNDONE_COMMAND);
		clearIndexList(listsManager);

		int numOfUndone = getLastIndex() - getFirstIndex() + 1;
		Task oldTask = null;
		ArrayList<Task> undoneTasksList = new ArrayList<Task>();
		for (int i = 0; i < numOfUndone; i++) {
			oldTask = listsManager.getViewList().get(_lastIndex);
			listsManager.getMainList().remove(oldTask);
			Task newTask = new Task();
			initializeNewTask(oldTask, newTask);
			undoneTasksList.add(newTask);
			updateManagers(listsManager, historyManager, numOfUndone, oldTask, newTask);
		}
		updateIndexList(listsManager, undoneTasksList);
		updateMessage(numOfUndone, oldTask);
		log.info(getMessage());
		log.info(LOGGER_MESSAGE_COMPLETED_UNDONE_COMMAND);
		return null;
	}
	
	/**
	 * This method is used to update indexList in ListsManaer.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param undoneTasksList	This is the list of tasks to be set to undone.
	 */
	private void updateIndexList(ListsManager listsManager, ArrayList<Task> undoneTasksList) {
		for (int i = 0; i < undoneTasksList.size(); i++) {
			Task undoneTask = undoneTasksList.get(i);
			listsManager.updateIndexList(undoneTask);
		}
	}

	/**
	 * This method is used to update UndoneCommand's message.
	 * 
	 * @param numOfUndone	This is the number of tasks to be set to undone.
	 * @param oldTask		This is the task before been set to undone.
	 */
	private void updateMessage(int numOfUndone, Task oldTask) {
		if (numOfUndone == 1) {
			_message = String.format(MESSAGE_UNDONE_COMMAND, oldTask.getDescription());
		} else {
			_message = MESSAGE_MULTIPLE_UNDONE_COMMAND;
		}
	}

	/**
	 * This method is used to update ListsManager and HistoryManager.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param historyManager	This is the HistoryManager.
	 * @param numOfUndone		This is the number of tasks to be set to undone.
	 * @param oldTask			This is the task before been set to undone.
	 * @param newTask			This is the task after been set to undone.
	 */
	private void updateManagers(ListsManager listsManager, HistoryManager historyManager, int numOfUndone, Task oldTask,
			Task newTask) {
		updateListsManager(listsManager, newTask);
		updateHistoryManager(historyManager, oldTask, newTask, numOfUndone);
	}

	/**
	 * This method is used to clear indexList in ListsManager.
	 * 
	 * @param listsManager This is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method is used to update HistoryManager.
	 * 
	 * @param historyManager	This is the HistoryManager.
	 * @param oldTask			This is the task before been set to undone.
	 * @param newTask			This is the task after been set to undone.
	 * @param numOfUndone		This is the number of tasks to be set to undone.
	 */
	private void updateHistoryManager(HistoryManager historyManager, Task oldTask, Task newTask, int numOfUndone) {
		RollbackItem rollbackItem = new RollbackItem(COMMAND_TYPE.UNDONE, oldTask, newTask, numOfUndone);
		historyManager.getUndoList().add(rollbackItem);
		historyManager.setRedoList(new ArrayList<RollbackItem>());
	}

	/**
	 * This method is used to update ListsManager.
	 * 
	 * @param listsManager	This is the ListsManager.
	 * @param newTask		This is the task after been set to undone.
	 */
	private void updateListsManager(ListsManager listsManager, Task newTask) {
		listsManager.getMainList().add(newTask);
		listsManager.updateLists();
	}

	/**
	 * This method is used to initialize the new task with the old task properties but done status is set to false.
	 * 
	 * @param oldTask	This is the task before been set to undone.
	 * @param newTask	This is the task after been set to undone.
	 */
	private void initializeNewTask(Task oldTask, Task newTask) {
		newTask.setDescription(oldTask.getDescription());
		newTask.setTagsList(oldTask.getTagsList());
		newTask.setStartDate(oldTask.getStartDate());
		newTask.setStartTime(oldTask.getStartTime());
		newTask.setEndDate(oldTask.getEndDate());
		newTask.setEndTime(oldTask.getEndTime());
		newTask.setIsOverdue(oldTask.getIsOverdue());
		newTask.setIsDone(false);
	}
}
```
###### \ArchPlanner\logic\commands\ViewCommand.java
``` java
 *
 */
public class ViewCommand implements CommandInterface {

	//These are enum variables of view type.
	public enum VIEW_TYPE {
		ALL, DONE, UNDONE, OVERDUE
	}

	//these are enum variables of category type.
	public enum CATEGORY_TYPE {
		ALL, EVENTS, DEADLINES, TASKS
	}

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the view type of the ViewCommand object.
	private VIEW_TYPE _viewType;

	//This is the category type of the ViewCommand object.
	public CATEGORY_TYPE _categoryType;

	//This is the taskParameters of the ViewCommand object.
	private TaskParameters _taskParameters;

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_EXECUTING_VIEW_COMMAND = "Executing view command...";
	private final String  LOGGER_MESSAGE_COMPLETED_VIEW_COMMAND = "Completed view command.";

	//These constant string variables are used to append messages for readability.
	private final String STRING_EMPTY = "";
	private final String STRING_DOUBLE_QUOTE = "\"";
	private final String STRING_SINGLE_SPACE = " ";
	private final String STRING_TO = "to";

	//This is constructor of the class.
	public ViewCommand(VIEW_TYPE viewType, CATEGORY_TYPE categoryType, TaskParameters taskParameters) {
		_viewType = viewType;
		_categoryType = categoryType;
		_taskParameters = taskParameters;
	}

	/**
	 * This is setter method of the ViewCommand's viewType.
	 * 
	 * @param viewType	This will be the viewType of the ViewCommand.
	 */
	public void setViewType(VIEW_TYPE viewType) {
		_viewType = viewType;
	}

	/**
	 * This is setter method of the ViewCommand's categoryType.
	 * 
	 * @param categoryType	This will be the categoryType of the ViewCommand.
	 */
	public void setCategoryType(CATEGORY_TYPE categoryType) {
		_categoryType = categoryType;
	}

	/**
	 * This is setter method of the ViewCommand's taskParameters.
	 * 
	 * @param taskParameters	This will be the taskParameters of the ViewCommand.
	 */
	public void setTaskParameters(TaskParameters taskParameters) {
		_taskParameters = taskParameters;
	}

	/**
	 * This is getter method of the ViewCommand's viewType.
	 * 
	 * @return	viewType.
	 */
	public VIEW_TYPE getViewType() {
		return _viewType;
	}

	/**
	 * This is getter method of the ViewCommand's categoryType.
	 * 
	 * @return	categoryType.
	 */
	public CATEGORY_TYPE getCategoryType() {
		return _categoryType;
	}

	/**
	 * This is getter method of the ViewCommand's taskParameters.
	 * 
	 * @return	taskParameters.
	 */
	public TaskParameters getTaskParameters() {
		return _taskParameters;
	}

	/**
	 * This is getter method of the ViewCommand's message.
	 * 
	 * @return	message with empty string.
	 */
	public String getMessage() {
		return STRING_EMPTY;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute() {
		return null;
	}

	/**
	 * This method will not be called.
	 */
	public CommandInterface execute(ListsManager listsManager, Storage storage) {
		return null;
	}

	/**
	 * This method is used to set the view state as specified by the user.
	 */
	public CommandInterface execute(ListsManager listsManager, HistoryManager historyManager) {

		log.info(LOGGER_MESSAGE_EXECUTING_VIEW_COMMAND);
		String currentViewType = STRING_EMPTY;
		listsManager.setViewType(VIEW_TYPE.ALL);
		setViewIfViewTypeIsNotNull(listsManager);
		setViewIfCategoryTypeIsNotNull(listsManager);
		updateSelectedTagsList(listsManager);

		clearIndexList(listsManager);
		listsManager.updateLists();

		currentViewType = updateViewListWithDescriptionOnly(listsManager, currentViewType);
		currentViewType = updateCurrentViewTypeWithTagsList(currentViewType);
		currentViewType = updateViewListWithStartDateOnly(listsManager, currentViewType);
		currentViewType = updateViewListWithStartTimeOnly(listsManager, currentViewType);
		currentViewType = updateViewListWithEndDateOnly(listsManager, currentViewType);
		currentViewType = updateViewListWithEndTimeOnly(listsManager, currentViewType);
		currentViewType = updateViewListWithStartDateEndDateOnly(listsManager, currentViewType);

		listsManager.setCurrentViewType(currentViewType);

		log.info(currentViewType);
		log.info(LOGGER_MESSAGE_COMPLETED_VIEW_COMMAND);
		return null;
	}

	/**
	 * This method clear the indexList in the ListsManager.
	 * 
	 * @param listsManager 	his is the ListsManager.
	 */
	private void clearIndexList(ListsManager listsManager) {
		listsManager.getIndexList().clear();
	}

	/**
	 * This method update the selectedTagsList in ListsManger.
	 * 
	 * @param listsManager	This is the ListsManger
	 */
	private void updateSelectedTagsList(ListsManager listsManager) {
		listsManager.getSelectedTagsList().clear();
		if (getTaskParameters().getTagsList() != null && !getTaskParameters().getTagsList().isEmpty()) {
			listsManager.getSelectedTagsList().addAll(getTaskParameters().getTagsList());
		}
	}

	/**
	 * This method is used to update view list in ListsManager with list of tasks with start date and end date that intercept
	 * taskParameters' start date and end date time frame.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	This is the current view type.
	 * @return					current view type
	 */
	private String updateViewListWithStartDateEndDateOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getStartDate() != null && getTaskParameters().getEndDate() != null) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (!(hasTaskStartDateInterceptsTaskParametersTimeFrame(task) || hasTaskEndDateInterceptsTaskParametersTimeFrame(task) 
						|| hasTaskStartDateEndDateInterceptsTaskParametersTimeFrame(task))) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType += appendCurrentViewType(currentViewType, getTaskParameters().getStartDateString()) + STRING_TO 
					+ STRING_SINGLE_SPACE + appendCurrentViewType(currentViewType, getTaskParameters().getEndDateString());
		}
		return currentViewType;
	}

	/**
	 * This method is used to check if the task's start date and end date intercepts taskParameters' time frame.
	 * 
	 * @param task	This is the task in the view list to be checked.
	 * @return		true if task's start date and end date intercepts taskParameters' time frame or else return false.
	 */
	private boolean hasTaskStartDateEndDateInterceptsTaskParametersTimeFrame(Task task) {
		return task.getStartDate() != null && task.getEndDate() != null 
				&& (((task.getStartDate().isAfter(getTaskParameters().getStartDate()) && task.getStartDate().isBefore(getTaskParameters().getEndDate())) 
						|| (task.getEndDate().isAfter(getTaskParameters().getStartDate()) && task.getEndDate().isBefore(getTaskParameters().getEndDate()))) 
						|| task.getStartDate().isEqual(getTaskParameters().getStartDate()) || task.getStartDate().isEqual(getTaskParameters().getEndDate()) 
						|| task.getEndDate().isEqual(getTaskParameters().getStartDate()) || task.getEndDate().isEqual(getTaskParameters().getEndDate()));
	}

	/**
	 * This method is used to check if the task's end date intercepts taskParameters' time frame.
	 * 
	 * @param task	This is the task in the view list to be checked.
	 * @return		true if task's end date intercepts taskParameters' time frame or else return false.
	 */
	private boolean hasTaskEndDateInterceptsTaskParametersTimeFrame(Task task) {
		return task.getStartDate() == null && task.getEndDate() != null
				&& ((task.getEndDate().isAfter(getTaskParameters().getStartDate()) && task.getEndDate().isBefore(getTaskParameters().getEndDate())) 
						|| task.getEndDate().isEqual(getTaskParameters().getStartDate()) || task.getEndDate().isEqual(getTaskParameters().getEndDate()));
	}

	/**
	 * This method is used to check if the task's start date intercepts taskParameters' time frame.
	 * 
	 * @param task	This is the task in the view list to be checked.
	 * @return		true if task's start date intercepts taskParameters' time frame or else return false.
	 */
	private boolean hasTaskStartDateInterceptsTaskParametersTimeFrame(Task task) {
		return task.getStartDate() != null && task.getEndDate() == null 
				&& ((task.getStartDate().isAfter(getTaskParameters().getStartDate()) && task.getStartDate().isBefore(getTaskParameters().getEndDate())) 
						|| task.getStartDate().isEqual(getTaskParameters().getStartDate()) || task.getStartDate().isEqual(getTaskParameters().getEndDate()));
	}

	/**
	 * This method is used to update view list with tasks' end time matches taskParameters' end time
	 * if taskParameters' start time is null and end time is not null.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	Thisis the current view type.
	 * @return					current view type.
	 */
	private String updateViewListWithEndTimeOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getStartTime() == null && getTaskParameters().getEndTime() != null) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (!(task.getEndTime() != null && task.getEndTime().equals(getTaskParameters().getEndTime()))) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType = appendCurrentViewType(currentViewType, getTaskParameters().getEndTimeString());
		}
		return currentViewType;
	}

	/**
	 * This method is used to append the current view type.
	 * 
	 * @param currentViewType	This is the current view type.
	 * @param detail			This is the String to be appended to current view type.
	 * @return					current view type.
	 */
	private String appendCurrentViewType(String currentViewType, String detail) {
		currentViewType += STRING_DOUBLE_QUOTE + detail + STRING_DOUBLE_QUOTE + STRING_SINGLE_SPACE;
		return currentViewType;
	}

	/**
	 * This method is used to update view list with tasks' end date matches taskParameters' end date
	 * if taskParameters' start date is null and end date is not null.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	This is the current view type.
	 * @return					current view type.
	 */
	private String updateViewListWithEndDateOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getStartDate() == null && getTaskParameters().getEndDate() != null) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (!((listsManager.getViewList().get(i).getEndDate() != null) && 
						(task.getEndDate().equals(getTaskParameters().getEndDate())))) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType = appendCurrentViewType(currentViewType, getTaskParameters().getEndDateString());
		}
		return currentViewType;
	}

	/**
	 * This method is used to update view list with tasks' start time matches taskParameters' start time
	 * if taskParameters' start time is not null and end time is null.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	This is the current view type.
	 * @return					current view type.
	 */
	private String updateViewListWithStartTimeOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getStartTime() != null && getTaskParameters().getEndTime() == null) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (!((listsManager.getViewList().get(i).getStartTime() != null) && 
						(task.getStartTime().equals(getTaskParameters().getStartTime())))) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType = appendCurrentViewType(currentViewType, getTaskParameters().getStartTimeString());
		}
		return currentViewType;
	}

	/**
	 * This method is used to update view list with tasks' start date matches taskParameters' start date
	 * if taskParameters' start date is not null and end date is null.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	This is the current view type.
	 * @return					current view type.
	 */
	private String updateViewListWithStartDateOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getStartDate() != null && getTaskParameters().getEndDate() == null) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (!((listsManager.getViewList().get(i).getStartDate() != null) && 
						(task.getStartDate().equals(getTaskParameters().getStartDate())))) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType = appendCurrentViewType(currentViewType, _taskParameters.getStartDateString());
		}
		return currentViewType;
	}

	/**
	 * This method is used to update and append current view type with tags' names.
	 * 
	 * @param currentViewType	This is the current view type.
	 * @return					current view type.
	 */
	private String updateCurrentViewTypeWithTagsList(String currentViewType) {
		if (getTaskParameters().getTagsList() != null && !getTaskParameters().getTagsList().isEmpty()) {
			for (int i = 0; i < getTaskParameters().getTagsList().size(); i++) {
				currentViewType = appendCurrentViewType(currentViewType, getTaskParameters().getTagsList().get(i));
			}
		}
		return currentViewType;
	}

	/**
	 * This method is used to update view list with tasks with description that contains the taskParameters' description.
	 * 
	 * @param listsManager		This is the ListsManager.
	 * @param currentViewType	This is the current view type.
	 * @return					current view type.
	 */
	private String updateViewListWithDescriptionOnly(ListsManager listsManager, String currentViewType) {
		if (getTaskParameters().getDescription() != null && !getTaskParameters().getDescription().isEmpty()) {
			for (int i = 0; i < listsManager.getViewList().size(); i++) {
				Task task = listsManager.getViewList().get(i);
				if (listsManager.getViewList().get(i).getDescription() != null && 
						!task.getDescription().toLowerCase().contains(getTaskParameters().getDescription().toLowerCase())) {
					listsManager.getViewList().remove(i);
					i--;
				}
			}
			currentViewType = appendCurrentViewType(currentViewType, getTaskParameters().getDescription());
		}
		return currentViewType;
	}

	/**
	 * This method is used to set view type if category type is not null.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void setViewIfCategoryTypeIsNotNull(ListsManager listsManager) {
		if (getCategoryType() != null) {
			if (getViewType() == null) {
				listsManager.setViewType(VIEW_TYPE.ALL);
			}
			listsManager.setCategoryType(getCategoryType());
		}
	}

	/**
	 * This method is used to set category type if view type is not null.
	 * 
	 * @param listsManager	This is the ListsManager.
	 */
	private void setViewIfViewTypeIsNotNull(ListsManager listsManager) {
		if (getViewType() != null) {
			if (getViewType().equals(VIEW_TYPE.ALL)) {
				listsManager.setCategoryType(CATEGORY_TYPE.ALL);
				deselectAllTags(listsManager);
			}
			listsManager.setViewType(_viewType);
		}
	}

	/**
	 * This method is used to set the select status of all the tags in tagsList to false, and clear selectedTagsList.
	 *  
	 * @param listsManager	This is the ListsManager.
	 */
	private void deselectAllTags(ListsManager listsManager) {
		for (int i = 0; i < listsManager.getTagsList().size(); i++) {
			Tag tag = listsManager.getTagsList().get(i);
			tag.setIsSelected(false);
		}
		listsManager.getSelectedTagsList().clear();
	}
}
```
###### \ArchPlanner\logic\comparator\DescriptionComparator.java
``` java
 *
 */
public class DescriptionComparator implements Comparator<Task> {

	/**
	 * This method is used to compare description of two Task objects.
	 * It returns 0 if task1's description and task2's description are both null.
	 * It returns -1 if task1's description is null and task2's description is not null.
	 * It returns 1 if task1's description is not null and task2's description is null.
	 */
	public int compare(Task task1, Task task2) {
		
		if (task1.getDescription() == null && task2.getDescription() == null) {
			return 0;
		}
		
		if (task1.getDescription() == null && task2.getDescription() != null) {
			return -1;
		}
		
		if (task1.getDescription() != null && task2.getDescription() == null) {
			return 1;
		}
		
		String description1 =  task1.getDescription();
		String description2 =  task2.getDescription();
		
		return description1.compareTo(description2);
	}
}
```
###### \ArchPlanner\logic\comparator\DoneComparator.java
``` java
 *
 */
public class DoneComparator implements Comparator<Task> {

	/**
	 * This method is used to compare done status of two Task objects.
	 * It returns 0 if task1's isDone and task2's isDone are true.
	 * It returns -1 if task1's isDone is false and task2's isDone is true.
	 * It returns 1 if task1's isDone and task2's isDone are both false or true.
	 */
	public int compare(Task task1, Task task2) {
		if (task1.getIsDone() == true && task2.getIsDone() == false){
			return 1;
		} else if (task1.getIsDone() == false && task2.getIsDone() == true){
			return -1;
		} else {
			return 0;
		}
	}
}
```
###### \ArchPlanner\logic\comparator\OverdueComparator.java
``` java
 *
 */
public class OverdueComparator implements Comparator<Task> {

	/**
	 * This method is used to compare overdue status of two Task objects.
	 * It returns 0 if task1's isOverdue and task2's isOverdue are both false or true.
	 * It returns -1 if task1's isOverdue is true and task2's isOverdue is false.
	 * It returns 1 if task1's isOverdue is false and task2's isOverdue is true.
	 */
	public int compare(Task task1, Task task2) {
		if (task1.getIsOverdue() == false && task2.getIsOverdue() == true){
			return 1;
		} else if (task1.getIsOverdue() == true && task2.getIsOverdue() == false){
			return -1;
		} else {
			return 0;
		}
	}
}
```
###### \ArchPlanner\logic\comparator\TagComparator.java
``` java
 *
 */
public class TagComparator implements Comparator<Tag> {

	/**
	 * This method is used to compare tag's name of two Tag objects.
	 * It returns 0 if tag1's name and tag2's name are both null.
	 * It returns -1 if tag1's name is null and tag2's name is not null.
	 * It returns 1 if tag1's name is not null and tag2's name is null.
	 */
	public int compare(Tag tag1, Tag tag2) {
		
		if (tag1.getName() == null && tag2.getName() == null) {
			return 0;
		}
		
		if (tag1.getName() == null && tag2.getName() != null) {
			return -1;
		}
		
		if (tag1.getName() != null && tag2.getName() == null) {
			return 1;
		}
		
		String tagName1 =  tag1.getName();
		String tagName2 =  tag2.getName();
		
		return tagName1.compareTo(tagName2);
	}
}
```
###### \ArchPlanner\logic\DateTimeFormat.java
``` java
 *
 */
public class DateTimeFormat {

	//These constant string variables are used for display if the date is today, yesterday or tomorrow.
	private final String STRING_TODAY = "today";
	private final String STRING_YESTERDAY = "yesterday";
	private final String STRING_TOMORROW = "tomorrow";

	//These constant string variables are used to format date and time for display.
	private final String STRING_DATE_FORMAT = "dd MMM uuuu";
	private final String STRING_TIME_FORMAT = "h:mma";

	//This constant string variable is used if date or time is null.
	private final String STRING_EMPTY = "";
	
	/**
	 * This is getter method for string today.
	 * 
	 * @return	string today.
	 */
	public String getStringToday() {
		return STRING_TODAY;
	}
	
	/**
	 * This is getter method for string yesterday.
	 * 
	 * @return	string yesterday.
	 */
	public String getStringYesterday() {
		return STRING_YESTERDAY;
	}
	
	/**
	 * This is getter method for string tomorrow.
	 * 
	 * @return	string tomorrow.
	 */
	public String getStringTomorrow() {
		return STRING_TOMORROW;
	}
	
	/**
	 * This is getter method for string date format.
	 * 
	 * @return	string date format.
	 */
	public String getStringDateFormat() {
		return STRING_DATE_FORMAT;
	}
	
	/**
	 * This is getter method for string time format.
	 * 
	 * @return	string time format.
	 */
	public String getStringTimeFormat() {
		return STRING_TIME_FORMAT;
	}
	
	/**
	 * This is getter method for string empty.
	 * 
	 * @return	string empty.
	 */
	public String getStringEmpty() {
		return STRING_EMPTY;
	}
}
```
###### \ArchPlanner\logic\HistoryManager.java
``` java
 *
 */
public class HistoryManager {
	
	//This ArrayList stores the successful string commands input by users.
	private ArrayList<String> _previousUserInputList;
	
	//This ArrayList stores the old and new task after a user successfully entered a command.
	private ArrayList<RollbackItem> _undoList;
	
	//This ArrayList stores the old and new task after a user successfully undo a command.
	private ArrayList<RollbackItem> _redoList;
	
	//This variable is used to keep track of the previous and next string command previously entered by user.
	private int _previousUserInputCounter;
	
	//This is constructor of the class.
	public HistoryManager() {
		_previousUserInputList = new ArrayList<String>();
		_undoList = new ArrayList<RollbackItem>();
		_redoList = new ArrayList<RollbackItem>();
		_previousUserInputCounter = 0;
	}
	
	/**
	 * This is setter method for previous user input counter.
	 * 
	 * @param previousUserInputCounter	This number represents the distance from current point to the history command executed previously.
	 */
	public void setPreviousUserInputCounter(int previousUserInputCounter) {
		_previousUserInputCounter = previousUserInputCounter;
	}

	/**
	 * This is setter method for previous user input list.
	 * 
	 * @param previousUserInputList	This is the list of successful commands executed by user.
	 */
	public void setPreviousUserInputList(ArrayList<String> previousUserInputList) {
		_previousUserInputList = new ArrayList<String>();
		_previousUserInputList.addAll(previousUserInputList);
	}
	
	/**
	 *  This is setter method for undo list.
	 *  
	 * @param undoList	This is the list RollbackItem to support undo command.
	 */
	public void setUndoList(ArrayList<RollbackItem> undoList) {
		_undoList = new ArrayList<RollbackItem>();
		_undoList.addAll(undoList);
	}

	/**
	 *  This is setter method for redo list.
	 *  
	 * @param redoList	This is the list RollbackItem to support redo command.
	 */
	public void setRedoList(ArrayList<RollbackItem> redoList) {
		_redoList = new ArrayList<RollbackItem>();
		_redoList.addAll(redoList);
	}

	/**
	 * This is getter method for previous user input counter.
	 * 
	 * @return	previous user input counter.
	 */
	public int getPreviousUserInputCounter() {
		return _previousUserInputCounter;
	}
	
	/**
	 * This is getter method for previous user input list.
	 * 
	 * @return	previous user input counter.
	 */
	public ArrayList<String> getPreviousUserInputList() {
		return _previousUserInputList;
	}

	/**
	 * This is getter method for undo list.
	 * 
	 * @return	undo list
	 */
	public ArrayList<RollbackItem> getUndoList() {
		return _undoList;
	}

	/**
	 * This is getter method for redo list
	 * 
	 * @return	redo list
	 */
	public ArrayList<RollbackItem> getRedoList() {
		return _redoList;
	}
}
```
###### \ArchPlanner\logic\ListsManager.java
``` java
 *
 */
public class ListsManager {
	
	//This is the list that will be accessed used to populate other list.
	private ArrayList<Task> _mainList;
	
	//This is the list that will be used to display to the user.
	private ArrayList<Task> _viewList;

	//These are the lists that will be populated from main list based on category type.
	private ArrayList<Task> _deadlineList;
	private ArrayList<Task> _eventList;
	private ArrayList<Task> _floatingList;
	
	//These are the lists that will be populated from main list based on view type.
	private ArrayList<Task> _doneList;
	private ArrayList<Task> _undoneList;
	private ArrayList<Task> _overdueList;
	
	//This list of indexes that point to the tasks that are changed on added to the viewing list.
	private ArrayList<Integer> _indexList;
	
	//This list is the contains all the tags of all the tasks in the main list.
	private ArrayList<Tag> _tagsList;
	
	//This list is the contains all the tags that were selected.
	private ArrayList<String> _selectedTagsList;

	//This variable specifies the state of the view.
	private VIEW_TYPE _viewType;
	
	//This variable specifies the the category that the user is viewing.
	private CATEGORY_TYPE _categoryType;
	
	//This variable is the header to be displayed to user which specifies the current view state.
	private String _currentViewType;

	//This object variable is used to sort the list.
	private SortMechanism sort;
	
	//These constant string variables are used to append messages for readability.
	private final String STRING_DOUBLE_QUOTE = "\"";
	private final String STRING_SINGLE_SPACE = " ";
	private final String STRING_EMPTY = "";

	//This is constructor of the class.
	public ListsManager() {
		_mainList = new ArrayList<Task>();
		_viewList = new ArrayList<Task>();
		_deadlineList = new ArrayList<Task>();
		_eventList = new ArrayList<Task>();
		_floatingList = new ArrayList<Task>();
		_doneList = new ArrayList<Task>();
		_undoneList = new ArrayList<Task>();
		_overdueList = new ArrayList<Task>();
		_indexList = new ArrayList<Integer>();

		_tagsList = new ArrayList<Tag>();
		_selectedTagsList = new ArrayList<String>();
		_viewType = VIEW_TYPE.ALL;
		_categoryType = CATEGORY_TYPE.ALL;
		_currentViewType = STRING_EMPTY;

		sort = new SortMechanism();
	}

	/**
	 * This is setter method for current view type.
	 * 
	 * @param currentViewType	This is the current view type.
	 */
	public void setCurrentViewType(String currentViewType) {
		_currentViewType = currentViewType;
	}

	/**
	 * This is setter method for main list.
	 * 
	 * @param list	This is the list that replaces current main list.
	 */
	public void setMainList(ArrayList<Task> list) {
		_mainList.clear();
		_mainList.addAll(list);
	}

	/**
	 * This is setter method for view list.
	 * 
	 * @param list	This is the list that replaces current view list.
	 */
	public void setViewList(ArrayList<Task> list) {
		_viewList.clear();
		_viewList.addAll(list);
	}

	/**
	 * This is setter method for tags list.
	 * 
	 * @param list	This is the list that replaces current tags list.
	 */
	public void setTagsList(ArrayList<Tag> list) {
		_tagsList.clear();
		_tagsList.addAll(list);
	}

	/**
	 * This is setter method for view type.
	 * 
	 * @param viewType	This is the view type to replace the current view type.
	 */
	public void setViewType(VIEW_TYPE viewType) {
		_viewType = viewType;
	}

	/**
	 * This is setter method for category type.
	 * 
	 * @param categoryType	This is the category type that replaces current category type.
	 */
	public void setCategoryType(CATEGORY_TYPE categoryType) {
		_categoryType = categoryType;
	}

	/**
	 * This is getter method for main list.
	 * 
	 * @return	main list.
	 */
	public ArrayList<Task> getMainList() {
		return _mainList;
	}

	/**
	 * This is getter method for view list.
	 * 
	 * @return	view list.
	 */
	public ArrayList<Task> getViewList() {
		return _viewList;
	}

	/**
	 * This is getter method for tags list.
	 * 
	 * @return	tags list.
	 */
	public ArrayList<Tag> getTagsList() {
		return _tagsList;
	}

	/**
	 * This is getter method for _deadlineList arrayList.
	 * 
	 * @return	deadline list.
	 */
	public ArrayList<Task> getDeadlineList() {
		return _deadlineList;
	}

	/**
	 * This is getter method for event list.
	 * 
	 * @return	event list.
	 */
	public ArrayList<Task> getEventList() {
		return _eventList;
	}

	/**
	 * This is getter method for floating list.
	 * 
	 * @return	floating list.
	 */
	public ArrayList<Task> getFloatingList() {
		return _floatingList;
	}

	/**
	 * This is getter method for overdue list.
	 * 
	 * @return	overdue list.
	 */
	public ArrayList<Task> getOverdueList() {
		return _overdueList;
	}

	/**
	 * This is getter method for done list.
	 * 
	 * @return	done list.
	 */
	public ArrayList<Task> getDoneList() {
		return _doneList;
	}

	/**
	 * This is getter method for undone list.
	 * 
	 * @return	undone list.
	 */
	public ArrayList<Task> getUndoneList() {
		return _undoneList;
	}

	/**
	 * This is getter method for current view type.
	 * 
	 * @return	current view type.
	 */
	public String getCurrentViewType() {
		return _currentViewType;
	}

	/**
	 * This is getter method for view type.
	 * 
	 * @return	view type.
	 */
	public VIEW_TYPE getViewType() {
		return _viewType;
	}

	/**
	 * This is getter method for category type.
	 * 
	 * @return	category type.
	 */
	public CATEGORY_TYPE getCategoryType() {
		return _categoryType;
	}

	/**
	 * This is getter method for selected tags list.
	 * 
	 * @return	selected tags list.
	 */
	public ArrayList<String> getSelectedTagsList() {
		return _selectedTagsList;
	}

	/**
	 * This is getter method for index list.
	 * 
	 * @return	index list.
	 */
	public ArrayList<Integer> getIndexList() {
		return _indexList;
	}

	/**
	 * This method is used to set up all the lists when the system just starts up.
	 * 
	 * @param list	This is the list used to set up main list.
	 */
	public void setUpLists(ArrayList<Task> list) {
		if (list == null) {
			return;
		}
		setMainList(list);
		updateLists();
	}

	/**
	 * The method is used to update all the lists when user add or modify tasks after executing a successful command.
	 */
	public void updateLists() {
		clearAllLists();
		updateTaskIsOverdueStatus(getMainList());
		sortMainList();
		populateAllLists();
		setSelectedTag();
		updateViewList();
	}

	/**
	 * This method is used to add or remove the tag name in selected tags list 
	 * when a user selected or unselected a tag button displayed on UI, respectively.
	 * 
	 * @param tagName		This is the name of the tag.
	 * @param isSelected	This is the status of whether the tag is selected.
	 */
	public void updateSelectedTagsList(String tagName, boolean isSelected) {
		if (!getSelectedTagsList().contains(tagName) && isSelected) {
			getSelectedTagsList().add(tagName);
		} else if(getSelectedTagsList().contains(tagName) && !isSelected) {
			getSelectedTagsList().remove(tagName);
		}
	}

	/**
	 * This method add the index of the task that was modified or added to the  index list
	 * follow by sorting it in ascending order.
	 * 
	 * @param task	This is the task that is added or modified to the list.
	 */
	public void updateIndexList(Task task) {
		for (int i = getViewList().size() - 1; i >= 0; i--) {
			if (getViewList().get(i).equals(task)) {
				getIndexList().add(i);
				Collections.sort(getIndexList());
				return;
			}
		}
	}

	/**
	 * This method is used to update the view list based on view type, category type and the selected tags.
	 */
	public void updateViewList() {
		boolean hasTagSelected = false;
		ArrayList<Task> list = new ArrayList<Task>();
		getViewList().clear();
		updateViewListWithViewType(list);
		updateViewListWithCategoryType(list);
		hasTagSelected = hasTagSelected(hasTagSelected);
		updateViewListWithSelectedTags(list, hasTagSelected);
		setViewList(list);
	}

	/**
	 * This method is used to refresh the view list and update the list after checking whether the tasks are overdue.
	 */
	public void refreshViewList() {
		updateTaskIsOverdueStatus(getViewList());
	}
	
	/**
	 * This method is used to update view list based on selected category type.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithCategoryType(ArrayList<Task> list) {
		switch (getCategoryType()) {
		case TASKS :
			updateViewListWithCategoryTasks(list);
			break;
		case EVENTS : 
			updateViewListWithCategoryEvents(list);
			break;
		case DEADLINES : 
			updateViewListWithCategoryDeadlines(list);
			break;
		default : 
			break;
		}
	}

	/**
	 * This method is used to update view list based on selected view type.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithViewType(ArrayList<Task> list) {
		switch (getViewType()) {
		case ALL : 
			updateViewListWithViewAll(list);
			break;
		case DONE :
			updateViewListWithViewDone(list);
			break;
		case UNDONE : 
			updateViewListWithViewUndone(list);
			break;
		case OVERDUE : 
			updateViewListWithViewOverdue(list);
			break;
		}
	}

	/**
	 * This method is used to clear all the lists.
	 */
	private void clearAllLists() {
		_tagsList.clear();
		_viewList.clear();
		_deadlineList.clear();
		_eventList.clear();
		_floatingList.clear();
		_doneList.clear();
		_undoneList.clear();
		_overdueList.clear();
		_currentViewType = STRING_EMPTY;
	}

	/**
	 * This method is used to populate all the lists based the category type and view type.
	 */
	private void populateAllLists() {
		for (int i = 0; i < getMainList().size(); i++) {
			Task task = getMainList().get(i);

			populateCategoryLists(task);
			populateDoneList(task);
			populateUndoneList(task);
			populateOverdueList(task);
			populateTagsList(task);
		}
	}
	
	/**
	 * This method is used to populate overdue list with tasks from main list that are overdue.
	 * 
	 * @param task	This is the task that will be checked whether it is overdue.
	 */
	private void populateOverdueList(Task task) {
		if ((task.getIsOverdue() == true) && (!task.getIsDone())) {
			getOverdueList().add(task);
		}
	}

	/**
	 * This method is used to populate undone list with tasks from main list that are undone.
	 * 
	 * @param task	This is the task that will be checked whether it is undone.
	 */
	private void populateUndoneList(Task task) {
		if (task.getIsDone() == false){
			getUndoneList().add(task);
		}
	}

	/**
	 * This method is used to populate done list with tasks from main list that are done.
	 * 
	 * @param task	This is the task that will be checked whether it is done.
	 */
	private void populateDoneList(Task task) {
		if (task.getIsDone() == true) {
			getDoneList().add(task);
		}
	}

	/**
	 * This method is used to populate category lists based on category type.
	 * 
	 * @param task	This is the task that will be classified based on category type.
	 */
	private void populateCategoryLists(Task task) {
		if (hasNoStartDateAndNoEndDate(task)) {
			getFloatingList().add(task);
		} else if (hasStartDateAndNoEndDate(task) || hasStartDateAndEndDate(task)) {
			getEventList().add(task);
		} else if (hasEndDateAndNoStartDate(task)) {
			getDeadlineList().add(task);
		}
	}

	/**
	 * This method is used to populate tags list from checking the tasks in the main list.
	 * 
	 * @param task	This is the task that will be checked whether it has same tag name in tags list.
	 */
	private void populateTagsList(Task task) {
		for (int i = 0; i < task.getTagsList().size(); i++) {
			String taskTagName = task.getTagsList().get(i);
			Tag tag = new Tag(taskTagName, false);
			boolean hasSameTag = false;
			updateTagsList(taskTagName, tag, hasSameTag);
		}
	}

	/**
	 * This method is used to check if tags list contains the name of the tag of a task
	 * and update the update the tags list.
	 * 
	 * @param taskTagName	This is the task's tag name to be checked.
	 * @param tag			This is the task' tag with isSelected set to false.
	 * @param hasSameTag	This is the variable to check if the task's tag name contains in tags list.
	 */
	private void updateTagsList(String taskTagName, Tag tag, boolean hasSameTag) {
		for (int j = 0; j < getTagsList().size() && !hasSameTag; j++) {
			String tagsListTagName = getTagsList().get(j).getName();
			if (taskTagName.equals(tagsListTagName)) {
				hasSameTag = true;
			}
		}
		addTagIfNotFoundInTagsList(tag, hasSameTag);
	}
	
	/**
	 * This method is used to add the tag to the tags list if not found in tags list.
	 * 
	 * @param tag			This is the task' tag with isSelected set to false.
	 * @param hasSameTag	This is the variable to check if the task's tag name contains in tags list.
	 */
	private void addTagIfNotFoundInTagsList(Tag tag, boolean hasSameTag) {
		if (!hasSameTag) {
			getTagsList().add(tag);
		}
	}

	/**
	 * This method is used to check and update the list after checking for tasks that are overdue.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateTaskIsOverdueStatus(ArrayList<Task> list) {

		LocalDate currentDate = LocalDate.now();
		LocalTime currentTime = LocalTime.now();

		for (int i = 0; i < list.size(); i++) {
			Task task = list.get(i);
			task.setIsOverdue(false);
			setTaskIsOverdueIfBeforeCurrentTime(currentDate, currentTime, task);
		}
	}

	/**
	 * This method is used to set task to overdue if the allocated date and time is before current date and time.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueIfBeforeCurrentTime(LocalDate currentDate, LocalTime currentTime, Task task) {
		if (hasStartDateAndEndDate(task) || hasStartDateAndNoEndDate(task)) {
			setTaskIsOverdueIfStartIsBeforeCurrentDateTime(currentDate, currentTime, task);
		} else if (hasEndDateAndNoStartDate(task)) {
			setTaskIsOverdueIfEndIsBeforeCurrentDateTime(currentDate, currentTime, task);
		}
	}

	/**
	 * This method is used to set task to overdue if the end is before current.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueIfEndIsBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime, Task task) {
		if (task.getEndTime() != null) {
			setTaskIsOverdueIfEndDateTimeBeforeCurrentDateTime(currentDate, currentTime, task);
		} else {
			setTaskIsOverdueIfEndDateBeforeCurrentDate(currentDate, task);
		}
	}

	/**
	 * This method is used to set task to overdue if the end date is before current date.
	 * 
	 * @param currentDate	This is the current date.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueIfEndDateBeforeCurrentDate(LocalDate currentDate, Task task) {
		if (task.getEndDate().isBefore(currentDate)) {
			task.setIsOverdue(true);
		}
	}
	
	/**
	 * This method is used to set task to overdue if the end date and time is before current date and time.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueIfEndDateTimeBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime,
			Task task) {
		if (hasEndDateTimeBeforeCurrentDateTime(currentDate, currentTime, task)) {
			task.setIsOverdue(true);
		}
	}

	/**
	 * This method is used to check if task end date and time is before current date and time.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 * @return 				true if task end date and time is before current date and time or else return false
	 */
	private boolean hasEndDateTimeBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime, Task task) {
		return task.getEndDate().isBefore(currentDate) || (task.getEndDate().equals(currentDate) 
				&& task.getEndTime().isBefore(currentTime));
	}

	/**
	 * This method is used to set task to overdue if the start is before current.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueIfStartIsBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime, Task task) {
		if (task.getStartTime() != null) {
			setTaskIsOverdueStartDateTimeBeforeCurrentDateTime(currentDate, currentTime, task);
		} else {
			setTaskIsOverdueStartDateBeforeCurrentDate(currentDate, task);
		}
	}

	/**
	 * This method is used to set task to overdue if the start date is before current date
	 * 
	 * @param currentDate	This is the current date.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueStartDateBeforeCurrentDate(LocalDate currentDate, Task task) {
		if (task.getStartDate().isBefore(currentDate)) {
			task.setIsOverdue(true);
		}
	}

	/**
	 * This method is used to set task to overdue if the start date and time is before current date and time.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 */
	private void setTaskIsOverdueStartDateTimeBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime,
			Task task) {
		if (hasStartDateTimeBeforeCurrentDateTime(currentDate, currentTime, task)) {
			task.setIsOverdue(true);
		}
	}

	/**
	 * This method is used to check if task start date and time is before current date and time.
	 * 
	 * @param currentDate	This is the current date.
	 * @param currentTime	This is the current time.
	 * @param task			This is the task to be checked if it is overdue.
	 * @return				true if task start date and time is before current date and time or else return false
	 */
	private boolean hasStartDateTimeBeforeCurrentDateTime(LocalDate currentDate, LocalTime currentTime, Task task) {
		return task.getStartDate().isBefore(currentDate) || (task.getStartDate().equals(currentDate) 
				&& task.getStartTime().isBefore(currentTime));
	}

	/**
	 * This method  is used to check if task has start date and no end date.
	 * 
	 * @param task	This is the task that is checked for start and end date.
	 * @return		true if task has start date and no end date or else return false.
	 */
	private boolean hasStartDateAndNoEndDate(Task task) {
		return task.getStartDate() != null && task.getEndDate() == null;
	}

	/**
	 * This method  is used to check if task has start date and end date.
	 * 
	 * @param task	This is the task that is checked for start and end date.
	 * @return		true if task has start date and end date or else return false.
	 */
	private boolean hasStartDateAndEndDate(Task task) {
		return task.getStartDate() != null && task.getEndDate() != null;
	}

	/**
	 * This method  is used to check if task has no start date and has end date.
	 * 
	 * @param task	This is the task that is checked for start and end date.
	 * @return		true if task has no start date and has end date or else return false.
	 */
	private boolean hasEndDateAndNoStartDate(Task task) {
		return task.getStartDate() == null && task.getEndDate() != null;
	}

	/**
	 * This method  is used to check if task has no start date and no end date.
	 * 
	 * @param task	This is the task that is checked for start and no end date.
	 * @return		true if task has no start date and no end date or else return false.
	 */
	private boolean hasNoStartDateAndNoEndDate(Task task) {
		return task.getStartDate() == null && task.getEndDate() == null;
	}

	/**
	 * This method is used to update all the tags in the tags list with selected tags list.
	 */
	private void setSelectedTag() {
		for (int i = 0; i < getSelectedTagsList().size(); i++) {
			_currentViewType += STRING_DOUBLE_QUOTE + getSelectedTagsList().get(i) + STRING_DOUBLE_QUOTE + STRING_SINGLE_SPACE;
			boolean hasSameTag = false;
			String selectedTagName = getSelectedTagsList().get(i);
			setTagIsSelectedStatusIfExistsInSelectedTagsList(selectedTagName, hasSameTag);
		}
		sort.sortTagsList(_tagsList);
	}

	/**
	 * This method is used to set the tag to selected if the tag name contains in the _selectedTagsList.
	 * 
	 * @param selectedTagName	This is the name of the selected tag.
	 * @param hasSameTag		This is the variable to check if the task's tag name contains in tags list.
	 */
	private void setTagIsSelectedStatusIfExistsInSelectedTagsList(String selectedTagName, boolean hasSameTag) {
		for (int j = 0; j < getTagsList().size() && !hasSameTag; j++) {
			Tag tag = getTagsList().get(j);
			if (selectedTagName.equals(tag.getName())) {
				tag.setIsSelected(true);
				hasSameTag = true;
			}
		}
	}

	/**
	 * This method is used to sort the _mainList in the order of description, date and time, overdue and done status.
	 */
	private void sortMainList() {
		sort.sortListByDescription(getMainList());
		sort.sortListByDateTime(getMainList());
		sort.sortListByOverdue(getMainList());
		sort.sortListByDone(getMainList());
	}

	/**
	 * This method is used to check if any of the tag is selected.
	 * 
	 * @param hasTagSelected	This variable indicates if any of the tags is selected.
	 * @return					true if any of the tag is selected or else return false.
	 */
	private boolean hasTagSelected(boolean hasTagSelected) {
		for (int i = 0; i < getTagsList().size() && !hasTagSelected; i++) {
			Tag tag = getTagsList().get(i);
			hasTagSelected = hasTagSelected(hasTagSelected, tag);
		}
		return hasTagSelected;
	}

	/**
	 * This method is used check if the tag is selected.
	 * 
	 * @param hasTagSelected	This variable indicates if any of the tags is selected.
	 * @param tag				This is the tag to be checked if it is selected
	 * @return					true if any of the tag is selected or else return false.
	 */
	private boolean hasTagSelected(boolean hasTagSelected, Tag tag) {
		if (tag.getIsSelected()) {
			hasTagSelected = true;
		}
		return hasTagSelected;
	}
	
	/**
	 * This method is used to update view list if at least one tag is selected.
	 * 
	 * @param list				This is the list of tasks after meeting previous conditions.
	 * @param hasTagSelected	This variable indicates whether any tag is selected.
	 */
	private void updateViewListWithSelectedTags(ArrayList<Task> list, boolean hasTagSelected) {
		if (!hasTagSelected) {
			return;
		}
		for (int i = 0; i < list.size(); i++) {
			boolean hasSameTag = false;
			Task task = list.get(i);
			hasSameTag = hasSameTag(hasSameTag, task);
			i = removeTaskFromViewListIfNoSameTag(list, i, hasSameTag);
		}
	}

	/**
	 * This is used to remove task from view list if it does not contain any of the tags that are selected.
	 * 
	 * @param list			This is the list of tasks after meeting previous conditions.
	 * @param i				This is the index of the task to be checked whether it has the tag that is selected.
	 * @param hasSameTag 	This variable indicates whether any tag is selected.
	 * @return				index of the previous checked task.
	 */
	private int removeTaskFromViewListIfNoSameTag(ArrayList<Task> list, int i, boolean hasSameTag) {
		if (hasSameTag == false) {
			list.remove(i);
			i--;
		}
		return i;
	}

	/**
	 * This method checks if task has tag with the same name as the tag in the selected tags list.
	 * 
	 * @param hasSameTag	This variable indicates whether any tag is selected.
	 * @param task			This is the task to be checked whether it has any tag that is selected.
	 * @return				true if task has tag with the same name as the tag in the _selectedTagsList or else return false.
	 */
	private boolean hasSameTag(boolean hasSameTag, Task task) {
		for (int j = 0; j < getTagsList().size() && !hasSameTag; j++) {
			Tag tag = getTagsList().get(j);
			if (task.getTagsList().contains(tag.getName()) && tag.getIsSelected()) {
				hasSameTag = true;
			}
		}
		return hasSameTag;
	}

	/**
	 * This method is used to update view list with tasks that are deadline task.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithCategoryDeadlines(ArrayList<Task> list) {
		for (int i = 0; i < list.size(); i++) {
			Task task = list.get(i);
			i = removeTaskFromViewListIfIsNotCategoryDeadlines(list, i, task);
		}
	}

	/**
	 * This method is used to remove task from view list if it is not deadline task.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 * @param i 	This is the index of the task to be checked whether it is deadline task.
	 * @param task 	This is the task to be checked whether it is deadline task.
	 * @return		index of the previous checked task.
	 */
	private int removeTaskFromViewListIfIsNotCategoryDeadlines(ArrayList<Task> list, int i, Task task) {
		if (!hasEndDateAndNoStartDate(task)) {
			list.remove(i);
			i--;
		}
		return i;
	}

	/**
	 * This method is used to update view list with tasks that are event task.
	 * 
	 * @param list This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithCategoryEvents(ArrayList<Task> list) {
		for (int i = 0; i < list.size(); i++) {
			Task task = list.get(i);
			i = removeTaskFromViewListIfIsNotCategoryEvents(list, i, task);
		}
	}

	/**
	 * This method is used to remove task from view list if it is not event task.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 * @param i 	This is the index of the task to be checked whether it is event task.
	 * @param task 	This is the task to be checked whether it is event task.
	 * @return 		index of the previous checked task.
	 */
	private int removeTaskFromViewListIfIsNotCategoryEvents(ArrayList<Task> list, int i, Task task) {
		if (!hasStartDateAndNoEndDate(task) && !hasStartDateAndEndDate(task)) {
			list.remove(i);
			i--;
		}
		return i;
	}

	/**
	 * This method is used to update view list with tasks that are floating task.
	 * 
	 * @param list This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithCategoryTasks(ArrayList<Task> list) {
		for (int i = 0; i < list.size(); i++) {
			Task task = list.get(i);
			i = removeTaskFromViewListIfIsNotCategoryTasks(list, i, task);
		}
	}

	/**
	 * This method is used to remove task from view list if it is not floating task.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 * @param i 	This is the index of the task to be checked whether it is floating task.
	 * @param task 	This is the task to be checked whether it is floating task.
	 * @return		index of the previous checked task.
	 */
	private int removeTaskFromViewListIfIsNotCategoryTasks(ArrayList<Task> list, int i, Task task) {
		if (!hasNoStartDateAndNoEndDate(task)) {
			list.remove(i);
			i--;
		}
		return i;
	}

	/**
	 * This method is used to update view list with overdue tasks.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithViewOverdue(ArrayList<Task> list) {
		list.addAll(getOverdueList());
	}
	
	/**
	 * This method is used to update view list with undone tasks.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithViewUndone(ArrayList<Task> list) {
		list.addAll(getUndoneList());
	}

	/**
	 * This method is used to update view list with done tasks.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithViewDone(ArrayList<Task> list) {
		list.addAll(getDoneList());
	}

	/**
	 * This method is used to update view list with all tasks.
	 * 
	 * @param list	This is the list of tasks after meeting previous conditions.
	 */
	private void updateViewListWithViewAll(ArrayList<Task> list) {
		list.addAll(getMainList());
	}
}
```
###### \ArchPlanner\logic\Logic.java
``` java
 *
 */
public class Logic {
	
	//These are enum variables of command type.
	public enum COMMAND_TYPE {
		ADD, DELETE, EDIT, EXIT, UNDO, REDO, DONE, UNDONE, VIEW, SET, INVALID
	}

	//This is the logger used to log and observe the changes when program runs.
	static Logger log = Logger.getLogger(Logic.class.getName());

	//This is the Storage object used for accessing and saving data.
	private Storage _storage;

	//This is the ListsManager object used for accessing managing the lists of tasks and viewing state.
	private ListsManager _listsManager;

	//This is the HistoryManager object used for accessing and managing the history of successful commands executed by users.
	private HistoryManager _historyManager;

	//This is the Parser object used to translate string commands entered by user to command object.
	private Interpreter _interpreter;

	//These are the constant string variables of the category type.
	private final String STRING_DEADLINES = "Deadlines";
	private final String STRING_EVENTS = "Events";
	private final String STRING_TASKS = "Tasks";

	//These are the constant string variables of the view type.
	private final String STRING_DONE = "Done";
	private final String STRING_UNDONE = "Undone";
	private final String STRING_OVERDUE = "Overdue";

	//These are constant string variables for logging.
	private final String  LOGGER_MESSAGE_ANALYZING_COMMAND_INPUT = "Analyzing command input...";
	private final String  LOGGER_MESSAGE_CONFIRMED = "confirmed.";
	
	//These constant string used to append messages for readability.
	private final String STRING_EMPTY = "";
	private final String STRING_SINGLE_SPACE = " ";

	//This is constructor of the class.
	public Logic() {
		_storage = new Storage();
		_listsManager = new ListsManager();
		_historyManager = new HistoryManager();
		_interpreter = new Interpreter();
		loadFile();
	}

	/**
	 * This method is used to load the content in the storage file to the main list
	 * and populate the lists in ListsManager
	 */
	public void loadFile() {
		ArrayList<Task> mainList = new ArrayList<Task>();
		mainList = _storage.getMasterList();
		_listsManager.setUpLists(mainList);
	}

	/**
	 * This method is used to refresh the view list for any overdue task
	 */
	public void updateViewList() {
		_listsManager.refreshViewList();
	}

	/**
	 * This method is used to execute command after passing the string command to parser and got command object.
	 * 
	 * @param userInput	This is the string command entered by user.
	 * @return 			command object.
	 */
	public CommandInterface executeCommand(String userInput) {
		ArrayList<Tag> tagsListClone = getTagsListClone();

		CommandInterface commandInput = _interpreter.parseCommand(userInput, _listsManager.getViewList().size(), 
				_historyManager.getUndoList().size(), _historyManager.getRedoList().size(), tagsListClone);

		CommandInterface commandReturn = runCommand(commandInput);

		return save(userInput, commandInput, commandReturn);
	}

	/**
	 * This method is used to update ListsManager the selected category type and reset view type and update all the lists.
	 * 
	 * @param selectedCategory	This is the category type.
	 */
	public void setSelectedCategory(CATEGORY_TYPE selectedCategory) {
		_listsManager.setViewType(VIEW_TYPE.ALL);
		_listsManager.setCategoryType(selectedCategory);
		_listsManager.updateLists();
	}

	/**
	 * This method is used to update the selected tags list in ListsManager.
	 * 
	 * @param tagName	This is the name of the selected tag
	 * 
	 * @param isSelected This is the variable indicates whether the tag is selected.
	 */
	public void setSelectedTag(String tagName, boolean isSelected) {
		if (!isSelected) {
			updateTagsList(tagName);
		}
		_listsManager.updateSelectedTagsList(tagName, isSelected);
		_listsManager.setViewType(VIEW_TYPE.ALL);
		_listsManager.updateLists();
	}

	/**
	 * This method is used to retrieve the string of the previously executed command entered by user in HistoryManager.
	 * 
	 * @return	string of the previously executed command by user.
	 */
	public String getPreviousUserInput() {
		_historyManager.setPreviousUserInputCounter(_historyManager.getPreviousUserInputCounter() + 1);
		int previousUserInputListIndex = _historyManager.getPreviousUserInputList().size() - 
				_historyManager.getPreviousUserInputCounter() - 1;
		if ((previousUserInputListIndex >= 0) 
				&& (_historyManager.getPreviousUserInputList().size() > previousUserInputListIndex)) {
			String previousUserInput = _historyManager.getPreviousUserInputList().get(previousUserInputListIndex);
			return previousUserInput;
		}
		_historyManager.setPreviousUserInputCounter(_historyManager.getPreviousUserInputList().size() - 1);
		return STRING_EMPTY;
	}

	/**
	 * This method is used to retrieve the string of the next executed command entered by user in HistoryManager.
	 * 
	 * @return	string of the next executed command by user.
	 */
	public String getNextUserInput() {
		_historyManager.setPreviousUserInputCounter(_historyManager.getPreviousUserInputCounter() - 1);
		int previousUserInputListIndex = _historyManager.getPreviousUserInputList().size() 
				- _historyManager.getPreviousUserInputCounter() - 1;
		if ((previousUserInputListIndex >= 0) && 
				(_historyManager.getPreviousUserInputList().size() > previousUserInputListIndex)) {
			String previousUserInput = _historyManager.getPreviousUserInputList().get(previousUserInputListIndex);
			return previousUserInput;
		}
		_historyManager.setPreviousUserInputCounter(-1);
		return STRING_EMPTY;
	}

	/**
	 * This method is used to differentiate the category type.
	 * 
	 * @param selectedCategory	This is the category selected.
	 * @return					category type.
	 */
	public CATEGORY_TYPE getCategoryType(String selectedCategory) {
		switch (selectedCategory) {
		case STRING_DEADLINES : 
			return CATEGORY_TYPE.DEADLINES;
		case STRING_EVENTS : 
			return CATEGORY_TYPE.EVENTS;
		case STRING_TASKS : 
			return CATEGORY_TYPE.TASKS;
		default : 
			return CATEGORY_TYPE.ALL;
		}
	}

	/**
	 * This method is used to retrieve the selected view type.
	 * 
	 * @return	string view type.
	 */
	public String getSelectedView() {
		VIEW_TYPE viewType = _listsManager.getViewType();
		switch (viewType) {

		case ALL : 
			return STRING_EMPTY;
		case DONE: 
			return STRING_DONE;
		case UNDONE : 
			return STRING_UNDONE;
		default : 
			return STRING_OVERDUE;
		}
	}

	/**
	 * This method is used to retrieve the selected category in ListsManager.
	 * 
	 * @return	selected category.
	 */
	public CATEGORY_TYPE getSelectedCategory() {
		return _listsManager.getCategoryType();
	}

	/**
	 * This method is used to retrieve current view type.
	 * 
	 * @return	current view type.
	 */
	public String getCurrentViewType() {
		String selectedCategory = getSelectedCategory().toString();
		String currentViewType = selectedCategory + STRING_SINGLE_SPACE + getSelectedView() + STRING_SINGLE_SPACE 
				+ _listsManager.getCurrentViewType();
		return currentViewType;
	}

	/**
	 * This method is used to retrieve view list in ListsManager.
	 * 
	 * @return	view list.
	 */
	public ArrayList<Task> getViewList() {
		return _listsManager.getViewList();
	}

	/**
	 * This method is used to retrieve main list in ListsManager.
	 * 
	 * @return	main list
	 */
	public ArrayList<Task> getMainList() {
		return _listsManager.getMainList();
	}

	/**
	 * This method is used to retrieve tags list in ListsManager.
	 * 
	 * @return	tags list.
	 */
	public ArrayList<Tag> getTagsList() {
		return _listsManager.getTagsList();
	}

	/**
	 * This method is used to retrieve index list in ListsManager.
	 * 
	 * @return	index lists.
	 */
	public ArrayList<Integer> getIndexList() {
		return _listsManager.getIndexList();
	}

	/**
	 * This method is used to create a clone list of the tags list in ListsManager.
	 * 
	 * @return	tags list clone
	 */
	private ArrayList<Tag> getTagsListClone() {
		ArrayList<Tag> tagsListClone = new ArrayList<Tag>();
		for (int i = 0; i < _listsManager.getTagsList().size(); i++) {
			String tagName = _listsManager.getTagsList().get(i).getName();
			boolean tagIsSelected = _listsManager.getTagsList().get(i).getIsSelected();
			Tag tag = new Tag(tagName, tagIsSelected);
			tagsListClone.add(tag);
		}
		return tagsListClone;
	}

	/**
	 * This method is used to set tag's isSelected to false if the tag is no selected.
	 * 
	 * @param tagName	This is the name of the tag.
	 */
	private void updateTagsList(String tagName) {
		for (int i = 0; i < _listsManager.getTagsList().size(); i++) {
			Tag tag = _listsManager.getTagsList().get(i);
			if (tag.getName().equals(tagName)) {
				tag.setIsSelected(false);
			}
		}
	}

	/**
	 * This method is used to differentiate the type of command and call the relevant execute method of the command.
	 * 
	 * @param commandInput	This is the command object that the user is executing.
	 * @return				command object.
	 */
	private CommandInterface runCommand(CommandInterface commandInput) {

		log.info(LOGGER_MESSAGE_ANALYZING_COMMAND_INPUT);
		String strCommandType = commandInput.getClass().getSimpleName();

		COMMAND_TYPE commandType = getCommandType(strCommandType);
		log.info(commandType.toString() + STRING_SINGLE_SPACE + LOGGER_MESSAGE_CONFIRMED);

		if (commandType.equals(COMMAND_TYPE.EXIT)) {
			return commandInput.execute();
		} else if (commandType.equals(COMMAND_TYPE.SET)) {
			return commandInput.execute(_listsManager, _storage);
		} else {
			return commandInput.execute(_listsManager, _historyManager);
		}
	}

	/**
	 * This method is used to differentiate the command type.
	 * 
	 * @param strCommandType	This is the string command type.
	 * @return					command type.
	 */
	private COMMAND_TYPE getCommandType(String strCommandType) {
		if (strCommandType.equals("AddCommand")) {
			return COMMAND_TYPE.ADD;
		} else if (strCommandType.equals("DeleteCommand")) {
			return COMMAND_TYPE.DELETE;
		} else if (strCommandType.equals("EditCommand")) {
			return COMMAND_TYPE.EDIT;
		} else if (strCommandType.equals("ExitCommand")) {
			return COMMAND_TYPE.EXIT;
		} else if (strCommandType.equals("UndoCommand")) {
			return COMMAND_TYPE.UNDO;
		} else if (strCommandType.equals("RedoCommand")) {
			return COMMAND_TYPE.REDO;
		} else if (strCommandType.equals("DoneCommand")) {
			return COMMAND_TYPE.DONE;
		} else if (strCommandType.equals("UndoneCommand")) {
			return COMMAND_TYPE.UNDONE;
		} else if (strCommandType.equals("ViewCommand")) {
			return COMMAND_TYPE.VIEW;
		} else if (strCommandType.equals("SetCommand")) {
			return COMMAND_TYPE.SET;
		}else {
			return COMMAND_TYPE.INVALID;
		}
	}

	/**
	 * This method is used to save the updated main list in ListsManager to the file through Storage.
	 * 
	 * @param userInput		This is the string command entered by user.
	 * @param commandInput	This is the command object the user is executing.
	 * @param commandReturn This is the command object returned after the been executed.
	 * @return				the command object the user is executing.
	 */
	private CommandInterface save(String userInput, CommandInterface commandInput, CommandInterface commandReturn) {
		if (commandReturn != null && commandReturn instanceof InvalidCommand) {
			return commandReturn;
		} else if (commandReturn == null && commandInput instanceof InvalidCommand) {
			return commandInput;
		}
		updateUserInputList(userInput);
		_storage.writeStorageFile(_listsManager.getMainList());
		return commandInput;
	}

	/**
	 * This method is used to update the user input list in HistoryManager.
	 * 
	 * @param userInput	This is the string command entered by user.
	 */
	private void updateUserInputList(String userInput) {
		_historyManager.getPreviousUserInputList().add(userInput);
		_historyManager.setPreviousUserInputCounter(-1);
	}

	/**
	 * This method is used to test commands executed on logic component
	 * 
	 * @param commandInput	This is the command object to be executed for testing.
	 * @return				the command object.
	 */
	public CommandInterface logicTestEnvironment(CommandInterface commandInput) {
		return runCommand(commandInput);
	}
}
```
###### \ArchPlanner\logic\RollbackItem.java
``` java
 *
 */
public class RollbackItem {
	
	//This variable is used to specify the command type of the RollbackItem object.
	private COMMAND_TYPE _commandType;
	
	//This is the number of times of rollback.
	private int _times;
	
	//This is the Task object of an old task before a command is executed.
	private Task _oldTask;
	
	//This is the Task object of a new task after a command is executed.
	private Task _newTask;
	
	//This is constructor of the class.
	public RollbackItem(COMMAND_TYPE commandType, Task oldTask, Task newTask) {
		_commandType = commandType;
		_times = 1;
		_oldTask = oldTask;
		_newTask = newTask;
	}
	
	//This is constructor of the class.
	public RollbackItem(COMMAND_TYPE commandType, Task oldTask, Task newTask, int times) {
		_commandType = commandType;
		_times = times;
		_oldTask = oldTask;
		_newTask = newTask;
	}
	
	/**
	 * This is setter method for command type.
	 * 
	 * @param commandType	This will be the command Type of the RollbackItem.
	 */
	public void setCommandType(COMMAND_TYPE commandType) {
		_commandType = commandType;
	}
	
	/**
	 * This is setter method for times of rollback.
	 * 
	 * @param times	This will be the number of times of rollback of the RollbackItem.
	 */
	public void setTimes(int times) {
		_times = times;
	}
	
	/**
	 * This is setter method for old task.
	 * 
	 * @param oldTask	This will be the oldTask of the RollbackItem.
	 */
	public void setOldTask(Task oldTask) {
		_oldTask = oldTask;
	}
	
	/**
	 * This is setter method for new task.
	 * 
	 * @param newTask	This will be newTask of the RollbackItem.
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}
	
	/**
	 * This is getter method for command type.
	 * 
	 * @return	command type.
	 */
	public COMMAND_TYPE getCommandType() {
		return _commandType;
	}
	
	/**
	 * This is getter method for times of rollback.
	 * 
	 * @return	number of times of rollback.
	 */
	public int getTimes() {
		return _times;
	}
	
	/**
	 * This is getter method for old task.
	 * 
	 * @return	old task.
	 */
	public Task getOldTask() {
		return _oldTask;
	}
	
	/**
	 * This is getter method for new task.
	 * 
	 * @return	new task.
	 */
	public Task getNewTask() {
		return _newTask;
	}
}
```
###### \ArchPlanner\logic\SortMechanism.java
``` java
 *
 */
public class SortMechanism {

	/**
	 * This method sort the list by description in ascending order.
	 * 
	 * @param list	this is the list to be sorted.
	 */
	public void sortListByDescription(ArrayList<Task> list) {
		DescriptionComparator descriptionComp = new DescriptionComparator();
		Collections.sort(list, descriptionComp);
	}

	/**
	 * This method sort the list by overdue status with overdue tasks on the top of the list.
	 * 
	 * @param list	this is the list to be sorted.
	 */
	public void sortListByOverdue(ArrayList<Task> list) {
		OverdueComparator overdueComp = new OverdueComparator();
		Collections.sort(list, overdueComp);
	}

	/**
	 * This method sort the list by done status with done tasks on the bottom of the list.
	 * 
	 * @param list	this is the list to be sorted.
	 */
	public void sortListByDone(ArrayList<Task> list) {
		DoneComparator doneComp = new DoneComparator();
		Collections.sort(list, doneComp);
	}

	/**
	 * This method sort the list by name in ascending order.
	 * 
	 * @param list	this is the list to be sorted.
	 */
	public void sortTagsList(ArrayList<Tag> list) {
		TagComparator tagComp = new TagComparator();
		Collections.sort(list, tagComp);
	}
	
	/**
	 * This method is used to sort the list based on date and time from earlier task to later task.
	 * 
	 * @param list	This is the list to be sorted.
	 * @return		sorted list.
	 */
	public ArrayList<Task> sortListByDateTime(ArrayList<Task> list) {

		//This list contains tasks of the top part of the list.
		ArrayList<Task> top = new ArrayList<Task>();

		//This list contains tasks of the bottom part of the list.
		ArrayList<Task> bottom = new ArrayList<Task>();

		//return if list has less than 2 Task objects
		if (list.size() <= 1) {
			return list;
		}

		int mid = list.size() / 2;
		updateTopList(list, top, mid);
		updateBottomList(list, bottom, mid);

		top  = sortListByDateTime(top);
		bottom = sortListByDateTime(bottom);
		merge(list, top, bottom);

		return list;
	}

	/**
	 * This method is used to add task to bottom list.
	 * 
	 * @param list		This is the list to be sorted.
	 * @param bottom 	This is the bottom list.
	 * @param mid 		This is the index of the middle of the list.
	 */
	private void updateBottomList(ArrayList<Task> list, ArrayList<Task> bottom, int mid) {
		for (int i=mid; i<list.size(); i++) {
			bottom.add(list.get(i));
		}
	}

	/**
	 * This method is used to add task to top list.
	 * 
	 * @param list	This is the list to be sorted.
	 * @param top 	This is the top list.
	 * @param mid 	This is the index of the middle of the list.
	 */
	private void updateTopList(ArrayList<Task> list, ArrayList<Task> top, int mid) {
		for (int i=0; i<mid; i++) {
			top.add(list.get(i));
		}
	}

	/**
	 * This method is used to merge top and bottom list.
	 * 
	 * @param list		This is the list to be sorted.
	 * @param top 		This is the top list.
	 * @param bottom 	This is the bottom list.
	 */
	private void merge(ArrayList<Task> list, ArrayList<Task> top, ArrayList<Task> bottom) {

		int listIndex = 0;
		int topIndex = 0;
		int bottomIndex = 0;

		//Loop and add tasks from top and bottom lists while topIndex and bottomIndex 
		//is less than top list's size and bottom list's size
		while (topIndex < top.size() && bottomIndex < bottom.size()) {
			Task topTask = top.get(topIndex);
			Task bottomTask = bottom.get(bottomIndex);

			if ( isTopTaskFloatingAndBottomTaskWithDate(topTask, bottomTask) || hasTopTaskIsAfterBottomTask(topTask, bottomTask)) {
				list.set(listIndex, bottom.get(bottomIndex));
				bottomIndex++;
			} else {
				list.set(listIndex, top.get(topIndex));
				topIndex++;
			}
			listIndex++;
		}

		int leftOverIndex = setLeftOverIndex(top, topIndex, bottomIndex);
		ArrayList<Task> leftOver = setLeftOverList(top, bottom, topIndex);
		listIndex = setListIndex(list, listIndex, leftOverIndex, leftOver);
	}

	/**
	 * This method is used to set the list index.
	 * 
	 * @param list			This is the list to be sorted.
	 * @param listIndex		This is the index of the sorted list.
	 * @param leftOverIndex This is the index of the leftOver list
	 * @param leftOver 		This is the list of leftover tasks after merging top and bottom lists with indexes within lists' size.
	 * @return lists 		index.
	 */
	private int setListIndex(ArrayList<Task> list, int listIndex, int leftOverIndex, ArrayList<Task> leftOver) {
		for (int i = leftOverIndex; i < leftOver.size(); i++) {
			list.set(listIndex, leftOver.get(i));
			listIndex++;
		}
		return listIndex;
	}
	
	/**
	 * This method is used to set the leftOver list with the remaining tasks after merging top and bottom lists.
	 * 
	 * @param top		This is the top list.
	 * @param bottom	This is the bottom list.
	 * @param topIndex	This is the top list index.
	 * @return			leftOver	list.
	 */
	private ArrayList<Task> setLeftOverList(ArrayList<Task> top, ArrayList<Task> bottom, int topIndex) {
		ArrayList<Task> leftOver;
		if (topIndex >= top.size()) {
			leftOver = bottom;
		} else {
			leftOver = top;
		}
		return leftOver;
	}

	/**
	 * This method set leftOver list index with the number of remaining tasks after merging top and bottom lists.
	 * 
	 * @param top			This is the top list.
	 * @param topIndex 		This is the top list index.
	 * @param bottomIndex 	This is the bottom list index.
	 * @return 				leftOver index.
	 */
	private int setLeftOverIndex(ArrayList<Task> top, int topIndex, int bottomIndex) {
		int leftOverIndex;
		if (topIndex >= top.size()) {
			leftOverIndex = bottomIndex;
		} else {
			leftOverIndex = topIndex;
		}
		return leftOverIndex;
	}

	/**
	 * This method is used to check top task is floating task and bottom task has start or end date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task is floating task and bottom task has start or end date, or else return false.
	 */
	private boolean isTopTaskFloatingAndBottomTaskWithDate(Task topTask, Task bottomTask) {
		return ((topTask.getStartDate() == null && topTask.getEndDate() == null)
				&& (((bottomTask.getStartDate() != null)) || (bottomTask.getEndDate() != null)));
	}

	/**
	 * This method is used to check whether top task is earlier than bottom task.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask 	This is the bottom task.
	 * @return 				true if top task is earlier than bottom task or else return false.
	 */
	private boolean hasTopTaskIsAfterBottomTask(Task topTask, Task bottomTask) {

		return (hasTopTaskStartDateIsAfterBottomTaskStartDate(topTask, bottomTask) 
				|| hasTopTaskStartTimeIsAfterBottomTaskStartTime(topTask, bottomTask) 
				|| hasTopTaskStartDateIsAfterBottomTaskEndDate(topTask, bottomTask) 
				|| hasTopTaskEndDateIsAfterBottomTaskStartDate(topTask, bottomTask)
				|| hasTopTaskStartTimeIsAfterBottomTaskEndTime(topTask, bottomTask) 
				|| hasTopTaskEndTimeIsAfterBottomTaskstartTime(topTask, bottomTask)
				|| hasTopTaskEndDateIsAfterBottomTaskEndDate(topTask, bottomTask))
				|| hasTopTaskEndTimeIsAfterBottomTaskEndTime(topTask, bottomTask);
	}

	/**
	 * This method is used to check whether both tasks have start date and whether 
	 * top task's start date is after bottom task's start date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if both tasks have start date and top task's start date is after bottom task's start date.
	 */
	private boolean hasTopTaskStartDateIsAfterBottomTaskStartDate(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() != null && bottomTask.getStartDate() != null) 
				&& topTask.getStartDate().isAfter(bottomTask.getStartDate()));
	}

	/**
	 * This method is used to check whether both tasks have start date and time with same date, 
	 * and whether top task's start time is after bottom task's start time.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if both tasks have start date and time with same date, and top task's start time is after 
	 * 		   				bottom task's start time.
	 */
	private boolean hasTopTaskStartTimeIsAfterBottomTaskStartTime(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() != null && bottomTask.getStartDate() != null)
				&& (topTask.getStartTime() != null && bottomTask.getStartTime() != null) 
				&& topTask.getStartDate().equals(bottomTask.getStartDate())
				&& topTask.getStartTime().isAfter(bottomTask.getStartTime()));
	}

	/**
	 * This method is used to check whether top task has start date and bottom task has no start date but has end date, 
	 * and whether top task's start date is after bottom task's end date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task has start date and bottom task has no start date but has end date, 
	 * 		  				and top task's start date is after than bottom task's end date.
	 */
	private boolean hasTopTaskStartDateIsAfterBottomTaskEndDate(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() != null && bottomTask.getStartDate() == null 
				&& bottomTask.getEndDate() != null) && topTask.getStartDate().isAfter(bottomTask.getEndDate()));
	}

	/**
	 * This method is used to check whether top task has start date and time and bottom task has no start date 
	 * but has end date and end time, whether top task's start date is same as bottom task's end date,
	 * and whether top task's start time is after bottom task's end time.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return 				true if top task has start date and time and bottom task has no start date but has end date and end time, 
	 * 		   				with top task's start date is same as bottom task's end date, and top task's start time is after
	 *         				bottom task's end time.
	 */
	private boolean hasTopTaskStartTimeIsAfterBottomTaskEndTime(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() != null && bottomTask.getStartDate() == null && bottomTask.getEndDate() != null)
				&& (topTask.getStartTime() != null && bottomTask.getEndTime() != null) 
				&& topTask.getStartDate().equals(bottomTask.getEndDate())
				&& topTask.getStartTime().isAfter(bottomTask.getEndTime()));
	}

	/**
	 * This method is used to check whether top task has start date and end date and bottom task has start date,
	 * and whether top task's end date is after bottom task's start date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task has start date and end date and bottom task has start date,
	 * 		   				and top task's end date is after bottom task's start date.
	 */
	private boolean hasTopTaskEndDateIsAfterBottomTaskStartDate(Task topTask, Task bottomTask) {

		return ((bottomTask.getStartDate() != null && topTask.getStartDate() == null && topTask.getEndDate() != null)
				&& topTask.getEndDate().isAfter(bottomTask.getStartDate()));
	}

	/**
	 * This method is used to check whether top task has no start date, has end date and time, and bottom task has start date and time,
	 * whether top task's end date is same as bottom task's start date,
	 * and whether top task's end time is after bottom task's start time.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task has no start date, has end date and time, and bottom task has start date and time,
	 *         				with top task's end date is same as bottom task's start date,
	 *         				and top task's end time is after bottom task's start time.
	 */
	private boolean hasTopTaskEndTimeIsAfterBottomTaskstartTime(Task topTask, Task bottomTask) {

		return ((bottomTask.getStartDate() != null && topTask.getStartDate() == null && topTask.getEndDate() != null)
				&& (topTask.getEndTime() != null && bottomTask.getStartTime() != null) 
				&& topTask.getEndDate().equals(bottomTask.getStartDate())
				&& topTask.getEndTime().isAfter(bottomTask.getStartTime()));
	}
	
	/**
	 * This method is used to check whether top task has no start date but has end date, and bottom task has no start date 
	 * but has end date, and whether top task's end date is after bottom task's end date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task has no start date but has end date, and bottom task has no start date but has end date, 
	 * 		   				and top task's end date is after bottom task's end date.
	 */
	private boolean hasTopTaskEndDateIsAfterBottomTaskEndDate(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() == null && bottomTask.getStartDate() == null) 
				&& (topTask.getEndDate() != null && bottomTask.getEndDate() != null) 
				&& topTask.getEndDate().isAfter(bottomTask.getEndDate()));
	}

	/**
	 * This method is used to check whether top task has no start date but has end date and time, and bottom task has no start date 
	 * but has end date and time, whether top task's end date is same as bottom task's end date,
	 * and whether top task's end date is after bottom task's end date.
	 * 
	 * @param topTask		This is the top task.
	 * @param bottomTask	This is the bottom task.
	 * @return				true if top task has no start date but has end date and time, and bottom task has no start date 
	 *         				but has end date and time, with top task's end date is same as bottom task's end date,
	 *         				and top task's end date is after bottom task's end date.
	 */
	private boolean hasTopTaskEndTimeIsAfterBottomTaskEndTime(Task topTask, Task bottomTask) {

		return ((topTask.getStartDate() == null && bottomTask.getStartDate() == null) 
				&& (topTask.getEndDate() != null && bottomTask.getEndDate() != null) 
				&& (topTask.getEndTime() != null && bottomTask.getEndTime() != null) 
				&& topTask.getEndDate().isEqual(bottomTask.getEndDate()) 
				&& topTask.getEndTime().isAfter(bottomTask.getEndTime()));
	}
}
```
###### \ArchPlanner\logic\Tag.java
``` java
 *
 */
public class Tag {
	
	//This variable is the name of the Tag object
	private String _name;
	
	//This variable indicates whether the Tag is selected.
	private boolean _isSelected;
	
	//This is constructor of the class.
	public Tag(String name, boolean isSelected) {
		_name = name;
		_isSelected = isSelected;
	}
	
	/**
	 * This is setter method for Tag's name.
	 * 
	 * @param name	This will be the name of the Tag.
	 */
	public void setName(String name) {
		_name = name;
	}
	
	/**
	 * This is setter method for isSelected.
	 * 
	 * @param isSelected	This will be the status of isSelected of the Tag.
	 */
	public void setIsSelected(boolean isSelected) {
		_isSelected = isSelected;
	}
	
	/**
	 * This is getter method for Tag's name.
	 * 
	 * @return	Tag's name.
	 */
	public String getName() {
		return _name;
	}
	
	/**
	 * This is getter method for Tag's isSelected.
	 * 
	 * @return	Tag's isSelected that indicates whether the Tag is selected.
	 */
	public boolean getIsSelected() {
		return _isSelected;
	}
}
```
###### \ArchPlanner\logic\Task.java
``` java
 *
 */
public class Task extends TaskParameters implements Serializable {

	/**
	 * This is a generated serial UID for serializing
	 */
	private static final long serialVersionUID = 4512516990029160337L;

	//This is constructor of the class.
	public Task() {
		super();
	}

	//This is constructor of the class.
	public Task(String description, ArrayList<String> tagsList, LocalDate startDate, LocalTime startTime, 
			LocalDate endDate, LocalTime endTime) {
		super(description, tagsList, startDate, startTime, endDate, endTime);
	}
}
```
###### \ArchPlanner\logic\TaskParameters.java
``` java
 *
 */
public class TaskParameters {
	
	//This variable is the description of the TaskParameters object
	private String _description;
	
	//This is the list of tags of the TaskParameters object
	private ArrayList<String> _tagsList;
	
	//This variable is the start date of the TaskParameters object
	private LocalDate _startDate;
	
	//This variable is the end date of the TaskParameters object
	private LocalDate _endDate;
	
	//This variable is the start time of the TaskParameters object
	private LocalTime _startTime;
	
	//This variable is the end time of the TaskParameters object
	private LocalTime _endTime;
	
	//This variable indicates whether the task is done.
	private boolean _isDone;
	
	//This variable indicates whether the task is overdue.
	private boolean _isOverdue;

	//This is constructor of the class.
	public TaskParameters() {
		_description = null;
		_tagsList = null;
		_startDate = null;
		_startTime = null;
		_endDate = null;
		_endTime = null;
		_isDone = false;
		_isOverdue = false;
	}
	
	//This is constructor of the class.
	public TaskParameters(String description, ArrayList<String> tagsList, LocalDate startDate, LocalTime startTime, 
			LocalDate endDate, LocalTime endTime) {
		_description = description;
		_tagsList = tagsList;
		_startDate = startDate;
		_startTime = startTime;
		_endDate = endDate;
		_endTime = endTime;
		_isDone = false;
		_isOverdue = false;
	}

	/**
	 * This is setter method for TaskParameters' description.
	 * 
	 * @param description	This will be the description of the TaskParamters.
	 */
	public void setDescription(String description) {
		_description = description;
	}

	/**
	 * This is setter method for TaskParameters' tags list.
	 * 
	 * @param tagsList	This will be the tags list of the TaskParamters.
	 */
	public void setTagsList(ArrayList<String> tagsList) {
		_tagsList = tagsList;
	}

	/**
	 * This is setter method for TaskParameters' start date.
	 * 
	 * @param startDate	This will be the start date of the TaskParameters.
	 */
	public void setStartDate(LocalDate startDate) {
		_startDate = startDate;
	}
	

	/**
	 * This is setter method for TaskParameters' start time.
	 * 
	 * @param startTime	This will be the start time of the TaskParameters.
	 */
	public void setStartTime(LocalTime startTime) {
		_startTime = startTime;
	}
	

	/**
	 * This is setter method for TaskParameters' end date.
	 * 
	 * @param endDate	This will be the end date of the TaskParameters.
	 */
	public void setEndDate(LocalDate endDate) {
		_endDate = endDate;
	}
	

	/**
	 * This is setter method for TaskParameters' end time.
	 * 
	 * @param endTime	This will be the end time of the TaskParameters.
	 */
	public void setEndTime(LocalTime endTime) {
		_endTime = endTime;
	}


	/**
	 * This is setter method for TaskParameters' isDone.
	 * 
	 * @param isDone	This is the done status of the TaskParameters.
	 */
	public void setIsDone(boolean isDone) {
		_isDone = isDone;
	}

	/**
	 * This is setter method for TaskParameters' isOverdue.
	 * 
	 * @param isOverdue	This is the overdue status of the TaskParameters.
	 */
	public void setIsOverdue(boolean isOverdue) {
		_isOverdue = isOverdue;
	}

	/**
	 * This is getter method for TaskParameters' description.
	 * 
	 * @return	description of TaskParameters.
	 */
	public String getDescription() {
		return _description;
	}

	/**
	 * This is getter method for TaskParameters' tags list.
	 * 
	 * @return	tags list.
	 */
	public ArrayList<String> getTagsList() {
		return _tagsList;
	}

	/**
	 * This is getter method for TaskParameters' start date.
	 * 
	 * @return	start date.
	 */
	public LocalDate getStartDate() {
		return _startDate;
	}
	
	/**
	 * This is getter method for TaskParameters' start time.
	 * 
	 * @return	start time.
	 */
	public LocalTime getStartTime() {
		return _startTime;
	}
	
	/**
	 * This is getter method for TaskParameters' end date.
	 * 
	 * @return	end date.
	 */
	public LocalDate getEndDate() {
		return _endDate;
	}
	
	/**
	 * This is getter method for TaskParameters' end time.
	 * 
	 * @return	end time.
	 */
	public LocalTime getEndTime() {
		return _endTime;
	}

	/**
	 * This is getter method for TaskParameters' start date in string format.
	 * 
	 * @return	start date in string format.
	 */
	public String getStartDateString() {
		String startDateString = getDateString(_startDate);
		return startDateString;
	}

	/**
	 * This is getter method for TaskParameters' start time in string format.
	 * 
	 * @return	start time in string format.
	 */
	public String getStartTimeString() {
		String startTime = getTimeString(_startTime);
		return startTime;
	}

	/**
	 * This is getter method for TaskParameters' end date in string format.
	 * 
	 * @return	end date in string format.
	 */
	public String getEndDateString() {
		String endDateString = getDateString(_endDate);
		return endDateString;
	}

	/**
	 * This is getter method for TaskParameters' end time in string format.
	 * 
	 * @return	end time in string format.
	 */
	public String getEndTimeString() {
		String endTime = getTimeString(_endTime);
		return endTime;
	}

	/**
	 * This is getter method for TaskParameters' isDone.
	 * 
	 * @return done status.
	 */
	public boolean getIsDone() {
		return _isDone;
	}

	/**
	 * This is getter method for TaskParameters' isOverdue.
	 * 
	 * @return	overdue status.
	 */
	public boolean getIsOverdue() {
		return _isOverdue;
	}

	/**
	 * This method is used to convert date from localDate to string format.
	 * 
	 * @param date	This is the date of TaskParameters.
	 * @return		date in string format.
	 */
	private String getDateString(LocalDate date) {

		DateTimeFormat dateTimeFormat = new DateTimeFormat();
		
		LocalDate today = LocalDate.now();
		LocalDate yesterday = today.minusDays(1);
		LocalDate tomorrow = today.plusDays(1);
		
		if (date == null) {
			return dateTimeFormat.getStringEmpty();
		} else if (date.isEqual(today)) {
			return dateTimeFormat.getStringToday();
		} else if (date.isEqual(yesterday)) {
			return dateTimeFormat.getStringYesterday();
		} else if (date.isEqual(tomorrow)) {
			return dateTimeFormat.getStringTomorrow();
		}
		
		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(dateTimeFormat.getStringDateFormat());
		return dateTimeFormatter.format(date);
	}

	/**
	 * This method is used to convert time from localTime to string format.
	 * 
	 * @param time	This is the time of TaskParameters.
	 * @return		time in string format.
	 */
	private String getTimeString(LocalTime time) {
		
		DateTimeFormat dateTimeFormat = new DateTimeFormat();
		
		if (time == null) {
			return dateTimeFormat.getStringEmpty();
		}

		DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(dateTimeFormat.getStringTimeFormat());
		return dateTimeFormatter.format(time);
	}
}
```
###### \ArchPlanner\storage\Storage.java
``` java
 *
 */
public class Storage {

	//This list is used to store the entries of tasks in the file
	private ArrayList<Task> _masterList = new ArrayList<Task>();

	//This is the file path of the file to be manipulated by the program.
	private String _filePath;

	//This the storage file to be manipulated by the program.
	private File _storageFile;

	//This is the linker file to be manipulated by the program.
	private File _linkerFile;

	//This is the default file name of the file to be manipulated by the program.
	private final String _fileName = "archplanner.txt";

	//This is the name of the linker file that indicates the storage file location.
	private final String _linkerName = "linker.txt";
	
	//These are the variables used to manage the file system.
	private final String SYSTEM_NAME = "os.name";
	private final String SYSTEM_DRIVE = "SystemDrive";
	private final String USER_NAME = "user.name";
	private final String SYSTEM_NAME_MAC_OS = "Mac OS";
	private final String SYSTEM_NAME_WINDOWS = "Windows";
	private final String USERS_DIRECTORY = "/Users/";
	private final String MAC_OS_PROGRAM_SUB_DIRECTORY = "/Documents/ArchPlanner/";
	private final String WINDOWS_PROGRAM_SUB_DIRECTORY = "/AppData/Local/ArchPlanner/";

	//These are the error message to be output when error occurs.
	private final String ERROR_MESSAGE_CREATE_FILE_FAILED = "Failed to create file";
	private final String ERROR_MESSAGE_ACCESS_FILE_FAILED = "Failed to acesss file";

	//This constant string variable is used to append messages for readability.
	private final String STRING_EMPTY = "";
	private final String STRING_NEW_LINE = "\r\n";

	//This is constructor of the class.
	public Storage() {
		_storageFile = null;
		_linkerFile = null;
		setFilePathToDefault();
		loadStorageFile();
	}

	/**
	 * This is setter method for master list.
	 * 
	 * @param list	This will be the master list.
	 */
	public void setMasterList(ArrayList<Task> list) {
		_masterList = list;
	}

	/**
	 * This is the setter method for file path.
	 * 
	 * @param filePath	This will be the file path.
	 */
	public void setFilePath(String filePath) {
		_filePath = filePath;
	}

	/**
	 * This is setter method for storage file.
	 * 
	 * @param file	This will be the storage file.
	 */
	public void setStorageFile(File file) {
		_storageFile = file;
	}

	/**
	 * This is setter method for linker file.
	 * 
	 * @param file	This will be the linker file.
	 */
	public void setLinkerFile(File file) {
		_linkerFile = file;
	}

	/**
	 * This is getter method for master list.
	 * 
	 * @return	master list.
	 */
	public ArrayList<Task> getMasterList() {
		return _masterList;
	}

	/**
	 * This is getter method for file path.
	 * 
	 * @return	file path.
	 */
	public String getFilePath() {
		return _filePath;
	}

	/**
	 * This is getter method for storage file.
	 * 
	 * @return	storage file.
	 */
	public File getStorageFile() {
		return _storageFile;
	}

	/**
	 * This is getter method for linker file.
	 * 
	 * @return	storage file.
	 */
	public File getLinkerFile() {
		return _linkerFile;
	}

	/**
	 * This is getter method for file name.
	 * 
	 * @return	file name.
	 */
	public String getFileName() {
		return _fileName;
	}

	/**
	 * This is getter method for linker file name.
	 * 
	 * @return	linker file name.
	 */
	public String getLinkerName() {
		return _linkerName;
	}

	/**
	 * This method is used to load the files.
	 */
	public void loadStorageFile() {
		setLinkerFile(new File(getLinkerPath()));
		createLinkerFileIfNotExists();
		initializeFile();
	}
	
	/**
	 * This method is used to set new file path.
	 * 
	 * @param filePath	This will be the new file path.
	 */
	public void setNewFilePath(String filePath) {
		try {
			FileWriter fileWriter;
			setFilePath(filePath);
			setStorageFile(new File(getFilePath()));
			createProgramFolder();
			fileWriter = new FileWriter(getLinkerPath(), false);
			fileWriter.append(getFilePath() + STRING_NEW_LINE);
			fileWriter.close();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_ACCESS_FILE_FAILED);
		}
	}

	/**
	 * This method is used to set file path to an existing file path.
	 * 
	 * @param filePath	This is the exisitng file path.
	 */
	public void setExistingFilePath(String filePath) {
		try {
			FileWriter fileWriter;
			setFilePath(filePath);
			setStorageFile(new File(getFilePath()));
			createProgramFolder();
			fileWriter = new FileWriter(getLinkerPath(), false);
			fileWriter.append(getFilePath() + STRING_NEW_LINE);
			fileWriter.close();
			readStorageFile();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_ACCESS_FILE_FAILED);
		}
	}

	/**
	 * This method is used to set file path to default.
	 */
	public void setDefaultFilePath() {
		try {
			FileWriter fileWriter;
			setFilePath(getDefaultFilePath());
			setStorageFile(new File(getDefaultFilePath()));
			createProgramFolder();
			fileWriter = new FileWriter(getLinkerPath(), false);
			fileWriter.append(getFilePath() + STRING_EMPTY);
			fileWriter.close();
			readStorageFile();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_ACCESS_FILE_FAILED);
		}
	}

	/**
	 * This method is used to write the list of tasks to the file.
	 * 
	 * @param list	This is the lists of tasks to be saved to the file.
	 */
	public void writeStorageFile(ArrayList<Task> list) {
		Gson gson = new GsonBuilder().setPrettyPrinting().create();
		Type type = new TypeToken<ArrayList<Task>>() {}.getType();
		String json = gson.toJson(list, type);

		FileWriter fileWriter;
		createLinkerFileIfNotExists();

		try {
			fileWriter = new FileWriter(getFilePath());
			fileWriter.write(json);
			fileWriter.close();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_ACCESS_FILE_FAILED);
		}
	}

	/**
	 * This method is used to create linker file if it does not exists.
	 */
	private void createLinkerFileIfNotExists() {
		if (!getLinkerFile().exists() || !getLinkerFile().isFile()) {
			createProgramFolder();
			createFile(_linkerFile);
		}
	}

	/**
	 * This method is used to create folder of this program.
	 */
	private void createProgramFolder() {
		String programFolderDirectory = getDefaultDirectory().substring(0, getDefaultDirectory().length() - 1);
		new File(programFolderDirectory).mkdirs();
	}

	/**
	 * This method is used to load the file using the file path stored in linker file. If file path is not found,
	 * file path is set to default.
	 */
	private void initializeFile() {
		try {
			Scanner scan = new Scanner(getLinkerFile());
			if (scan.hasNextLine()) {
				setFilePath(scan.nextLine());
				scan.close();
			} else {
				setFilePathToDefault();
			}
			scan.close();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_ACCESS_FILE_FAILED);
		}
		setStorageFile(new File(getFilePath()));
		readStorageFile();
	}

	/**
	 * This method is used to read storage file.
	 */
	private void readStorageFile() {
		Gson gson = new Gson();
		BufferedReader bufferedReader;
		try {
			bufferedReader = new BufferedReader(new FileReader(getFilePath()));
			setMasterList(gson.fromJson(bufferedReader, new TypeToken<ArrayList<Task>>(){}.getType()));
			bufferedReader.close();
		} catch (Exception e) {
			getStorageFile().delete();
			createFile(getStorageFile());
		}
	}

	/**
	 * this method is used to create new file.
	 * 
	 * @param file	This is the file to be created.
	 */
	private void createFile(File file) {
		try {
			file.createNewFile();
		} catch (Exception e) {
			System.out.println(ERROR_MESSAGE_CREATE_FILE_FAILED);
		}
	}

	/**
	 * This method is used to retrieve the default directory for storing of file.
	 * 
	 * @return	default directory.
	 */
	private String getDefaultDirectory() {
		String systemName = System.getProperty(SYSTEM_NAME);
		String systemDrive = System.getenv(SYSTEM_DRIVE);
		String userName = System.getProperty(USER_NAME);
		String defaultDirectory;
		if (systemName.startsWith(SYSTEM_NAME_MAC_OS)) {
			defaultDirectory = USERS_DIRECTORY + userName + MAC_OS_PROGRAM_SUB_DIRECTORY;
		} else if (systemName.startsWith(SYSTEM_NAME_WINDOWS)) {
			defaultDirectory = systemDrive + USERS_DIRECTORY + userName + WINDOWS_PROGRAM_SUB_DIRECTORY;
		} else {
			defaultDirectory = STRING_EMPTY;
		}
		return defaultDirectory;
	}
	/**
	 * This method is used to get the file path of the linker file.
	 * 
	 * @return	linker file's file path.
	 */
	private String getLinkerPath() {
		String defaultLinkerPath = getDefaultDirectory() + getLinkerName();
		return defaultLinkerPath;
	}

	/**
	 * This method is used to get the file path of the storage file.
	 * 
	 * @return	storage file's file path.
	 */
	private String getDefaultFilePath() {
		String defaultLinkerPath = getDefaultDirectory() + getFileName();
		return defaultLinkerPath;
	}

	/**
	 * This method is used to set file path to default.
	 */
	private void setFilePathToDefault() {
		setFilePath(getDefaultDirectory() + getFileName());
	}
}
```
###### \ArchPlanner\test\logic\LogicAddCommandTest.java
``` java
 *
 */
public class LogicAddCommandTest {

    private Logic logic;

    private CommandInterface addCommandTest;


    @Before
    public void setUp() throws Exception {
        logic = new Logic();
        tearDown();
    }

    @After
    public void tearDown() throws Exception {
        logic.getMainList().clear();
        logic.getViewList().clear();
    }

    @Test
    public void testAddTask() {
    	
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), null, null, null, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddDeadlineWithDate() {
    	LocalDate endDate = LocalDate.of(2016, 1, 1);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), null, null, endDate, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("01 Jan 2016", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddDeadlineWithDateTime() {
    	LocalDate endDate = LocalDate.of(2016, 1, 1);
    	LocalTime endTime = LocalTime.of(10, 00);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), null, null, endDate, endTime);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("01 Jan 2016", task.getEndDateString());
        assertEquals("10:00AM", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddEventWithStartDate() {
    	LocalDate startDate = LocalDate.of(2016, 1, 1);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), startDate, null, null, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("01 Jan 2016", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddEventWithStartDateTime() {
    	LocalDate startDate = LocalDate.of(2016, 1, 1);
    	LocalTime startTime = LocalTime.of(10, 00);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), startDate, startTime, null, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("01 Jan 2016", task.getStartDateString());
        assertEquals("10:00AM", task.getStartTimeString());
        assertEquals("", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddEventWithStartDateEndDate() {
    	LocalDate startDate = LocalDate.of(2016, 1, 1);
    	LocalDate endDate = LocalDate.of(2016, 2, 2);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), startDate, null, endDate, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("01 Jan 2016", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("02 Feb 2016", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddEventWithStartDateTimeEndDateTime() {
    	LocalDate startDate = LocalDate.of(2016, 1, 1);
    	LocalTime startTime = LocalTime.of(10, 00);
    	LocalDate endDate = LocalDate.of(2016, 2, 2);
    	LocalTime endTime = LocalTime.of(11, 00);
    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), startDate, startTime, endDate, endTime);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("01 Jan 2016", task.getStartDateString());
        assertEquals("10:00AM", task.getStartTimeString());
        assertEquals("02 Feb 2016", task.getEndDateString());
        assertEquals("11:00AM", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(true, task.getTagsList().isEmpty());
    }

    @Test
    public void testAddTaskWithTag() {
    	ArrayList<String> tags = new ArrayList<>();
    	tags.add("#project");
    	TaskParameters task = new TaskParameters("transfer task to harddisk", tags, null, null, null, null);
        addCommandTest = new AddCommand(task);
        
        logic.logicTestEnvironment(addCommandTest);

        task = logic.getViewList().get(0);
        assertEquals("transfer task to harddisk", task.getDescription());
        assertEquals("", task.getStartDateString());
        assertEquals("", task.getStartTimeString());
        assertEquals("", task.getEndDateString());
        assertEquals("", task.getEndTimeString());
        assertEquals(false , task.getIsDone());
        assertEquals(false, task.getTagsList().isEmpty());
        assertEquals("#project", task.getTagsList().get(0));
    }
}
```
###### \ArchPlanner\test\logic\LogicDeleteCommandTest.java
``` java
 *
 */
public class LogicDeleteCommandTest {

	 private Logic logic;

	    private CommandInterface deleteCommandTest;


	    @Before
	    public void setUp() throws Exception {
	        logic = new Logic();
	        tearDown();
	    }

	    @After
	    public void tearDown() throws Exception {
	        logic.getMainList().clear();
	        logic.getViewList().clear();
	    }

	    @Test
	    public void testDeleteOneTask() {
	    	
	    	addOneTask();
	    	assertEquals(1, logic.getViewList().size());
	    	
	    	deleteCommandTest = new DeleteCommand(1);
	        logic.logicTestEnvironment(deleteCommandTest);

	        assertEquals(0, logic.getViewList().size());
	    }
	    
	    @Test
	    public void testDeleteMultipleTask() {
	    	
	    	addOneTask();
	    	addOneTask();
	    	addOneTask();
	    	assertEquals(3, logic.getViewList().size());
	    	
	    	deleteCommandTest = new DeleteCommand(1, 3);
	        logic.logicTestEnvironment(deleteCommandTest);

	        assertEquals(0, logic.getViewList().size());
	    }
	    
	    public void addOneTask() {
	    	
	    	TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), null, null, null, null);
	    	AddCommand addCommand = new AddCommand(task);
	        
	        logic.logicTestEnvironment(addCommand);
	    }
}
```
###### \ArchPlanner\test\logic\LogicDoneCommandTest.java
``` java
 *
 */
public class LogicDoneCommandTest {

	private Logic logic;

	private CommandInterface doneCommandTest;


	@Before
	public void setUp() throws Exception {
		logic = new Logic();
		tearDown();
	}

	@After
	public void tearDown() throws Exception {
		logic.getMainList().clear();
		logic.getViewList().clear();
	}

	@Test
	public void testDoneOneTask() {

		addOneTask();
		
		assertEquals(1, logic.getViewList().size());
		Task oldTask1 = logic.getViewList().get(0);
		assertEquals(false, oldTask1.getIsDone());

		doneCommandTest = new DoneCommand(1);
		logic.logicTestEnvironment(doneCommandTest);

		Task newTask1 = logic.getViewList().get(0);
		assertEquals(true, newTask1.getIsDone());
	}

	@Test
	public void testDoneMultipleTask() {

		addOneTask();
		addOneTask();
		addOneTask();
		
		assertEquals(3, logic.getViewList().size());
		Task oldTask1 = logic.getViewList().get(0);
		Task oldTask2 = logic.getViewList().get(1);
		Task oldTask3 = logic.getViewList().get(2);
		assertEquals(false, oldTask1.getIsDone());
		assertEquals(false, oldTask2.getIsDone());
		assertEquals(false, oldTask3.getIsDone());

		doneCommandTest = new DoneCommand(1, 3);
		logic.logicTestEnvironment(doneCommandTest);

		Task newTask1 = logic.getViewList().get(0);
		Task newTask2 = logic.getViewList().get(1);
		Task newTask3 = logic.getViewList().get(2);
		assertEquals(true, newTask1.getIsDone());
		assertEquals(true, newTask2.getIsDone());
		assertEquals(true, newTask3.getIsDone());
	}

	public void addOneTask() {

		TaskParameters task = new TaskParameters("transfer task to harddisk", new ArrayList<String>(), null, null, null, null);
		AddCommand addCommand = new AddCommand(task);

		logic.logicTestEnvironment(addCommand);
	}

}
```
###### \ArchPlanner\test\logic\LogicEditCommandTest.java
``` java
 *
 */
public class LogicEditCommandTest {

	private Logic logic;

	private CommandInterface editCommandTest;


	@Before
	public void setUp() throws Exception {
		logic = new Logic();
		tearDown();
	}

	@After
	public void tearDown() throws Exception {
		logic.getMainList().clear();
		logic.getViewList().clear();
	}

	@Test
	public void testEditCommandTaskDescription() {

		addEventTaskWithStartDateTimeEndDateTimeAndTag();

		TaskParameters taskParameters = new TaskParameters();
		taskParameters.setDescription("work on proposal");
		editCommandTest = new EditCommand(1, taskParameters);

		logic.logicTestEnvironment(editCommandTest);

		assertEquals("work on proposal", logic.getViewList().get(0).getDescription());
	}

	@Test
	public void testEditCommandTaskStartDateTime() {

		LocalDate startDate = LocalDate.of(2016, 1, 10);
		LocalTime startTime = LocalTime.of(9, 00);
		addEventTaskWithStartDateTimeEndDateTimeAndTag();

		TaskParameters taskParameters = new TaskParameters();
		taskParameters.setStartDate(startDate);
		taskParameters.setStartTime(startTime);
		editCommandTest = new EditCommand(1, taskParameters);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("10 Jan 2016", task.getStartDateString());
		assertEquals("9:00AM", task.getStartTimeString());
		assertEquals("02 Feb 2016", task.getEndDateString());
		assertEquals("11:00AM", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals("#project", task.getTagsList().get(0));
	}

	@Test
	public void testEditCommandTaskEndDateTime() {

		LocalDate endDate = LocalDate.of(2016, 1, 10);
		LocalTime endTime = LocalTime.of(9, 00);
		addEventTaskWithStartDateTimeEndDateTimeAndTag();

		TaskParameters taskParameters = new TaskParameters();
		taskParameters.setEndDate(endDate);
		taskParameters.setEndTime(endTime);
		editCommandTest = new EditCommand(1, taskParameters);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("01 Jan 2016", task.getStartDateString());
		assertEquals("10:00AM", task.getStartTimeString());
		assertEquals("10 Jan 2016", task.getEndDateString());
		assertEquals("9:00AM", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals("#project", task.getTagsList().get(0));
	}
	
	@Test
	public void testEditCommandTaskTags() {

		addEventTaskWithStartDateTimeEndDateTimeAndTag();
		
		ArrayList<String> tags = new ArrayList<String>();
		tags.add("#work");
		
		TaskParameters taskParameters = new TaskParameters();
		taskParameters.setTagsList(tags);
		editCommandTest = new EditCommand(1, taskParameters);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("01 Jan 2016", task.getStartDateString());
		assertEquals("10:00AM", task.getStartTimeString());
		assertEquals("02 Feb 2016", task.getEndDateString());
		assertEquals("11:00AM", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals("#work", task.getTagsList().get(0));
	}
	
	@Test
	public void testEditCommandRemoveStartDateTime() {

		addEventTaskWithStartDateTimeEndDateTimeAndTag();
		
		TaskParameters taskParameters = new TaskParameters();
		editCommandTest = new EditCommand(1, taskParameters, REMOVE_TYPE.START);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("", task.getStartDateString());
		assertEquals("", task.getStartTimeString());
		assertEquals("02 Feb 2016", task.getEndDateString());
		assertEquals("11:00AM", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals("#project", task.getTagsList().get(0));
	}

	@Test
	public void testEditCommandRemoveEndDateTime() {

		addEventTaskWithStartDateTimeEndDateTimeAndTag();
		
		TaskParameters taskParameters = new TaskParameters();
		editCommandTest = new EditCommand(1, taskParameters, REMOVE_TYPE.END);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("01 Jan 2016", task.getStartDateString());
		assertEquals("10:00AM", task.getStartTimeString());
		assertEquals("", task.getEndDateString());
		assertEquals("", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals("#project", task.getTagsList().get(0));
	}
	
	@Test
	public void testEditCommandRemoveTag() {

		addEventTaskWithStartDateTimeEndDateTimeAndTag();
		
		TaskParameters taskParameters = new TaskParameters();
		editCommandTest = new EditCommand(1, taskParameters, REMOVE_TYPE.TAG);

		logic.logicTestEnvironment(editCommandTest);

		Task task = logic.getViewList().get(0);

		assertEquals("transfer task to harddisk", task.getDescription());
		assertEquals("01 Jan 2016", task.getStartDateString());
		assertEquals("10:00AM", task.getStartTimeString());
		assertEquals("02 Feb 2016", task.getEndDateString());
		assertEquals("11:00AM", task.getEndTimeString());
		assertEquals(false , task.getIsDone());
		assertEquals(0, task.getTagsList().size());
	}

	@Test
	public void testEditCommandInvalidStartDate() {
		LocalDate startDate = LocalDate.of(2016, 3, 1);
		addEventTaskWithStartDateTimeEndDateTimeAndTag();
		
		TaskParameters taskParameters = new TaskParameters();
		taskParameters.setStartDate(startDate);
		editCommandTest = new EditCommand(1, taskParameters, REMOVE_TYPE.END);

		CommandInterface commandExecuted = logic.logicTestEnvironment(editCommandTest);
		String invalidMessage = commandExecuted.getMessage();

		assertEquals("Invalid start date", invalidMessage);
	}

	public void addEventTaskWithStartDateTimeEndDateTimeAndTag() {
		ArrayList<String> tags = new ArrayList<String>();
		tags.add("#project");
		LocalDate startDate = LocalDate.of(2016, 1, 1);
		LocalTime startTime = LocalTime.of(10, 00);
		LocalDate endDate = LocalDate.of(2016, 2, 2);
		LocalTime endTime = LocalTime.of(11, 00);
		TaskParameters task = new TaskParameters("transfer task to harddisk", tags, startDate, startTime, endDate, endTime);
		AddCommand addCommandTest = new AddCommand(task);

		logic.logicTestEnvironment(addCommandTest);
	}
}
```
