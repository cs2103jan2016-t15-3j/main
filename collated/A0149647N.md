# A0149647N
###### \ArchPlanner\interpreter\parser\AddCommandParser.java
``` java
 * AddCommandParser parse add command with AddInputSeparator
 */
public class AddCommandParser {

    private static final int ADD_PARAMETER_INDEX = 4;
    private static final String INVALID_TIME = "Invalid Time!";
    private static final String INVALID_RANGE = "Invalid Time Range!";
    private static final String INVALID_TAG = "Invalid Tags";
    private static final String INVALID_EMPTY = "Invalid empty command";
    private static final String TAG_NOTATION = "#";

    private TaskParameters result = new TaskParameters();

    /**
     * Parse add command with AddInputSeparator
     * @param input user's command
     * @return Parsed command object
     */
    public CommandInterface parse(String input) {
        if (input.length() <= ADD_PARAMETER_INDEX) {
            return new InvalidCommand(INVALID_EMPTY);
        }
        AddInputSeparater addInputSeparator = new AddInputSeparater(input.substring(ADD_PARAMETER_INDEX));
        if (!addInputSeparator.hasDescription()) {
            return new InvalidCommand(INVALID_EMPTY);
        }
        result.setDescription(addInputSeparator.getDescription());
        TimeParserResult timeParserResult = getDateTime(addInputSeparator);
        result.setStartDate(timeParserResult.getFirstDate());
        result.setStartTime(timeParserResult.getFirstTime());
        result.setEndDate(timeParserResult.getSecondDate());
        result.setEndTime(timeParserResult.getSecondTime());
        result.setTagsList(new ArrayList<>());
        if (!timeParserResult.isTimeValid()) {
            return new InvalidCommand(INVALID_RANGE);
        }
        if (!checkTimeValidWithKeyword(addInputSeparator.getKeyWord(), timeParserResult)) {
            return new InvalidCommand(INVALID_TIME);
        }
        if (addInputSeparator.hasValidTag()) {
            if (addInputSeparator.getTags()[addInputSeparator.getTags().length - 1].equals(TAG_NOTATION)) {
                return new InvalidCommand(INVALID_TAG);
            } else {
                ArrayList<String> arrayList = new ArrayList<>();
                Collections.addAll(arrayList, addInputSeparator.getTags());
                result.setTagsList(arrayList);
            }
        } else if (addInputSeparator.hasTag()) {
            return new InvalidCommand(INVALID_TAG);
        }
        return new AddCommand(result);
    }

    /**
     * Get date and time from AddInputSeparator and return a TimeParserResult object
     * This method also update data for some default values
     * @param addInputSeparator The separator which contains initial data
     * @return Reformed TimeParserResult object
     */
    private TimeParserResult getDateTime(AddInputSeparater addInputSeparator) {
        TimeParserResult timeParserResult = new TimeParserResult();
        if (addInputSeparator.hasStartDate()) {
            timeParserResult.setFirstDate(addInputSeparator.getStartDate());
        }
        if (addInputSeparator.hasStartTime()) {
            timeParserResult.setFirstTime(addInputSeparator.getStartTime());
        }
        if (addInputSeparator.hasEndDate()) {
            timeParserResult.setSecondDate(addInputSeparator.getEndDate());
        }
        if (addInputSeparator.hasEndTime()) {
            timeParserResult.setSecondTime(addInputSeparator.getEndTime());
        }
        timeParserResult.updateDateTime();
        if (timeParserResult.getFirstTime() != null && timeParserResult.getFirstDate() == null) {
            timeParserResult.setFirstDate(LocalDate.now());
        }
        if (timeParserResult.getSecondTime() != null && timeParserResult.getSecondDate() == null) {
            timeParserResult.setSecondDate(LocalDate.now());
        }
        timeParserResult.checkInvalidTimeRange();
        return timeParserResult;
    }

    /**
     * check if the time is valid for the keyword
     * @param keyword This is the keyword
     * @param timeParserResult This contains all the date and time date
     * @return true if valid, else false
     */
    private boolean checkTimeValidWithKeyword(AddInputSeparater.AddKeyWordType keyword, TimeParserResult timeParserResult) {
        if (keyword == null) {
            return true;
        }
        switch (keyword) {
            case UNKNOWN:
                return true;
            case ON:
                if (timeParserResult.getFirstDate() == null || timeParserResult.getSecondDate() != null) {
                    return false;
                }
                break;
            case BY:
                if (timeParserResult.getFirstDate() != null || timeParserResult.getSecondDate() == null) {
                    return false;
                }
                break;
            case FROM:
                if (timeParserResult.getFirstDate() == null || timeParserResult.getSecondDate() == null) {
                    return false;
                }
                break;
            default:
                break;
        }
        return true;
    }

}
```
###### \ArchPlanner\interpreter\parser\DeleteCommandParser.java
``` java
 * DeleteCommandParser parse delete command with InputSeparator
 */
public class DeleteCommandParser {

    private static final String INVALID_ID = "Invalid: ID not found";
    private static final String INVALID_COMMAND = "Delete command is invalid!";
    private static final String INVALID_OUT_OF_RANGE = "Delete index out of range!";

    /**
     * Parse delete command with InputSeparator
     * @param input User's input
     * @param viewListSize Current view list's size
     * @return Parsed command object
     */
    public CommandInterface parse(String input, int viewListSize) {
        InputSeparater separator = new InputSeparater(input);
        if (separator.getID() == null) {
            return new InvalidCommand(INVALID_ID);
        }
        if (separator.isIdOnly()) {
            if (separator.isIdRangeValid(separator.getID(), viewListSize)) {
                return new DeleteCommand(separator.getID());
            } else {
                return new InvalidCommand(INVALID_OUT_OF_RANGE);
            }
        }
        if (separator.hasTwoValidId(viewListSize)) {
            return new DeleteCommand(separator.getID(), separator.getSecondId());
        }
        if (!separator.isIdRangeValid(separator.getSecondId(), viewListSize)) {
            return new InvalidCommand(INVALID_OUT_OF_RANGE);
        }
        return new InvalidCommand(INVALID_COMMAND);
    }
}
```
###### \ArchPlanner\interpreter\parser\DoneCommandParser.java
``` java
 * DoneCommandParser parse done command with InputSeparator
 */
public class DoneCommandParser {

    private static final String INVALID_ID = "Invalid: ID not found";
    private static final String INVALID_COMMAND = "Done command is invalid!";
    private static final String INVALID_OUT_OF_RANGE = "Done index out of range!";

    /**
     * Parse delete command with InputSeparator
     * @param input User's input
     * @param viewListSize Current view list's size
     * @return Parsed command object
     */
    public CommandInterface parse(String input, int viewListSize) {
        InputSeparater separator = new InputSeparater(input);
        if (separator.getID() == null) {
            return new InvalidCommand(INVALID_ID);
        }
        if (separator.isIdOnly()) {
            if (separator.isIdRangeValid(separator.getID(), viewListSize)) {
                return new DoneCommand(separator.getID());
            } else {
                return new InvalidCommand(INVALID_OUT_OF_RANGE);
            }
        }
        if (separator.hasTwoValidId(viewListSize)) {
            return new DoneCommand(separator.getID(), separator.getSecondId());
        }
        if (!separator.isIdRangeValid(separator.getSecondId(), viewListSize)) {
            return new InvalidCommand(INVALID_OUT_OF_RANGE);
        }
        return new InvalidCommand(INVALID_COMMAND);
    }
}
```
###### \ArchPlanner\interpreter\parser\EditCommandParser.java
``` java
 * EditCommandParser parse edit command with InputSeparator
 */
public class EditCommandParser {

    private static final String INVALID_NO_ID = "Index not found!";
    private static final String INVALID_ID_OUT_OF_RANGE = "Index out of range";
    private static final String INVALID_NO_KEYWORD = "Keyword not found!";
    private static final String INVALID_KEYWORD = "Keyword Invalid!";
    private static final String INVALID_ARGUMENT_MISSING = "Argument Missing";
    private static final String INVALID_DATE_TIME = "Invalid date or time";
    private static final String INVALID_START_DATE_TIME = "Invalid start date or time";
    private static final String INVALID_END_DATE_TIME = "Invalid end date or time";
    private static final String INVALID_TIME_RANGE = "Invalid: Start time is after end time";
    private static final String INVALID_COMMAND = "Invalid Command";

    private static final String REMOVE = "remove";
    private static final String START_REMOVE = "start remove";
    private static final String END_REMOVE = "end remove";
    private static final String TAG_NOTATION = "#";
    private static final String TAG_REMOVE = "# remove";
    private static final String INVALID_TAG_EMPTY = "Empty Tag is not allowed";
    private static final String INVALID_TAG_NO_PREFIX = "Tag requires \"#\" prefix";
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final int FIRST_INDEX = 1;

    private TaskParameters result = new TaskParameters();

    /**
     * Parse edit command with InputSeparator
     * @param input User's input
     * @param viewListSize Current view list's size
     * @return Parsed command object
     */
    public CommandInterface parse(String input, int viewListSize) {
        InputSeparater inputSeparator = new InputSeparater(input);
        Integer index = inputSeparator.getID();
        InputSeparater.KeywordType type = inputSeparator.getKeywordType();
        String parameter = inputSeparator.getParameter();

        if (index == null) {
            return new InvalidCommand(INVALID_NO_ID);
        }
        if (index < FIRST_INDEX || index > viewListSize) {
            return new InvalidCommand(INVALID_ID_OUT_OF_RANGE);
        }
        if (type == null) {
            return parserNoKeywordCase(parameter, index);
        }
        if (parameter == null) {
            return new InvalidCommand(INVALID_ARGUMENT_MISSING);
        } else {
            return parserKeywordWithParameter(parameter, index, type);
        }
    }

    /**
     * Parse user input which doesn't have keyword
     * The input is editing tags or the input is invalid
     * @param parameter This is the parameter
     * @param index This is the index to edit
     * @return Parsed result
     */
    private CommandInterface parserNoKeywordCase(String parameter, Integer index) {
        if (parameter == null) {
            return new InvalidCommand(INVALID_NO_KEYWORD);
        } else if (parameter.startsWith(TAG_NOTATION)) {
            return parseTag(parameter, index);
        } else {
            return new InvalidCommand(INVALID_KEYWORD);
        }
    }

    /**
     * Parse the tag string to tag ArrayList
     * This method may return EditCommand with tags or InvalidCommand
     * @param parameter This is the parameter
     * @param index This is the index to edit
     * @return Parsed result
     */
    private CommandInterface parseTag(String parameter, Integer index){
        if (parameter.equalsIgnoreCase(TAG_REMOVE)) {
            return new EditCommand(index, result, EditCommand.REMOVE_TYPE.TAG);
        }
        ArrayList<String> tagList = new ArrayList<>();
        String[] tags = parameter.split(STRING_MULTIPLE_WHITESPACE);
        for (String tag : tags) {
            if (tag.startsWith(TAG_NOTATION)) {
                if (tag.length() > 1) {
                    tagList.add(tag);
                } else {
                    return new InvalidCommand(INVALID_TAG_EMPTY);
                }
            } else {
                return new InvalidCommand(INVALID_TAG_NO_PREFIX);
            }
        }
        result.setTagsList(tagList);
        return new EditCommand(index, result);
    }

    /**
     * Parse edit command with keyword and its parameter
     * There are four possible case: view description, view start, view end and view from
     * @param parameter This is the parameter of the keyword
     * @param index This is the index to edit
     * @param type This is the keyword type
     * @return Parsed result
     */
    private CommandInterface parserKeywordWithParameter(String parameter, Integer index, InputSeparater.KeywordType type) {
        TimeParserResult timeParserResult = new TimeParser().parseTime(parameter);
        boolean timeInvalid = timeParserResult.getMatchString() == null || !timeParserResult.getMatchString().equals(parameter);
        boolean isRemove = parameter.equalsIgnoreCase(REMOVE);
        switch (type) {
            case DESCRIPTION:
                result.setDescription(parameter);
                return new EditCommand(index, result);
            case START:
                return parseStart(isRemove, timeInvalid, index, timeParserResult);
            case END:
                return parseEnd(isRemove, timeInvalid, index, timeParserResult);
            case FROM:
                return parseFrom(timeInvalid, index, timeParserResult);
            default:
                break;
        }
        if (parameter.equalsIgnoreCase(START_REMOVE)) {
            return new EditCommand(index, result, EditCommand.REMOVE_TYPE.START);
        }
        if (parameter.equalsIgnoreCase(END_REMOVE)) {
            return new EditCommand(index, result, EditCommand.REMOVE_TYPE.END);
        }
        return new InvalidCommand(INVALID_COMMAND);
    }

    /**
     * Parse "view start" command.
     * May return parsed EditCommand or InvalidCommand
     * @param isRemove True if the command is to remove start date and time
     * @param timeInvalid True if time is invalid
     * @param index This is the index to edit
     * @param timeParserResult This is the parsed time object
     * @return Parsed result
     */
    private CommandInterface parseStart(boolean isRemove, boolean timeInvalid, Integer index, TimeParserResult timeParserResult) {
        if (isRemove) {
            return new EditCommand(index, result, EditCommand.REMOVE_TYPE.START);
        }
        if (timeInvalid) {
            return new InvalidCommand(INVALID_START_DATE_TIME);
        }

        switch (timeParserResult.getDateTimeStatus()) {
            case START_TIME:
                result.setStartTime(timeParserResult.getFirstTime());
                return new EditCommand(index, result);
            case START_DATE:
                result.setStartDate(timeParserResult.getFirstDate());
                return new EditCommand(index, result);
            case START_DATE_START_TIME:
                result.setStartDate(timeParserResult.getFirstDate());
                result.setStartTime(timeParserResult.getFirstTime());
                return new EditCommand(index, result);
            default:
                return new InvalidCommand(INVALID_START_DATE_TIME);
        }
    }

    /**
     * Parse "view end" command.
     * May return parsed EditCommand or InvalidCommand
     * @param isRemove True if the command is to remove end date and time
     * @param timeInvalid True if time is invalid
     * @param index This is the index to edit
     * @param timeParserResult This is the parsed time object
     * @return Parsed result
     */
    private CommandInterface parseEnd(boolean isRemove, boolean timeInvalid, Integer index, TimeParserResult timeParserResult) {
        if (isRemove) {
            return new EditCommand(index, result, EditCommand.REMOVE_TYPE.END);
        }
        if (timeInvalid) {
            return new InvalidCommand(INVALID_END_DATE_TIME);
        }
        switch (timeParserResult.getDateTimeStatus()) {
            case START_TIME:
                result.setEndTime(timeParserResult.getFirstTime());
                return new EditCommand(index, result);
            case START_DATE:
                result.setEndDate(timeParserResult.getFirstDate());
                return new EditCommand(index, result);
            case START_DATE_START_TIME:
                result.setEndDate(timeParserResult.getFirstDate());
                result.setEndTime(timeParserResult.getFirstTime());
                return new EditCommand(index, result);
            default:
                return new InvalidCommand(INVALID_END_DATE_TIME);
        }
    }

    /**
     * Parse "view from" command.
     * May return parsed EditCommand or InvalidCommand
     * @param timeInvalid True if time is invalid
     * @param index This is the index to edit
     * @param timeParserResult This is the parsed time object
     * @return Parsed result
     */
    private CommandInterface parseFrom(boolean timeInvalid, Integer index, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_DATE_TIME);
        }
        if (!timeParserResult.isTimeValid()) {
            return new InvalidCommand(INVALID_TIME_RANGE);
        }
        switch (timeParserResult.getDateTimeStatus()) {
            case START_TIME_END_TIME:
                result.setStartTime(timeParserResult.getFirstTime());
                result.setEndTime(timeParserResult.getSecondTime());
                return new EditCommand(index, result);
            case START_DATE_END_DATE:
                result.setStartDate(timeParserResult.getFirstDate());
                result.setEndDate(timeParserResult.getSecondDate());
                return new EditCommand(index, result);
            case START_DATE_START_TIME_END_DATE_END_TIME:
                result.setStartDate(timeParserResult.getFirstDate());
                result.setStartTime(timeParserResult.getFirstTime());
                result.setEndDate(timeParserResult.getSecondDate());
                result.setEndTime(timeParserResult.getSecondTime());
                return new EditCommand(index, result);
            default:
                return new InvalidCommand(INVALID_DATE_TIME);
        }
    }
}
```
###### \ArchPlanner\interpreter\parser\Parser.java
``` java
 * Parser receives user input and dispatch it to specific parser to parse it.
 */
public class Parser {

    enum CommandType {
        ADD, DELETE, EDIT, VIEW, DONE, UNDONE, UNDO, REDO, EXIT, UNKNOWN, SET
    }

    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final String NATTY_INIT = "today";
    private static final int INITIAL_INDEX = 0;
    private static final String INVALID_NULL = "Null input";
    private static final String INVALID_COMMAND = "Invalid command";
    private static final String INVALID_UNDO_LIST_SIZE = "Can't undo anymore";
    private static final String INVALID_UNDO_LENGTH = "Invalid undo: too many arguments";
    private static final String INVALID_REDO_LIST_SIZE = "Can't redo anymore";
    private static final String INVALID_REDO_LENGTH = "Invalid redo: too many arguments";
    private static final String INVALID_FAILED = "Failed to parse";

    public Parser() {
        init();
    }

    /**
     * Initialization start a new thread calling Natty at beginning to avoid lag of Natty initialization
     */
    public static void init() {

        new Thread(() -> {
            new com.joestelmach.natty.Parser().parse(NATTY_INIT);
        }).start();
    }

    /**
     * This method is used to parse user input into command object.
     *
     * @param input The user's input.
     * @return parsed command. If input is invalid, will return InvalidCommand
     */
    public CommandInterface parseCommand(String input, int viewListSize, int undoListSize, int redoListSize, ArrayList<Tag> tagList) {
        if (input == null) {
            return new InvalidCommand(INVALID_NULL);
        }
        CommandType commandType = determineCommandType(input);
        switch (commandType) {
            case UNKNOWN:
                return new InvalidCommand(INVALID_COMMAND);
            case ADD:
                return new AddCommandParser().parse(input);
            case DELETE:
                return new DeleteCommandParser().parse(input, viewListSize);
            case EDIT:
                return new EditCommandParser().parse(input, viewListSize);
            case VIEW:
                return new ViewCommandParser().parse(input, tagList);
            case DONE:
                return new DoneCommandParser().parse(input, viewListSize);
            case UNDONE:
                return new UndoneCommandParser().parse(input, viewListSize);
            case UNDO:
                return parseUndoCommand(input, undoListSize);
            case REDO:
                return parseRedoCommand(input, redoListSize);
            case EXIT:
                return new ExitCommand();
            case SET:
                return new SetCommandParser().parse(input);
        }
        return new InvalidCommand(INVALID_FAILED);
    }

    /**
     * Parse undo command.
     * May return UndoCommand or InvalidCommand
     * @param input This is user's command
     * @param undoListSize This is the size of current list
     * @return Parsed result
     */
    private CommandInterface parseUndoCommand(String input, int undoListSize) {
        if (input.split(STRING_MULTIPLE_WHITESPACE).length != 1) {
            return new InvalidCommand(INVALID_UNDO_LENGTH);
        } else if (undoListSize <= 0) {
            return new InvalidCommand(INVALID_UNDO_LIST_SIZE);
        } else {
            return new UndoCommand();
        }
    }

    /**
     * Parse redo command.
     * May return RedoCommand or InvalidCommand
     * @param input This is user's command
     * @param redoListSize This is the size of current list
     * @return Parsed result
     */
    private CommandInterface parseRedoCommand(String input, int redoListSize) {
        if (input.split(STRING_MULTIPLE_WHITESPACE).length != 1) {
            return new InvalidCommand(INVALID_REDO_LENGTH);
        } else if (redoListSize <= 0) {
            return new InvalidCommand(INVALID_REDO_LIST_SIZE);
        } else {
            return new RedoCommand();
        }
    }

    /**
     * Determine the command type of user's input
     * @param input This is user's command
     * @return Recognized command type
     */
    private CommandType determineCommandType(String input) {
        String commandTypeString = getFirstWord(input);
        if (commandTypeString.isEmpty()) {
            return CommandType.UNKNOWN;
        }
        for (CommandType type : CommandType.values()) {
            if (commandTypeString.equalsIgnoreCase(type.name())) {
                return type;
            }
        }
        return CommandType.UNKNOWN;
    }

    /**
     * Get the first word of a string
     * @param input This is the initial string
     * @return The first word of the string
     */
    private String getFirstWord(String input) {
        return input.trim().split(STRING_MULTIPLE_WHITESPACE)[INITIAL_INDEX];
    }

}
```
###### \ArchPlanner\interpreter\parser\SetCommandParser.java
``` java
 * SetCommandParser parse delete command with InputSeparator
 */
public class SetCommandParser {

    private static final String DEFAULT = "default";
    private static final String INVALID_PATH_MISSING = "Path missing!";
    private static final String INVALID_COMMAND = "Set command Invalid";

    /**
     * Parse set command with InputSeparator
     * @return Parsed command object
     */
    public CommandInterface parse(String input) {
        InputSeparater separator = new InputSeparater(input);
        if (isValidCommand(separator)) {
            if (separator.getParameter() == null) {
                return new InvalidCommand(INVALID_PATH_MISSING);
            } else if (DEFAULT.equals(separator.getParameter().toLowerCase())) {
                return new SetCommand(null);
            } else {
                return new SetCommand(separator.getParameter());
            }
        }
        return new InvalidCommand(INVALID_COMMAND);
    }

    /**
     * Check if the set command is valid
     * The set command is valid if it doesn't have ID and the keyword if FILEPATH
     * @param separator This is the InputSeparator object which contains parsed result
     * @return True if the command is valid
     */
    private boolean isValidCommand(InputSeparater separator) {
        boolean noId = separator.getID() == null;
        boolean validKeyword = separator.getKeywordType() != null && separator.getKeywordType() == InputSeparater.KeywordType.FILEPATH;
        return noId && validKeyword;
    }
}
```
###### \ArchPlanner\interpreter\parser\time\TimeParser.java
``` java
 * TimeParser parse time with Natty and return a TimeParserResult object.
 */
public class TimeParser {

    private static final String NATTY_DATE_TIME = "DATE_TIME";
    private static final String NATTY_RELATIVE_DATE = "RELATIVE_DATE";
    private static final String NATTY_EXPLICIT_DATE = "EXPLICIT_DATE";
    private static final String NATTY_RELATIVE_TIME = "RELATIVE_TIME";
    private static final String NATTY_EXPLICIT_TIME = "EXPLICIT_TIME";
    private static final int NO_DATE_TIME = 0;
    private static final int ONE_DATE_TIME = 1;
    private static final int TWO_DATE_TIME = 2;
    private static final int FIRST_DATE_INDEX = 0;
    private static final int SECOND_DATE_INDEX = 1;


    private static Parser timeParser = new Parser();
    private TimeParserResult timeParserResult = new TimeParserResult();
    private int dateTimeCount;

    /**
     * Parse time string with Natty and return a TimeParserResult object
     */
    public TimeParserResult parseTime(String input) {

        if (input == null) {
            return timeParserResult;
        }
        List<DateGroup> groups = timeParser.parse(input);
        for (DateGroup group : groups){
            if (dateTimeCount > NO_DATE_TIME) {
                break;
            }
            List<Date> dates = group.getDates();
            Tree tree = group.getSyntaxTree();
            postTraverseSyntaxTree(tree, dates);
            timeParserResult.setMatchString(group.getText());
        }
        timeParserResult.updateDateTime();
        timeParserResult.checkInvalidTimeRange();
        return timeParserResult;
    }

    /**
     * Recursively post traverse the syntax tree.
     * Retrieve the recognized date and time and its position in the syntax tree.
     * It's used to figure a date/time as start date/time or end date/time.
     * @param node the current traversed tree node
     * @param dates the recognized date list
     */
    private void postTraverseSyntaxTree(Tree node, List<Date> dates) {
        if (node.getText().equals(NATTY_DATE_TIME)){
            dateTimeCount++;
        }
        if (node.getText().equals(NATTY_RELATIVE_DATE) || node.getText().equals(NATTY_EXPLICIT_DATE)) {
            if (dateTimeCount == ONE_DATE_TIME) {
                timeParserResult.setFirstDate(dates.get(FIRST_DATE_INDEX));
            } else if (dateTimeCount == TWO_DATE_TIME) {
                timeParserResult.setSecondDate(dates.get(SECOND_DATE_INDEX));
            }
        } else if (node.getText().equals(NATTY_RELATIVE_TIME) || node.getText().equals(NATTY_EXPLICIT_TIME)) {
            if (dateTimeCount == ONE_DATE_TIME) {
                timeParserResult.setFirstTime(dates.get(FIRST_DATE_INDEX));
            } else if (dateTimeCount == TWO_DATE_TIME) {
                timeParserResult.setSecondTime(dates.get(SECOND_DATE_INDEX));
            }
        }
        for (int i = 0; i < node.getChildCount(); i++) {
            postTraverseSyntaxTree(node.getChild(i), dates);
        }
    }
}
```
###### \ArchPlanner\interpreter\parser\time\TimeParserResult.java
``` java
 * TimeParserResult hold the result after parse time with Natty.
 * TimeParserResult also check the time and update it according to the rule.
 */
public class TimeParserResult {

    private static final int FIRST_HOUR_OF_DAY = 0;
    private static final int FIRST_MINUTE_OF_HOUR = 0;
    private static final int FIRST_SECOND_OF_MINUTE = 0;
    private static final int LAST_HOUR_OF_DAY = 23;
    private static final int LAST_MINUTE_OF_HOUR = 59;
    private static final int LAST_SECOND_OF_MINUTE = 59;

    private String matchString;
    private LocalDate firstDate;
    private LocalDate secondDate;
    private LocalTime firstTime;
    private LocalTime secondTime;
    private boolean timeValid;
    private DateTimeStatus rawDateTimeStatus = DateTimeStatus.NONE;

    /**
     * 16 enum to represent all possible recognized time type
     */
    public enum DateTimeStatus {
        NONE, END_TIME, END_DATE, END_DATE_END_TIME,
        START_TIME, START_TIME_END_TIME, START_TIME_END_DATE, START_TIME_END_DATE_END_TIME,
        START_DATE, START_DATE_END_TIME, START_DATE_END_DATE, START_DATE_END_DATE_END_TIME,
        START_DATE_START_TIME, START_DATE_START_TIME_END_TIME,
        START_DATE_START_TIME_END_DATE, START_DATE_START_TIME_END_DATE_END_TIME
    }

    /**
     * Check whether end time is after start time
     */
    public void checkInvalidTimeRange() {
        timeValid = true;
        DateTimeStatus status = getDateTimeStatus();
        switch (status) {
            case START_DATE_END_DATE:
                if (firstDate.isAfter(secondDate)) {
                    timeValid = false;
                }
                break;
            case START_DATE_START_TIME_END_DATE_END_TIME:
                if (firstDate.isAfter(secondDate)) {
                    timeValid = false;
                } else if (firstDate.isEqual(secondDate) && !firstTime.isBefore(secondTime)) {
                    timeValid = false;
                }
                break;
            default:
                break;
        }
    }

    /**
     * Update date and time with default setting
     * e.g. from today 1pm to 3pm. End date is initially null. The method will set end date as today.
     */
    public void updateDateTime() {
        rawDateTimeStatus = getDateTimeStatus();
        switch (rawDateTimeStatus) {
            case START_TIME_END_TIME:
                firstDate = LocalDate.now();
                secondDate = LocalDate.now();
                break;
            case START_TIME_END_DATE:
                firstDate = LocalDate.now();
                secondTime = LocalTime.of(LAST_HOUR_OF_DAY, LAST_MINUTE_OF_HOUR, LAST_SECOND_OF_MINUTE);
                break;
            case START_TIME_END_DATE_END_TIME:
                firstDate = LocalDate.now();
                break;
            case START_DATE_END_TIME:
                firstTime = LocalTime.of(FIRST_HOUR_OF_DAY, FIRST_MINUTE_OF_HOUR, FIRST_SECOND_OF_MINUTE);
                secondDate = LocalDate.now();
                break;
            case START_DATE_END_DATE_END_TIME:
                firstTime = LocalTime.of(FIRST_HOUR_OF_DAY, FIRST_MINUTE_OF_HOUR, FIRST_SECOND_OF_MINUTE);
                break;
            case START_DATE_START_TIME_END_TIME:
                secondDate = firstDate;
                break;
            case START_DATE_START_TIME_END_DATE:
                secondTime = LocalTime.of(LAST_HOUR_OF_DAY, LAST_MINUTE_OF_HOUR, LAST_SECOND_OF_MINUTE);
                break;
            default:
                break;
        }
    }

    /**
     * Cast the time result to an enum instance
     * This method is used to simplify further condition control
     */
    public DateTimeStatus getDateTimeStatus() {
        DateTimeStatus dateTimeStatus = DateTimeStatus.NONE;
        if (secondTime != null) {
            dateTimeStatus = DateTimeStatus.END_TIME;
        }
        if (secondDate != null) {
            switch (dateTimeStatus) {
                case NONE:
                    dateTimeStatus = DateTimeStatus.END_DATE;
                    break;
                case END_TIME:
                    dateTimeStatus = DateTimeStatus.END_DATE_END_TIME;
                    break;
                default:
                    break;
            }
        }
        if (firstTime != null) {
            switch (dateTimeStatus) {
                case NONE:
                    dateTimeStatus = DateTimeStatus.START_TIME;
                    break;
                case END_TIME:
                    dateTimeStatus = DateTimeStatus.START_TIME_END_TIME;
                    break;
                case END_DATE:
                    dateTimeStatus = DateTimeStatus.START_TIME_END_DATE;
                    break;
                case END_DATE_END_TIME:
                    dateTimeStatus = DateTimeStatus.START_TIME_END_DATE_END_TIME;
                    break;
                default:
                    break;
            }
        }
        if (firstDate != null) {
            switch (dateTimeStatus) {
                case NONE:
                    dateTimeStatus = DateTimeStatus.START_DATE;
                    break;
                case END_TIME:
                    dateTimeStatus = DateTimeStatus.START_DATE_END_TIME;
                    break;
                case END_DATE:
                    dateTimeStatus = DateTimeStatus.START_DATE_END_DATE;
                    break;
                case END_DATE_END_TIME:
                    dateTimeStatus = DateTimeStatus.START_DATE_END_DATE_END_TIME;
                    break;
                case START_TIME:
                    dateTimeStatus = DateTimeStatus.START_DATE_START_TIME;
                    break;
                case START_TIME_END_TIME:
                    dateTimeStatus = DateTimeStatus.START_DATE_START_TIME_END_TIME;
                    break;
                case START_TIME_END_DATE:
                    dateTimeStatus = DateTimeStatus.START_DATE_START_TIME_END_DATE;
                    break;
                case START_TIME_END_DATE_END_TIME:
                    dateTimeStatus = DateTimeStatus.START_DATE_START_TIME_END_DATE_END_TIME;
                    break;
                default:
                    break;
            }
        }
        return dateTimeStatus;
    }

    public DateTimeStatus getRawDateTimeStatus() {
        return rawDateTimeStatus;
    }

    public String getMatchString() {
        return matchString;
    }

    public void setMatchString(String matchString) {
        this.matchString = matchString;
    }

    public void setFirstDate(Date date) {
        firstDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }

    public void setSecondDate(Date date) {
        secondDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }

    public void setFirstTime(Date date) {
        firstTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
    }

    public void setSecondTime(Date date) {
        secondTime = date.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
    }

    public LocalDate getFirstDate() {
        return firstDate;
    }

    public LocalDate getSecondDate() {
        return secondDate;
    }

    public LocalTime getFirstTime() {
        return firstTime;
    }

    public LocalTime getSecondTime() {
        return secondTime;
    }

    public void setFirstDate(LocalDate firstDate) {
        this.firstDate = firstDate;
    }

    public void setSecondDate(LocalDate secondDate) {
        this.secondDate = secondDate;
    }

    public void setFirstTime(LocalTime firstTime) {
        this.firstTime = firstTime;
    }

    public void setSecondTime(LocalTime secondTime) {
        this.secondTime = secondTime;
    }

    public boolean isTimeValid() {
        return timeValid;
    }

    /**
     * True if the time result only have a time and no date
     */
    public boolean hasNoDateAndOneTime() {
        return firstDate == null && secondDate == null && firstTime != null && secondTime == null;
    }

    /**
     * True if the time result only have a date and no time
     */
    public boolean hasOneDateAndNoTime() {
        return firstDate != null && secondDate == null && firstTime == null && secondTime == null;
    }

    /**
     * True if the time result have two date and no time
     */
    public boolean hasTwoDateAndNoTime() {
        return firstDate != null && secondDate != null && firstTime == null && secondTime == null;
    }
}
```
###### \ArchPlanner\interpreter\parser\UndoneCommandParser.java
``` java
 * UndoneCommandParser parse undone command with InputSeparator
 */
public class UndoneCommandParser {

    private static final String INVALID_ID = "Invalid: ID not found";
    private static final String INVALID_COMMAND = "Undone command is invalid!";
    private static final String INVALID_OUT_OF_RANGE = "Undone index out of range!";

    /**
     * Parse delete command with InputSeparator
     * @param input User's input
     * @param viewListSize Current view list's size
     * @return Parsed command object
     */
    public CommandInterface parse(String input, int viewListSize) {
        InputSeparater separator = new InputSeparater(input);
        if (separator.getID() == null) {
            return new InvalidCommand(INVALID_ID);
        }
        if (separator.isIdOnly()) {
            if (separator.isIdRangeValid(separator.getID(), viewListSize)) {
                return new UndoneCommand(separator.getID());
            } else {
                return new InvalidCommand(INVALID_OUT_OF_RANGE);
            }
        }
        if (separator.hasTwoValidId(viewListSize)) {
            return new UndoneCommand(separator.getID(), separator.getSecondId());
        }
        if (!separator.isIdRangeValid(separator.getSecondId(), viewListSize)) {
            return new InvalidCommand(INVALID_OUT_OF_RANGE);
        }
        return new InvalidCommand(INVALID_COMMAND);
    }
}
```
###### \ArchPlanner\interpreter\parser\ViewCommandParser.java
``` java
 * ViewCommandParser parse view command with InputSeparator
 */
public class ViewCommandParser {

    private static final String INVALID_HAVE_ID = "View command shouldn't have id";
    private static final String INVALID_INCOMPLETE = "View command incomplete";
    private static final String INVALID_TAG_NOT_EXIST = "Tag %s doesn't exist!";
    private static final String INVALID_TAG_EMPTY = "Empty Tag is not allowed";
    private static final String INVALID_TAG_NO_PREFIX = "Tag requires \"#\" prefix";
    private static final String INVALID_TIME = "Invalid Time";
    private static final String INVALID_START_TIME = "Invalid Start Time";
    private static final String INVALID_START_DATE = "Invalid Start Date";
    private static final String INVALID_END_TIME = "Invalid End Time";
    private static final String INVALID_END_DATE = "Invalid End Date";
    private static final String INVALID_COMMAND = "Invalid Command";
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final String TAG_NOTATION = "#";
    private static final int MINIMUM_STRING_LENGTH = 1;

    private TaskParameters result = new TaskParameters();

    /**
     * Parse view command with InputSeparator
     * @return Parsed command object
     */
    public CommandInterface parse(String input, ArrayList<Tag> currentTagList) {
        InputSeparater separator = new InputSeparater(input);
        InputSeparater.KeywordType type = separator.getKeywordType();
        String parameter = separator.getParameter();
        if (separator.getID() != null) {
            return new InvalidCommand(INVALID_HAVE_ID);
        }

        if (type == null) {
            return parseNoKeywordCase(parameter, currentTagList);
        }

        if (parameter == null) {
            return parseKeywordOnlyCase(type);
        }

        return parserKeywordWithParameter(parameter, type);
    }

    /**
     * Parse view command with keyword and its parameter
     * May return parsed ViewCommand or InvalidCommand
     * @param parameter This is the parameter of the keyword
     * @param type This is the keyword typr
     * @return Parsed result
     */
    private CommandInterface parserKeywordWithParameter(String parameter, InputSeparater.KeywordType type) {
        TimeParserResult timeParserResult = new TimeParser().parseTime(parameter);
        boolean timeInvalid = timeParserResult.getMatchString() == null || !timeParserResult.getMatchString().equals(parameter);
        switch (type) {
            case DESCRIPTION:
                return parseDescription(parameter);
            case FROM:
                return parseFrom(timeInvalid, timeParserResult);
            case START_DATE:
                return parseStartDate(timeInvalid, timeParserResult);
            case START_TIME:
                return parseStartTime(timeInvalid, timeParserResult);
            case END_DATE:
                return parseEndDate(timeInvalid, timeParserResult);
            case END_TIME:
                return parseEndTime(timeInvalid, timeParserResult);
            default:
                return new InvalidCommand(INVALID_COMMAND);
        }
    }

    /**
     * Parse "view description" command
     * @param parameter This is the description to view
     * @return Parsed result
     */
    private CommandInterface parseDescription(String parameter) {
        result.setDescription(parameter);
        return new ViewCommand(null, null, result);
    }

    /**
     * Parse "view from" command
     * May return parsed ViewCommand or InvalidCommand
     * @param timeInvalid True if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return Parsed result
     */
    private CommandInterface parseFrom(boolean timeInvalid, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_TIME);
        }
        if (timeParserResult.hasTwoDateAndNoTime()) {
            result.setStartDate(timeParserResult.getFirstDate());
            result.setEndDate(timeParserResult.getSecondDate());
            return new ViewCommand(null, null, result);
        } else {
            return new InvalidCommand(INVALID_TIME);
        }
    }

    /**
     * Parse "view start time" command
     * May return parsed ViewCommand or InvalidCommand
     * @param timeInvalid True if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return Parsed result
     */
    private CommandInterface parseStartTime(boolean timeInvalid, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_START_TIME);
        }
        if (timeParserResult.hasNoDateAndOneTime()) {
            result.setStartTime(timeParserResult.getFirstTime());
            return new ViewCommand(null, null, result);
        } else {
            return new InvalidCommand(INVALID_START_TIME);
        }
    }

    /**
     * Parse "view start date" command
     * May return parsed ViewCommand or InvalidCommand
     * @param timeInvalid True if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return Parsed result
     */
    private CommandInterface parseStartDate(boolean timeInvalid, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_START_DATE);
        }
        if (timeParserResult.hasOneDateAndNoTime()) {
            result.setStartDate(timeParserResult.getFirstDate());
            return new ViewCommand(null, null, result);
        } else {
            return new InvalidCommand(INVALID_START_DATE);
        }
    }

    /**
     * Parse "view end time" command
     * May return parsed ViewCommand or InvalidCommand
     * @param timeInvalid True if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return Parsed result
     */
    private CommandInterface parseEndTime(boolean timeInvalid, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_END_TIME);
        }
        if (timeParserResult.hasNoDateAndOneTime()) {
            result.setEndTime(timeParserResult.getFirstTime());
            return new ViewCommand(null, null, result);
        } else {
            return new InvalidCommand(INVALID_END_TIME);
        }
    }

    /**
     * Parse "view end date" command
     * May return parsed ViewCommand or InvalidCommand
     * @param timeInvalid True if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return Parsed result
     */
    private CommandInterface parseEndDate(boolean timeInvalid, TimeParserResult timeParserResult) {
        if (timeInvalid) {
            return new InvalidCommand(INVALID_END_DATE);
        }
        if (timeParserResult.hasOneDateAndNoTime()) {
            result.setEndDate(timeParserResult.getFirstDate());
            return new ViewCommand(null, null, result);
        } else {
            return new InvalidCommand(INVALID_END_DATE);
        }
    }

    /**
     * Parse view command without keyword
     * If the command is to view tag, parse the tags
     * Else, the parameter will be processed as partial description
     * @param parameter This is the parameter
     * @param currentTagList This is the current tag list. Tag to view should in this list
     * @return Parsed result
     */
    private CommandInterface parseNoKeywordCase(String parameter, ArrayList<Tag> currentTagList) {
        if (parameter == null) {
            return new InvalidCommand(INVALID_INCOMPLETE);
        } else if (parameter.startsWith(TAG_NOTATION)) {
            return parseTag(parameter, currentTagList);
        } else {
            result.setDescription(parameter);
            return new ViewCommand(null, null, result);
        }
    }

    /**
     * Parse view command with only keyword
     * The command is to view types or categories
     * The command maybe invalid if keyword doesn't match
     * @param type This is the command type
     * @return Parsed result
     */
    private CommandInterface parseKeywordOnlyCase(InputSeparater.KeywordType type) {
        switch (type) {
            case ALL:
                return new ViewCommand(ViewCommand.VIEW_TYPE.ALL, null, result);
            case DONE:
                return new ViewCommand(ViewCommand.VIEW_TYPE.DONE, null, result);
            case UNDONE:
                return new ViewCommand(ViewCommand.VIEW_TYPE.UNDONE, null, result);
            case OVERDUE:
                return new ViewCommand(ViewCommand.VIEW_TYPE.OVERDUE, null, result);
            case TASKS:
                return new ViewCommand(null, ViewCommand.CATEGORY_TYPE.TASKS, result);
            case DEADLINES:
                return new ViewCommand(null, ViewCommand.CATEGORY_TYPE.DEADLINES, result);
            case EVENTS:
                return new ViewCommand(null, ViewCommand.CATEGORY_TYPE.EVENTS, result);
            default:
                return new InvalidCommand(INVALID_INCOMPLETE);
        }
    }

    /**
     * Parse the tag string to a tag list
     * The tag in the string should be in the global tag list
     * @param parameter This is the tag string
     * @param currentTagList This is the current global tag list
     * @return Parsed result
     */
    private CommandInterface parseTag(String parameter, ArrayList<Tag> currentTagList) {
        String[] tags = parameter.split(STRING_MULTIPLE_WHITESPACE);
        ArrayList<String> tagList = new ArrayList<>();
        for (String tag : tags) {
            if (!tag.startsWith(TAG_NOTATION)) {
                return new InvalidCommand(INVALID_TAG_NO_PREFIX);
            }
            if (tag.length() <= MINIMUM_STRING_LENGTH) {
                return new InvalidCommand(INVALID_TAG_EMPTY);
            }
            if (!containTag(tag, currentTagList)) {
                return new InvalidCommand(String.format(INVALID_TAG_NOT_EXIST, tag));
            }
            tagList.add(tag);
        }
        result.setTagsList(tagList);
        return new ViewCommand(null, null, result);
    }

    /**
     * Check whether the tag is in the global tag list
     * @param tagName This is the tag name to check
     * @param currentTagList This is the current global tag list
     * @return True if the tag name is in the tag list
     */
    private boolean containTag(String tagName, ArrayList<Tag> currentTagList) {
        for (Tag tag : currentTagList) {
            if (tag.getName().equals(tagName)) {
                return true;
            }
        }
        return false;
    }


}
```
###### \ArchPlanner\interpreter\prompt\EditPrompt.java
``` java
 * EditPrompt return the prompts of edit command for the user input
 */
public class EditPrompt implements PromptInterface {

    private static final String EDIT_ID = "edit <Task ID>";
    private static final String EDIT_DESCRIPTION = "edit <Task ID> description";
    private static final String EDIT_DESCRIPTION_FULL = "edit <Task ID> description <Description>";
    private static final String EDIT_TAG = "edit <Task ID> #<Tag>";
    private static final String EDIT_TAG_APPENDIX = " #<Tag>";

    private static final String EDIT_TIME = "edit <Task ID> start | end | from";
    private static final String EDIT_START = "edit <Task ID> start";
    private static final String EDIT_START_REMOVE = "edit <Task ID> start remove";
    private static final String EDIT_START_10 = "edit <Task ID> start <Date>";
    private static final String EDIT_START_01 = "edit <Task ID> start <Time>";
    private static final String EDIT_START_11 = "edit <Task ID> start <Date> <Time>";
    private static final String EDIT_END = "edit <Task ID> end";
    private static final String EDIT_END_REMOVE = "edit <Task ID> end remove";
    private static final String EDIT_END_10 = "edit <Task ID> end <Date>";
    private static final String EDIT_END_01 = "edit <Task ID> end <Time>";
    private static final String EDIT_END_11 = "edit <Task ID> end <Date> <Time>";

    private static final String EDIT_FROM = "edit <Task ID> from";
    private static final String EDIT_FROM_1010 = "edit <Task ID> from <Start Date> to <End Date>";
    private static final String EDIT_FROM_0101 = "edit <Task ID> from <Start Time> to <End Time>";
    private static final String EDIT_FROM_0110 = "edit <Task ID> from <Start Time> to <End Date>";
    private static final String EDIT_FROM_1011 = "edit <Task ID> from <Start Date> to <End Date> <End Time>";
    private static final String EDIT_FROM_0111 = "edit <Task ID> from <Start Time> to <End Date> <End Time>";
    private static final String EDIT_FROM_1110 = "edit <Task ID> from <Start Date> <Start Time> to <End Date>";
    private static final String EDIT_FROM_1101 = "edit <Task ID> from <Start Date> <Start Time> to <End Time>";
    private static final String EDIT_FROM_1111 = "edit <Task ID> from <Start Date> <Start Time> to <End Date> <End Time>";

    private static final String REMOVE = "remove";
    private static final String REMOVE_START = "edit <Task ID> start remove";
    private static final String REMOVE_END = "edit <Task ID> end remove";
    private static final String REMOVE_TAG = "edit <Task ID> # remove";

    private static final String INVALID_ID = "Invalid ID: edit <Task ID>";
    private static final String INVALID_TIME = "Invalid Time";
    private static final String INVALID_COMMAND = "Invalid Edit Command";
    private static final String INVALID_START = "Invalid Time: edit <Task ID> start <Date> <Time>";
    private static final String INVALID_END = "Invalid Time: edit <Task ID> end <Date> <Time>";
    private static final String INVALID_TAG = "Invalid tag: edit <Task ID> #<Tag>";

    private static final String KEYWORD_DESCRIPTION = "description";
    private static final String KEYWORD_START_REMOVE = "start remove";
    private static final String KEYWORD_START = "start";
    private static final String KEYWORD_END = "end";
    private static final String KEYWORD_END_REMOVE = "end remove";
    private static final String KEYWORD_FROM = "from";
    private static final String KEYWORD_TAG_REMOVE = "# remove";

    private static final String TAG_NOTATION = "#";
    private static final String EMPTY_STRING = "";
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final int MINIMUM_INDEX = 1;
    private static final int ONE_WORD = 1;

    ArrayList<String> promptList = new ArrayList<>();
    InputSeparater inputSeparator;

    /**
     * Get prompts of edit command
     */
    @Override
    public ArrayList<String> getPrompts(String userInput) {

        this.inputSeparator = new InputSeparater(userInput);
        int wordCount = inputSeparator.getWordCount();
        Integer id = inputSeparator.getID();
        String parameter = inputSeparator.getParameter();
        InputSeparater.KeywordType keyword = inputSeparator.getKeywordType();
        boolean endWithSpace = inputSeparator.isEndWithSpace();

        if (id == null) {
            if (wordCount == ONE_WORD) {
                promptList.add(EDIT_ID);
            } else {
                promptList.add(INVALID_ID);
            }
            return promptList;
        }
        if (id < MINIMUM_INDEX) {
            promptList.add(INVALID_ID);
            return promptList;
        }

        if (keyword == null) {
            handleNoKeywordCase(parameter, endWithSpace);
        } else {
            handleKeywordWithParameter(keyword, parameter);
        }
        if (promptList.isEmpty()) {
            promptList.add(INVALID_COMMAND);
        }
        return promptList;
    }

    /**
     * Prompt edit command without keyword
     * @param parameter This is the parameter
     * @param endWithSpace True if user's input end with space
     */
    private void handleNoKeywordCase(String parameter, boolean endWithSpace) {
        if (parameter == null) {
            promptList.add(EDIT_DESCRIPTION);
            promptList.add(EDIT_TIME);
            promptList.add(EDIT_TAG);
        } else {

            boolean hasTags = checkTags(parameter, endWithSpace);

            if (!hasTags) {
                if (KEYWORD_DESCRIPTION.startsWith(parameter)) {
                    promptList.add(EDIT_DESCRIPTION);
                }
                if (KEYWORD_START.startsWith(parameter)) {
                    promptList.add(EDIT_START);
                }
                if (KEYWORD_END.startsWith(parameter)) {
                    promptList.add(EDIT_END);
                }
                if (KEYWORD_START_REMOVE.startsWith(parameter)) {
                    promptList.add(REMOVE_START);
                }
                if (KEYWORD_END_REMOVE.startsWith(parameter)) {
                    promptList.add(REMOVE_END);
                }
                if (KEYWORD_FROM.startsWith(parameter)) {
                    promptList.add(EDIT_FROM);
                }
            } else if (KEYWORD_TAG_REMOVE.startsWith(parameter)) {
                promptList.add(REMOVE_TAG);
            } else if (promptList.isEmpty()) {
                promptList.add(INVALID_TAG);
            }
        }
    }

    /**
     * Prompt edit command with a keyword and its parameter
     * @param keyword This is the keyword
     * @param parameter This is the parameter of the keyword
     */
    private void handleKeywordWithParameter(InputSeparater.KeywordType keyword, String parameter) {
        TimeParserResult result = new TimeParser().parseTime(parameter);
        switch (keyword) {
            case DESCRIPTION:
                promptList.add(EDIT_DESCRIPTION_FULL);
                break;
            case START:
                handleStart(parameter, result);
                break;
            case END:
                handleEnd(parameter, result);
                break;
            case FROM:
                handleFrom(result);
            default:
                break;
        }
    }

    /**
     * Get auto complete word of current input
     * @return The auto complete word
     */
    @Override
    public String getAutoWord() {
        if (inputSeparator.getID() != null) {
            if (inputSeparator.getKeywordType() == InputSeparater.KeywordType.START
                    || inputSeparator.getKeywordType() == InputSeparater.KeywordType.END) {
                String remove = REMOVE;
                if (remove.startsWith(inputSeparator.getParameter().toLowerCase())) {
                    return remove;
                }
            }
            return inputSeparator.getPartialKeyword();
        }
        return EMPTY_STRING;
    }

    /**
     * Prompt "edit <Task ID> start" case
     * This command may edit start date, start time or remove start date and time
     * @param parameter This is the parameter
     * @param result This is the TimeParserResult which contains data
     */
    private void handleStart(String parameter, TimeParserResult result) {
        if (parameter == null) {
            promptList.add(EDIT_START_10);
            promptList.add(EDIT_START_01);
            promptList.add(EDIT_START_11);
            promptList.add(EDIT_START_REMOVE);
        } else if (isToRemove(parameter)) {
            promptList.add(EDIT_START_REMOVE);
        } else if (isTimeInvalid(result)) {
            promptList.add(INVALID_TIME);
        } else {
            switch (result.getDateTimeStatus()) {
                case NONE:
                    promptList.add(EDIT_START_10);
                    promptList.add(EDIT_START_01);
                    promptList.add(EDIT_START_11);
                    break;
                case START_TIME:
                    promptList.add(EDIT_START_01);
                    break;
                case START_DATE:
                    promptList.add(EDIT_START_10);
                    promptList.add(EDIT_START_11);
                    break;
                case START_DATE_START_TIME:
                    promptList.add(EDIT_START_11);
                    break;
                default:
                    promptList.add(INVALID_START);
            }
        }
    }

    /**
     * Prompt "edit <Task ID> end" case
     * This command may edit end date, end time or remove end date and time
     * @param parameter This is the parameter
     * @param result This is the TimeParserResult which contains data
     */
    private void handleEnd(String parameter, TimeParserResult result) {
        if (parameter == null) {
            promptList.add(EDIT_END_10);
            promptList.add(EDIT_END_01);
            promptList.add(EDIT_END_11);
            promptList.add(EDIT_END_REMOVE);
        } else if (isToRemove(parameter)) {
            promptList.add(EDIT_END_REMOVE);
        } else if (isTimeInvalid(result)) {
            promptList.add(INVALID_TIME);
        } else {
            switch (result.getDateTimeStatus()) {
                case NONE:
                    promptList.add(EDIT_END_10);
                    promptList.add(EDIT_END_01);
                    promptList.add(EDIT_END_11);
                    break;
                case START_TIME:
                    promptList.add(EDIT_END_01);
                    break;
                case START_DATE:
                    promptList.add(EDIT_END_10);
                    promptList.add(EDIT_END_11);
                    break;
                case START_DATE_START_TIME:
                    promptList.add(EDIT_END_11);
                    break;
                default:
                    promptList.add(INVALID_END);
            }
        }
    }

    /**
     * Prompt "edit <Task ID> from" case
     * This command will edit both start time and end time
     * @param result This is the TimeParserResult which contains data
     */
    private void handleFrom(TimeParserResult result) {
        switch (result.getRawDateTimeStatus()) {
            case NONE:
                promptList.add(EDIT_FROM_1010);
                promptList.add(EDIT_FROM_0101);
                promptList.add(EDIT_FROM_1111);
                break;
            case START_TIME:
                promptList.add(EDIT_FROM_0101);
                promptList.add(EDIT_FROM_0110);
                promptList.add(EDIT_FROM_0111);
                break;
            case START_TIME_END_TIME:
                promptList.add(EDIT_FROM_0101);
                break;
            case START_TIME_END_DATE:
                promptList.add(EDIT_FROM_0110);
                promptList.add(EDIT_FROM_0111);
                break;
            case START_TIME_END_DATE_END_TIME:
                promptList.add(EDIT_FROM_0111);
                break;
            case START_DATE:
                promptList.add(EDIT_FROM_1010);
                promptList.add(EDIT_FROM_1111);
                break;
            case START_DATE_END_DATE:
                promptList.add(EDIT_FROM_1010);
                promptList.add(EDIT_FROM_1011);
                break;
            case START_DATE_END_DATE_END_TIME:
                promptList.add(EDIT_FROM_1011);
                break;
            case START_DATE_START_TIME:
                promptList.add(EDIT_FROM_1101);
                promptList.add(EDIT_FROM_1111);
                break;
            case START_DATE_START_TIME_END_TIME:
                promptList.add(EDIT_FROM_1101);
                break;
            case START_DATE_START_TIME_END_DATE:
                promptList.add(EDIT_FROM_1111);
                promptList.add(EDIT_FROM_1110);
                break;
            case START_DATE_START_TIME_END_DATE_END_TIME:
                promptList.add(EDIT_FROM_1111);
                break;
            default:
                break;
        }
    }

    /**
     * Check if the command is to edit tag and add tag prompt if true
     * @param parameter This is the parameter
     * @param endWithSpace True if the user's input end with space
     * @return True if the command is to edit tag
     */
    private boolean checkTags(String parameter, boolean endWithSpace) {
        if (parameter == null) {
            return false;
        }
        String[] possibleTags = parameter.split(STRING_MULTIPLE_WHITESPACE);
        for (int i = 0; i < possibleTags.length; i++) {
            String possibleTag = possibleTags[i];
            if (!possibleTag.startsWith(TAG_NOTATION)) {
                return i != 0;
            }
            if (possibleTag.equals(TAG_NOTATION)) {
                if (endWithSpace || i != possibleTags.length - 1) {
                    return true;
                }
            }
        }
        String tagPrompt = EDIT_TAG;
        int appendixCount = possibleTags.length - 1;
        if (endWithSpace) {
            appendixCount++;
        }
        for (int i = 0; i < appendixCount; i++) {
            tagPrompt += EDIT_TAG_APPENDIX;
        }
        promptList.add(tagPrompt);
        return true;
    }

    /**
     * Check whether the parameter is "remove" or halfway typing "remove".
     * @param parameter This is the parameter
     * @return True if user may wants to type remove
     */
    private boolean isToRemove(String parameter) {
        if (parameter != null) {
            String remove = REMOVE;
            return remove.startsWith(parameter.toLowerCase());
        }
        return true;
    }

    /**
     * Check if the time is valid
     * @param timeParserResult This is the TimeParserResult object which contains data
     * @return True if time is valid
     */
    private boolean isTimeInvalid(TimeParserResult timeParserResult) {
        String parameter = inputSeparator.getParameter();
        if (parameter != null) {
            int parameterCount = parameter.split(STRING_MULTIPLE_WHITESPACE).length;
            if (timeParserResult.getMatchString() == null) {
                return parameterCount > ONE_WORD;
            }
            int timeCount = timeParserResult.getMatchString().split(STRING_MULTIPLE_WHITESPACE).length;
            if (parameterCount - timeCount > ONE_WORD) {
                return true;
            }
        }
        return false;
    }

}
```
###### \ArchPlanner\interpreter\prompt\IdOnlyPrompt.java
``` java
 * IdOnlyPrompt return the prompts of id only command for the user input
 */
public class IdOnlyPrompt implements PromptInterface{

    private static final String COMMAND = "%s <Task ID>";
    private static final String COMMAND_RANGE = "%s <Task ID> to <Task ID>";
    private static final String INVALID_ID = "Invalid ID: %s <Task ID>";
    private static final String INVALID_COMMAND = "Invalid command";
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final String EMPTY_STRING = "";
    private static final int FIRST_INDEX = 0;
    private static final int ONE_WORD = 1;
    private static final int TWO_WORD = 2;
    private static final int MINIMUM_ID = 1;

    InputSeparater inputSeparator;

    /**
     * Get the prompt of ID only command: delete, done and undone.
     */
    @Override
    public ArrayList<String> getPrompts(String userInput) {
        String commandName = userInput.trim().toLowerCase().split(STRING_MULTIPLE_WHITESPACE)[FIRST_INDEX];
        ArrayList<String> promptList = new ArrayList<>();
        this.inputSeparator = new InputSeparater(userInput);
        if (inputSeparator.getWordCount() == ONE_WORD) {
            promptList.add(String.format(COMMAND, commandName));
            promptList.add(String.format(COMMAND_RANGE, commandName));
        } else if (inputSeparator.getWordCount() == TWO_WORD) {
            if (inputSeparator.getID() != null) {
                if (inputSeparator.getID() >= MINIMUM_ID) {
                    promptList.add(String.format(COMMAND, commandName));
                    promptList.add(String.format(COMMAND_RANGE, commandName));
                } else {
                    promptList.add(String.format(INVALID_ID, commandName));
                }
            } else {
                promptList.add(String.format(INVALID_ID, commandName));
            }
        } else {
            if (inputSeparator.mayHaveTwoValidID()) {
                promptList.add(String.format(COMMAND_RANGE, commandName));
            } else {
                promptList.add(INVALID_COMMAND);
            }
        }
        return promptList;
    }

    /**
     * Get auto complete word of current input
     * @return The auto complete word
     */
    @Override
    public String getAutoWord() {
        if (inputSeparator.getID() != null) {
            return inputSeparator.getPartialKeyword();
        }
        return EMPTY_STRING;
    }
}
```
###### \ArchPlanner\interpreter\prompt\SetPrompt.java
``` java
 * SetPrompt return the prompts of set command for the user input
 */
public class SetPrompt implements PromptInterface {
    private final String SET_PROMPT = "set filepath <New File Path>";
    private final String SET_PROMPT_DEFAULT = "set filepath default";
    private final String FILEPATH = "filepath";
    private final String DEFAULT = "default";
    private final String INVALID_KEYWORD = "Invalid keyword: set filepath <New File Path>";
    private final String INVALID_ID = "Invalid id: set filepath <New File Path>";
    ArrayList<String> promptList = new ArrayList<>();
    InputSeparater inputSeparator;

    /**
     * Get prompt of set command.
     * @param userInput
     * @return
     */
    @Override
    public ArrayList<String> getPrompts(String userInput) {
        this.inputSeparator = new InputSeparater(userInput);
        if (inputSeparator.getID() != null) {
            promptList.add(INVALID_ID);
        }
        if (inputSeparator.getKeywordType() != null && inputSeparator.getKeywordType() == InputSeparater.KeywordType.FILEPATH) {
            if (inputSeparator.getParameter() == null) {
                promptList.add(SET_PROMPT);
                promptList.add(SET_PROMPT_DEFAULT);
            } else if (DEFAULT.startsWith(inputSeparator.getParameter().toLowerCase())) {
                promptList.add(SET_PROMPT_DEFAULT);
                promptList.add(SET_PROMPT);
            } else {
                promptList.add(SET_PROMPT);
            }
        } else {
            if (inputSeparator.getParameter() == null || FILEPATH.startsWith(inputSeparator.getParameter().toLowerCase())) {
                promptList.add(SET_PROMPT);
                promptList.add(SET_PROMPT_DEFAULT);
            } else {
                promptList.add(INVALID_KEYWORD);
            }
        }
        return promptList;
    }

    /**
     * Get auto complete word of current input
     * @return The auto complete word
     */
    @Override
    public String getAutoWord() {
        if (inputSeparator.getKeywordType() != null && inputSeparator.getKeywordType() == InputSeparater.KeywordType.FILEPATH) {
            if (inputSeparator.getParameter() != null && DEFAULT.startsWith(inputSeparator.getParameter().toLowerCase())) {
                return DEFAULT;
            }
        }
        return inputSeparator.getPartialKeyword();
    }
}
```
###### \ArchPlanner\interpreter\prompt\ViewPrompt.java
``` java
 * ViewPrompt return the prompts of view command for the user input
 */
public class ViewPrompt implements PromptInterface {
    private final String VIEW_ALL = "view all";
    private final String VIEW_DONE = "view done";
    private final String VIEW_UNDONE = "view undone";
    private final String VIEW_OVERDUE = "view overdue";
    private final String VIEW_DEADLINE = "view deadlines";
    private final String VIEW_EVENT = "view events";
    private final String VIEW_TASK = "view tasks";
    private final String VIEW_DESCRIPTION = "view description <Partial Description>";
    private final String VIEW_DESCRIPTION_WITHOUT_KEYWORD = "view <Partial Description>";
    private final String VIEW_FROM = "view from ";
    private final String VIEW_FROM_FULL = "view from <Start Date> to <End Date>";
    private final String VIEW_START_DATE = "view start date ";
    private final String VIEW_START_DATE_FULL = "view start date <Start Date>";
    private final String VIEW_START_TIME = "view start time ";
    private final String VIEW_START_TIME_FULL = "view start time <Start Time>";
    private final String VIEW_END_DATE = "view end date ";
    private final String VIEW_END_DATE_FULL = "view end date <End Date>";
    private final String VIEW_END_TIME = "view end time ";
    private final String VIEW_END_TIME_FULL = "view end time <End Time>";
    private final String VIEW_TAGS_HEADER = "view #<Tag>";
    private final String VIEW_TAGS_APPENDIX = " #<Tag>";
    private final String VIEW_CATEGORY = "view events | deadlines | tasks";
    private final String VIEW_TYPE = "view all | done | undone | overdue";
    private final String VIEW_TIME = "view start | end | from";

    private final String INVALID_COMMAND = "Invalid command";
    private final String INVALID_TAG = "Invalid Tag: view #<Tag>";
    private final String INVALID_FROM = "Invalid Time: view from <Start Date> to <End Date>";
    private final String INVALID_START_TIME = "Invalid time: view start time <Start Time>";
    private final String INVALID_START_DATE = "Invalid date: view start date <Start Date>";
    private final String INVALID_END_TIME = "Invalid time: view end time <End Time>";
    private final String INVALID_END_DATE = "Invalid date: view end date <End Date>";

    private static final String TAG_NOTATION = "#";
    private static final String EMPTY_STRING = "";
    private static final String SPACE_STRING = " ";
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";

    private static final int FIRST_INDEX = 0;
    private static final int ONE_WORD = 1;

    ArrayList<String> promptList = new ArrayList<>();
    InputSeparater inputSeparator;

    @Override
    public ArrayList<String> getPrompts(String command) {
        command = removeMultipleSpace(command);
        this.inputSeparator = new InputSeparater(command);
        InputSeparater.KeywordType type = inputSeparator.getKeywordType();
        String parameter = inputSeparator.getParameter();
        String lowerCaseCommand = command.toLowerCase();

        if (inputSeparator.getWordCount() == ONE_WORD) {
            handleEmptyCase();
            return promptList;
        }

        handleKeywordTypingCase(lowerCaseCommand);

        boolean hasTags = checkTags(inputSeparator.getParameter(), inputSeparator.isEndWithSpace());

        if (type != null) {
            handleKeywordWithParameter(type, parameter);
        }

        handleUnrecognizedCase(hasTags);

        return promptList;
    }

    /**
     * Prompt the message when user types only "view"
     */
    private void handleEmptyCase() {
        promptList.add(VIEW_DESCRIPTION);
        promptList.add(VIEW_CATEGORY);
        promptList.add(VIEW_TYPE);
        promptList.add(VIEW_TIME);
    }

    /**
     * Prompt possible view command when user is typing keyword halfway
     *
     * @param lowerCaseCommand This is the lower case of user's input
     */
    private void handleKeywordTypingCase(String lowerCaseCommand) {
        if (VIEW_DESCRIPTION.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_DESCRIPTION);
        }
        if (VIEW_OVERDUE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_OVERDUE);
        }
        if (VIEW_DEADLINE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_DEADLINE);
        }
        if (VIEW_EVENT.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_EVENT);
        }
        if (VIEW_TASK.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_TASK);
        }
        if (VIEW_ALL.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_ALL);
        }
        if (VIEW_DONE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_DONE);
        }
        if (VIEW_UNDONE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_UNDONE);
        }
        if (VIEW_FROM.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_FROM_FULL);
        }
        if (VIEW_START_DATE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_START_DATE_FULL);
        }
        if (VIEW_START_TIME.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_START_TIME_FULL);
        }
        if (VIEW_END_DATE.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_END_DATE_FULL);
        }
        if (VIEW_END_TIME.startsWith(lowerCaseCommand)) {
            promptList.add(VIEW_END_TIME_FULL);
        }
    }

    /**
     * Prompt view command with keyword and its parameter
     *
     * @param type      This is the keyword
     * @param parameter This is the parameter of the keyword
     */
    private void handleKeywordWithParameter(InputSeparater.KeywordType type, String parameter) {
        switch (type) {
            case DESCRIPTION:
                handleDescription(parameter);
                break;
            case FROM:
                handleFrom(parameter);
                break;
            case START_DATE:
                handleStartDate(parameter);
                break;
            case START_TIME:
                handleStartTime(parameter);
                break;
            case END_DATE:
                handleEndDate(parameter);
                break;
            case END_TIME:
                handleEndTime(parameter);
                break;
            default:
                break;
        }
    }

    /**
     * Prompt "view description" case
     *
     * @param parameter This is the parameter
     */
    private void handleDescription(String parameter) {
        if (parameter != null) {
            promptList.add(VIEW_DESCRIPTION);
        }
    }

    /**
     * Prompt "view from" case
     *
     * @param parameter This is the parameter
     */
    private void handleFrom(String parameter) {
        if (parameter == null) {
            return;
        }
        TimeParserResult result = new TimeParser().parseTime(parameter);
        if (result.getMatchString() == null || !result.getMatchString().equals(parameter)) {
            promptList.add(INVALID_FROM);
        } else {
            if (result.getFirstDate() != null && result.getSecondDate() != null) {
                if (result.getFirstTime() == null && result.getSecondTime() == null) {
                    promptList.add(VIEW_FROM_FULL);
                }
            } else {
                promptList.add(INVALID_FROM);
            }

        }
    }

    /**
     * Prompt "view start date" case
     *
     * @param parameter This is the parameter
     */
    private void handleStartDate(String parameter) {
        if (parameter == null) {
            return;
        }
        TimeParserResult result = new TimeParser().parseTime(parameter);
        if (result.getMatchString() == null || !result.getMatchString().equals(parameter)) {
            promptList.add(INVALID_START_DATE);
        } else {
            if (result.getFirstDate() != null && result.getSecondDate() == null
                    && result.getFirstTime() == null && result.getSecondTime() == null) {
                promptList.add(VIEW_START_DATE_FULL);
            } else {
                promptList.add(INVALID_START_DATE);
            }
        }
    }

    /**
     * Prompt "view start time" case
     *
     * @param parameter This is the parameter
     */
    private void handleStartTime(String parameter) {
        if (parameter == null) {
            return;
        }
        TimeParserResult result = new TimeParser().parseTime(parameter);
        if (result.getMatchString() == null || !result.getMatchString().equals(parameter)) {
            promptList.add(INVALID_START_TIME);
        } else {
            if (result.getFirstDate() == null && result.getSecondDate() == null
                    && result.getFirstTime() != null && result.getSecondTime() == null) {
                promptList.add(VIEW_START_TIME_FULL);
            } else {
                promptList.add(INVALID_START_TIME);
            }
        }
    }

    /**
     * Prompt "view end date" case
     *
     * @param parameter This is the parameter
     */
    private void handleEndDate(String parameter) {
        if (parameter == null) {
            return;
        }
        TimeParserResult result = new TimeParser().parseTime(parameter);
        if (result.getMatchString() == null || !result.getMatchString().equals(parameter)) {
            promptList.add(INVALID_END_DATE);
        } else {
            if (result.getFirstDate() != null && result.getSecondDate() == null
                    && result.getFirstTime() == null && result.getSecondTime() == null) {
                promptList.add(VIEW_END_DATE_FULL);
            } else {
                promptList.add(INVALID_END_DATE);
            }
        }
    }

    /**
     * Prompt "view end time" case
     *
     * @param parameter This is the parameter
     */
    private void handleEndTime(String parameter) {
        if (parameter == null) {
            return;
        }
        TimeParserResult result = new TimeParser().parseTime(parameter);
        if (result.getMatchString() == null || !result.getMatchString().equals(parameter)) {
            promptList.add(INVALID_END_TIME);
        } else {
            if (result.getFirstDate() == null && result.getSecondDate() == null
                    && result.getFirstTime() != null && result.getSecondTime() == null) {
                promptList.add(VIEW_END_TIME_FULL);
            } else {
                promptList.add(INVALID_END_TIME);
            }
        }

    }

    /**
     * Get auto complete word of current input
     *
     * @return The auto complete word
     */
    @Override
    public String getAutoWord() {
        return inputSeparator.getPartialKeyword();
    }

    /**
     * Check if the command is to edit tag and add tag prompt if true
     *
     * @param parameter    This is the parameter
     * @param endWithSpace True if the user's input end with space
     * @return True if the command is to edit tag
     */
    private boolean checkTags(String parameter, boolean endWithSpace) {
        if (parameter == null) {
            return false;
        }
        String[] possibleTags = parameter.split(STRING_MULTIPLE_WHITESPACE);
        for (int i = 0; i < possibleTags.length; i++) {
            String possibleTag = possibleTags[i];
            if (!possibleTag.startsWith(TAG_NOTATION)) {
                if (i == FIRST_INDEX) {
                    return false;
                }
                promptList.add(INVALID_TAG);
                return true;
            }
            if (possibleTag.equals(TAG_NOTATION)) {
                if (endWithSpace || i != possibleTags.length - 1) {
                    promptList.add(INVALID_TAG);
                    return true;
                }
            }
        }
        String tagPrompt = VIEW_TAGS_HEADER;
        int appendixCount = possibleTags.length - 1;
        if (endWithSpace) {
            appendixCount++;
        }
        for (int i = 0; i < appendixCount; i++) {
            tagPrompt += VIEW_TAGS_APPENDIX;
        }
        promptList.add(tagPrompt);
        return true;
    }

    /**
     * If the prompt list is still empty, check if it's partial description or invalid and prompt message
     *
     * @param hasTags True if the view command contains tag
     */
    private void handleUnrecognizedCase(boolean hasTags) {
        if (promptList.isEmpty()) {
            if (hasTags) {
                promptList.add(INVALID_COMMAND);
            } else {
                promptList.add(VIEW_DESCRIPTION_WITHOUT_KEYWORD);
            }
        }
    }

    /**
     * Remove multiple spaces in user's input
     *
     * @param input User's input
     * @return The string which has removed multiple spaces
     */
    private String removeMultipleSpace(String input) {
        String[] splitInput = input.trim().split(STRING_MULTIPLE_WHITESPACE);
        String result = EMPTY_STRING;
        for (String part : splitInput) {
            result += part + SPACE_STRING;
        }
        return result.trim();
    }

}
```
###### \ArchPlanner\interpreter\separater\InputSeparater.java
``` java
 * InputSeparator return the parsed components of a command
 * This class serves for all commands except add command
 */
public class InputSeparater {

    public enum KeywordType {
        DESCRIPTION, DONE, UNDONE, OVERDUE, ALL, DEADLINES, EVENTS, TASKS, TO, FILEPATH,
        START_TIME, END_TIME, START_DATE, END_DATE, FROM, START, END;

        @Override
        public String toString() {
            return this.name().toLowerCase().replace('_', ' ');
        }
    }

    private static final HashMap<Prompt.CommandType, KeywordType[]> commandMap = new HashMap<>();

    private static final int INITIAL_PARSE_INDEX = 1;
    private static final String STRING_MULTIPLE_WHITESPACE = "\\s+";
    private static final String EMPTY_STRING = "";
    private static final String SPACE_STRING = " ";

    private Prompt.CommandType commandType;
    private int wordCount;
    private Integer id;
    private Integer secondId;
    private KeywordType keywordType;
    private String parameter;
    private int idPosition = INITIAL_PARSE_INDEX;
    private int keywordPosition = INITIAL_PARSE_INDEX;
    private int parameterPosition = INITIAL_PARSE_INDEX;
    private boolean endWithSpace;

    /**
     * Parse ID, keyword and parameter
     *
     * @param command This is user's input
     */
    public InputSeparater(String command) {
        commandType = determineCommandType(command);
        String[] breakUserInput = command.split(STRING_MULTIPLE_WHITESPACE);
        this.wordCount = breakUserInput.length;
        this.id = parseID(breakUserInput);
        this.keywordType = parseKeyword(breakUserInput);
        this.secondId = parseSecondId(breakUserInput);
        this.parameter = parseParameter(breakUserInput);
        this.endWithSpace = command.endsWith(SPACE_STRING);
    }

    /**
     * Parse second ID for delete, done and undone command
     *
     * @param input This is user's input split by space
     * @return Parsed ID, null if doesn't exist
     */
    private Integer parseSecondId(String[] input) {
        try {
            if (keywordType != null && keywordType == KeywordType.TO) {
                Integer result = Integer.parseInt(input[parameterPosition]);
                parameterPosition++;
                return result;
            }
            return null;
        } catch (NumberFormatException e) {
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    /**
     * Get the partial keyword from current input
     * This method serves for parser to get partial word
     *
     * @return Auto complete partial keyword
     */
    public String getPartialKeyword() {
        if (keywordType != null) {
            return EMPTY_STRING;
        }
        for (KeywordType type : KeywordType.values()) {
            if (commandHasKeyword(commandType, type) && type.toString().startsWith(parameter.toLowerCase())) {
                return getAutoCompleteWord(type);
            }
        }
        return EMPTY_STRING;
    }

    /**
     * Get the auto complete word according to the type and current typing status
     *
     * @param type the keyword type
     * @return The auto complete word
     */
    private String getAutoCompleteWord(KeywordType type) {
        String[] splitType = type.toString().split(STRING_MULTIPLE_WHITESPACE);
        if (splitType.length > 1) {
            if (parameter.contains(SPACE_STRING)) {
                return splitType[1];
            } else {
                return splitType[0];
            }
        }
        return type.toString();
    }

    /**
     * Parse ID from user's input if exist
     *
     * @param input This is the user's input split by space
     * @return Parsed ID, null if doesn't exist
     */
    private Integer parseID(String[] input) {
        try {
            Integer result = Integer.parseInt(input[idPosition]);
            keywordPosition++;
            parameterPosition++;
            return result;
        } catch (NumberFormatException e) {
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    /**
     * Parse keyword from user's input if exist
     *
     * @param input This is the user's input split by space
     * @return Parsed keyword, null if doesn't exist
     */
    private KeywordType parseKeyword(String[] input) {
        try {
            for (KeywordType type : KeywordType.values()) {
                if (input[keywordPosition].equalsIgnoreCase(type.toString())
                        && commandHasKeyword(commandType, type)) {
                    parameterPosition++;
                    return type;
                }
            }
            String twoWord = input[keywordPosition] + SPACE_STRING + input[keywordPosition + 1];
            for (KeywordType type : KeywordType.values()) {
                if (twoWord.equalsIgnoreCase(type.toString())
                        && commandHasKeyword(commandType, type)) {
                    parameterPosition += 2;
                    return type;
                }
            }
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    /**
     * Parse parameter from user's input if exist
     *
     * @param input This is the user's input split by space
     * @return Parsed parameter, null if doesn't exist
     */
    private String parseParameter(String[] input) {
        if (input.length == parameterPosition) {
            return null;
        }
        String result = EMPTY_STRING;
        for (int i = parameterPosition; i < input.length; i++) {
            result += input[i] + SPACE_STRING;
        }
        return result.trim();
    }

    /**
     * Check if the command only has a ID
     *
     * @return True if contains ID only
     */
    public boolean isIdOnly() {
        return id != null && keywordType == null && parameter == null;
    }

    /**
     * Check if the ID's range is between 1 and the current view list
     *
     * @param id           User typed ID
     * @param viewListSize The size of current view list
     * @return True if ID's range is valid
     */
    public boolean isIdRangeValid(Integer id, int viewListSize) {
        return id != null && id > 0 && id <= viewListSize;
    }

    public boolean hasTwoValidId(int viewListSize) {
        try {
            return isIdRangeValid(id, viewListSize)
                    && isIdRangeValid(secondId, viewListSize)
                    && id < secondId
                    && keywordType == KeywordType.TO
                    && parameter == null;
        } catch (NullPointerException e) {
            return false;
        }
    }

    /**
     * Check whether user may want to input two ID
     */
    public boolean mayHaveTwoValidID() {
        if (parameter == null) {
            return !(id != null && secondId != null && id >= secondId);
        } else if (id != null && KeywordType.TO.toString().startsWith(parameter.toLowerCase())) {
            return true;
        }
        return false;
    }

    /**
     * Determine the command type of the command
     *
     * @param input User's command
     * @return Recognized commant type
     */
    private Prompt.CommandType determineCommandType(String input) {
        String commandTypeString = input.trim().split(STRING_MULTIPLE_WHITESPACE)[0];
        if (commandTypeString.isEmpty()) {
            return Prompt.CommandType.UNKNOWN;
        }
        for (Prompt.CommandType type : Prompt.CommandType.values()) {
            if (commandTypeString.equalsIgnoreCase(type.toString())) {
                return type;
            }
        }
        return Prompt.CommandType.UNKNOWN;
    }

    /**
     * Check whether the keyword is valid for the specific command type
     *
     * @param commandType This is the command type
     * @param keywordType This is the keyword type
     * @return True if the keyword is valid for the command type
     */
    private boolean commandHasKeyword(Prompt.CommandType commandType, KeywordType keywordType) {
        if (commandMap.isEmpty()) {
            initCommandMap();
        }
        KeywordType[] keywordTypes = commandMap.get(commandType);
        for (KeywordType type : keywordTypes) {
            if (type == keywordType) {
                return true;
            }
        }
        return false;
    }

    /**
     * Initialize mapping from command type to its keywords
     */
    private void initCommandMap() {
        commandMap.put(Prompt.CommandType.ADD, new KeywordType[]{});
        commandMap.put(Prompt.CommandType.DELETE, new KeywordType[]{KeywordType.TO});
        commandMap.put(Prompt.CommandType.DONE, new KeywordType[]{KeywordType.TO});
        commandMap.put(Prompt.CommandType.UNDONE, new KeywordType[]{KeywordType.TO});
        commandMap.put(Prompt.CommandType.SET, new KeywordType[]{KeywordType.FILEPATH});
        commandMap.put(Prompt.CommandType.EDIT, new KeywordType[]
                {KeywordType.DESCRIPTION, KeywordType.END, KeywordType.START, KeywordType.FROM});
        commandMap.put(Prompt.CommandType.VIEW, new KeywordType[]
                {KeywordType.ALL, KeywordType.DONE, KeywordType.UNDONE, KeywordType.OVERDUE,
                        KeywordType.DEADLINES, KeywordType.TASKS, KeywordType.EVENTS,
                        KeywordType.DESCRIPTION, KeywordType.FROM, KeywordType.START_DATE, KeywordType.START_TIME,
                        KeywordType.END_DATE, KeywordType.END_TIME});
    }


    public Integer getID() {
        return this.id;
    }

    public Integer getSecondId() {
        return secondId;
    }

    public KeywordType getKeywordType() {
        return this.keywordType;
    }

    public String getParameter() {
        return this.parameter;
    }

    public int getWordCount() {
        return wordCount;
    }

    public boolean isEndWithSpace() {
        return endWithSpace;
    }


}
```
###### \ArchPlanner\test\ArchPlannerTest.java
``` java
 * Run all tests
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({ParserTest.class, LogicTest.class, PromptTest.class, StorageTest.class})
public class ArchPlannerTest {
}
```
###### \ArchPlanner\test\LogicTest.java
``` java
 * Run all logic tests
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({LogicAddCommandTest.class, LogicDeleteCommandTest.class, LogicDoneCommandTest.class, LogicEditCommandTest.class})
public class LogicTest {
}

```
###### \ArchPlanner\test\parser\AddCommandParserTest.java
``` java
 * Test AddCommandParser
 */
public class AddCommandParserTest {


    LocalDate dateNow;
    LocalDate tomorrow;

    @Before
    public void setUp() throws Exception {
        dateNow = LocalDate.now();
        tomorrow = dateNow.plusDays(1);
    }

    /**
     * This method test keyword on with different time type
     */
    @Test
    public void testKeywordOn() throws Exception {
        //add ... on <date>
        CommandInterface onlyDateKeywordOn = new AddCommandParser().parse("add sth123 on tomorrow");
        assertEquals("sth123", ((AddCommand) onlyDateKeywordOn).getTaskParameters().getDescription());
        assertEquals(tomorrow, ((AddCommand) onlyDateKeywordOn).getTaskParameters().getStartDate());

        //add ... on <date> <time>
        CommandInterface dateTimeKeywordOn = new AddCommandParser().parse("add assignments on this Thursday 3pm #assign #oh-my-god #help-me!");
        LocalTime threePm = LocalTime.of(15, 0);
        assertEquals(threePm, ((AddCommand) dateTimeKeywordOn).getTaskParameters().getStartTime());
        assertEquals("#assign", ((AddCommand) dateTimeKeywordOn).getTaskParameters().getTagsList().get(0));
        assertEquals("#oh-my-god", ((AddCommand) dateTimeKeywordOn).getTaskParameters().getTagsList().get(1));
        assertEquals("#help-me!", ((AddCommand) dateTimeKeywordOn).getTaskParameters().getTagsList().get(2));

        //add ... on <time>
        CommandInterface timeKeywordOn = new AddCommandParser().parse("add sth on 3pm");
        assertEquals(dateNow, ((AddCommand) timeKeywordOn).getTaskParameters().getStartDate());
        assertEquals(threePm, ((AddCommand) timeKeywordOn).getTaskParameters().getStartTime());
    }

    /**
     * This method test keyword by with different time type
     */
    @Test
    public void testKeywordBy() throws Exception {
        //add ... by <date>
        CommandInterface onlyDateKeywordBy = new AddCommandParser().parse("add miao by Mar 7 #a #b");
        LocalDate mar7 = LocalDate.of(dateNow.getYear(), 3, 7);
        assertEquals(mar7, ((AddCommand) onlyDateKeywordBy).getTaskParameters().getEndDate());
        assertEquals("#a", ((AddCommand) onlyDateKeywordBy).getTaskParameters().getTagsList().get(0));
        assertEquals("#b", ((AddCommand) onlyDateKeywordBy).getTaskParameters().getTagsList().get(1));

        //add ... by <date><time>
        CommandInterface dateTimeKeywordBy = new AddCommandParser().parse("add manual V0.2 by Nov 2 23:59:59");
        LocalDate nov2 = LocalDate.of(dateNow.getYear(), 11, 2);
        assertEquals(nov2, ((AddCommand) dateTimeKeywordBy).getTaskParameters().getEndDate());
        LocalTime endOfDay = LocalTime.of(23, 59, 59);
        assertEquals(endOfDay, ((AddCommand) dateTimeKeywordBy).getTaskParameters().getEndTime());
        assertEquals(null, ((AddCommand) dateTimeKeywordBy).getTaskParameters().getStartDate());
        assertEquals(null, ((AddCommand) dateTimeKeywordBy).getTaskParameters().getStartTime());

        //add ... by <time>
        CommandInterface timeKeywordBy = new AddCommandParser().parse("add sth by 11pm");
        assertEquals(dateNow, ((AddCommand) timeKeywordBy).getTaskParameters().getEndDate());
        LocalTime elevenPm = LocalTime.of(23, 0, 0);
        assertEquals(elevenPm, ((AddCommand) timeKeywordBy).getTaskParameters().getEndTime());
    }

    /**
     * This method test keyword from with different time type
     */
    @Test
    public void testKeywordFrom() throws Exception {
        //add ... from <date> to <date>
        CommandInterface onlyDateKeywordFrom = new AddCommandParser().parse("add lalala from today to tomorrow #a");
        assertEquals("lalala", ((AddCommand) onlyDateKeywordFrom).getTaskParameters().getDescription());
        assertEquals(dateNow, ((AddCommand) onlyDateKeywordFrom).getTaskParameters().getStartDate());
        assertEquals(tomorrow, ((AddCommand) onlyDateKeywordFrom).getTaskParameters().getEndDate());

        //add ... from <date><time> to <date><time>
        CommandInterface dateTimeDateTime = new AddCommandParser().parse("add a lot of things from March 22 0:00:00 to May 3 8:00");
        assertEquals("a lot of things", ((AddCommand) dateTimeDateTime).getTaskParameters().getDescription());
        LocalDate mar22 = LocalDate.of(dateNow.getYear(), 3, 22);
        LocalDate may3 = LocalDate.of(dateNow.getYear(), 5, 3);
        assertEquals(mar22, ((AddCommand) dateTimeDateTime).getTaskParameters().getStartDate());
        assertEquals(may3, ((AddCommand) dateTimeDateTime).getTaskParameters().getEndDate());
        LocalTime zero = LocalTime.of(0, 0, 0);
        LocalTime eight = LocalTime.of(8, 0, 0);
        assertEquals(zero, ((AddCommand) dateTimeDateTime).getTaskParameters().getStartTime());
        assertEquals(eight, ((AddCommand) dateTimeDateTime).getTaskParameters().getEndTime());

        //add ... from <date><time> to <time>
        CommandInterface dateTimeToTime = new AddCommandParser().parse("add movie from May 9 13:00 to 15:00");
        LocalDate may9 = LocalDate.of(dateNow.getYear(), 5, 9);
        assertEquals(may9, ((AddCommand) dateTimeToTime).getTaskParameters().getStartDate());
        assertEquals(may9, ((AddCommand) dateTimeToTime).getTaskParameters().getEndDate());

        //add ... from <time> to <time>
        CommandInterface timeToTimeKeywordFrom = new AddCommandParser().parse("add movie from 13:00 to 3pm");
        LocalTime onePm = LocalTime.of(13, 0, 0);
        LocalTime threePm = LocalTime.of(15, 0);
        assertEquals(dateNow, ((AddCommand) timeToTimeKeywordFrom).getTaskParameters().getStartDate());
        assertEquals(dateNow, ((AddCommand) timeToTimeKeywordFrom).getTaskParameters().getEndDate());
        assertEquals(onePm, ((AddCommand) timeToTimeKeywordFrom).getTaskParameters().getStartTime());
        assertEquals(threePm, ((AddCommand) timeToTimeKeywordFrom).getTaskParameters().getEndTime());
    }

    /**
     * This method test description only command without time
     */
    @Test
    public void testDescriptionOnly() throws Exception {
        //add ...
        CommandInterface onlyDescription = new AddCommandParser().parse("add assignments 2");
        assertEquals("assignments 2", ((AddCommand) onlyDescription).getTaskParameters().getDescription());
    }

    /**
     * This method test misusing the keyword and wrong time
     * All the misused time string will be recognized as description
     */
    @Test
    public void testKeywordWrongFormat() throws Exception {
        CommandInterface wrongKeyword = new AddCommandParser().parse("add movie at Friday 13:00 to 15:00");
        assertEquals("movie at Friday 13:00 to 15:00", ((AddCommand) wrongKeyword).getTaskParameters().getDescription());

        CommandInterface unmatchedKeyword = new AddCommandParser().parse("add movie from Friday 13:00");
//        assertEquals("movie from Friday 13:00", ((AddCommand) unmatchedKeyword).getTaskParameters().getDescription());
        assertTrue(unmatchedKeyword instanceof InvalidCommand);
        assertEquals("Invalid Time!", unmatchedKeyword.getMessage());

        CommandInterface wrongTime = new AddCommandParser().parse("add movie from Friday 23:61");
        assertEquals("movie from Friday 23:61", ((AddCommand) wrongTime).getTaskParameters().getDescription());
    }

    /**
     * This method test invalid command which has empty tag
     */
    @Test
    public void testInvalidInput() throws Exception {
        CommandInterface invalidTag = new AddCommandParser().parse("add assignments 2 on today #tag #");
        assertTrue(invalidTag instanceof InvalidCommand);
    }
}
```
###### \ArchPlanner\test\parser\DeleteCommandParserTest.java
``` java
 * Test DeleteCommandParser
 */
public class DeleteCommandParserTest {

    /**
     * Test delete command parser
     */
    @Test
    public void testDeleteCommandParser() throws Exception {
        CommandInterface command1 = new DeleteCommandParser().parse("delete 1", 2);
        assertEquals(0, ((DeleteCommand)command1).getFirstIndex());

        CommandInterface command2 = new DeleteCommandParser().parse("delete 1343234", 100);//invalid
        assertTrue(command2 instanceof InvalidCommand);
        assertEquals("Delete index out of range!", command2.getMessage());

        CommandInterface command3 = new DeleteCommandParser().parse("delete gg", 100);//invalid
        assertTrue(command3 instanceof InvalidCommand);
        assertEquals("Invalid: ID not found", command3.getMessage());

        CommandInterface command4 = new DeleteCommandParser().parse("delete 2 to 40", 100);
        assertEquals(1, ((DeleteCommand)command4).getFirstIndex());
        assertEquals(39, ((DeleteCommand)command4).getLastIndex());

        CommandInterface command5 = new DeleteCommandParser().parse("delete 1 to 400", 100);//invalid
        assertTrue(command5 instanceof InvalidCommand);
        assertEquals("Delete index out of range!", command5.getMessage());

    }

}
```
###### \ArchPlanner\test\parser\DoneCommandParserTest.java
``` java
 * Test DoneCommandParser
 */
public class DoneCommandParserTest {
    /**
     * Test done command parser
     */
    @Test
    public void testDoneCommandParser() throws Exception {
        CommandInterface command1 = new DoneCommandParser().parse("done 1", 2);
        assertEquals(0, ((DoneCommand)command1).getFirstIndex());

        CommandInterface command2 = new DoneCommandParser().parse("done 1343234", 100);//invalid
        assertTrue(command2 instanceof InvalidCommand);
        assertEquals("Done index out of range!", command2.getMessage());

        CommandInterface command3 = new DoneCommandParser().parse("dedonelete gg", 100);//invalid
        assertTrue(command3 instanceof InvalidCommand);
        assertEquals("Invalid: ID not found", command3.getMessage());

        CommandInterface command4 = new DoneCommandParser().parse("done 2 to 40", 100);
        assertEquals(1, ((DoneCommand)command4).getFirstIndex());
        assertEquals(39, ((DoneCommand)command4).getLastIndex());

        CommandInterface command5 = new DoneCommandParser().parse("done 1 to 400", 100);//invalid
        assertTrue(command5 instanceof InvalidCommand);
        assertEquals("Done index out of range!", command5.getMessage());

    }
}
```
###### \ArchPlanner\test\parser\EditCommandParserTest.java
``` java
 * Test EditCommandParser
 */
public class EditCommandParserTest {

    /**
     * Test edit description
     */
    @Test
    public void testDescription() {
        //edit <id> description ...
        CommandInterface command1 = new EditCommandParser().parse("edit 3 description lalala", 10);
        assertEquals("lalala", ((EditCommand) command1).getTaskParameters().getDescription());

        CommandInterface command2 = new EditCommandParser().parse("edit 8 description", 10);
        assertTrue(command2 instanceof InvalidCommand);
        assertEquals("Argument Missing", command2.getMessage());

        CommandInterface command3 = new EditCommandParser().parse("edit 43 description bbb", 10);//invalid
        assertTrue(command3 instanceof InvalidCommand);
        assertEquals("Index out of range", command3.getMessage());

    }

    /**
     * Test edit start date and time
     */
    @Test
    public void testStart() throws Exception {

        //edit <id> start ...
        CommandInterface command4 = new EditCommandParser().parse("edit 1 start May 5", 10);
        LocalDate dateNow = LocalDate.now();
        LocalDate may5 = LocalDate.of(dateNow.getYear(), 5, 5);
        assertEquals(may5, ((EditCommand) command4).getTaskParameters().getStartDate());

        CommandInterface command5 = new EditCommandParser().parse("edit -1 start this friday 3pm", 10);//invalid
        assertTrue(command5 instanceof InvalidCommand);
        assertEquals("Index out of range", command5.getMessage());

        CommandInterface command6 = new EditCommandParser().parse("edit 3 start time 3pm", 10);
        assertTrue(command6 instanceof InvalidCommand);
        assertEquals("Invalid start date or time", command6.getMessage());

        CommandInterface command7 = new EditCommandParser().parse("edit 3 start 23:23:23", 10);//invalid
        LocalTime command7Time = LocalTime.of(23, 23, 23);
        assertEquals(command7Time, ((EditCommand) command7).getTaskParameters().getStartTime());
    }

    /**
     * Test edit end date and time
     */
    @Test
    public void testEnd() throws Exception {

        //edit <id> end ...
        CommandInterface command9 = new EditCommandParser().parse("edit 5 end tomorrow 1pm", 10);
        LocalDate dateNow = LocalDate.now();
        assertEquals(dateNow.plusDays(1), ((EditCommand) command9).getTaskParameters().getEndDate());
        LocalTime onePm = LocalTime.of(13, 0, 0);
        assertEquals(onePm, ((EditCommand) command9).getTaskParameters().getEndTime());

        CommandInterface command10 = new EditCommandParser().parse("edit 3 end 3pm", 10);
        LocalTime threePm = LocalTime.of(15, 0, 0);
        assertEquals(threePm, ((EditCommand) command10).getTaskParameters().getEndTime());

    }

    /**
     * Test edit tag of a task
     */
    @Test
    public void testTag() throws Exception {
        //edit <id> #tags
        CommandInterface command11 = new EditCommandParser().parse("edit 3 #a #assignments #233", 10);
        assertEquals("#a", ((EditCommand) command11).getTaskParameters().getTagsList().get(0));
        assertEquals("#assignments", ((EditCommand) command11).getTaskParameters().getTagsList().get(1));
        assertEquals("#233", ((EditCommand) command11).getTaskParameters().getTagsList().get(2));

        CommandInterface command12 = new EditCommandParser().parse("edit 3 #123 fdsf", 10);//invalid
        assertTrue(command12 instanceof InvalidCommand);

    }
}
```
###### \ArchPlanner\test\parser\SetCommandParserTest.java
``` java
 * Test SetCommandParser
 */
public class SetCommandParserTest {

    /**
     * Test set command parser
     */
    @Test
    public void testSetCommandParser() throws Exception {

        CommandInterface command1 = new SetCommandParser().parse("set filepath /usr/bin/storage");
        assertEquals("/usr/bin/storage.txt", ((SetCommand) command1).getFilePath());

        CommandInterface command2 = new SetCommandParser().parse("set filepath default");
        assertEquals(null, ((SetCommand) command2).getFilePath());

        CommandInterface command3 = new SetCommandParser().parse("set filepath default/bin/a");
        assertEquals("default/bin/a.txt", ((SetCommand) command3).getFilePath());

        CommandInterface command4 = new SetCommandParser().parse("set filepath path/to/file");
        assertEquals("path/to/file.txt", ((SetCommand) command4).getFilePath());

        CommandInterface command5 = new SetCommandParser().parse("set filep");
        assertTrue(command5 instanceof InvalidCommand);
    }
}
```
###### \ArchPlanner\test\parser\UndoneCommandParserTest.java
``` java
 * Test UndoneCommandParser
 */
public class UndoneCommandParserTest {

    /**
     * Test unUndone command parser
     */
    @Test
    public void testUndoneCommandParser() throws Exception {
        CommandInterface command1 = new UndoneCommandParser().parse("undone 1", 2);
        assertEquals(0, ((UndoneCommand) command1).getFirstIndex());

        CommandInterface command2 = new UndoneCommandParser().parse("undone 1343234", 100);//invalid
        assertTrue(command2 instanceof InvalidCommand);
        assertEquals("Undone index out of range!", command2.getMessage());

        CommandInterface command3 = new UndoneCommandParser().parse("undone gg", 100);//invalid
        assertTrue(command3 instanceof InvalidCommand);
        assertEquals("Invalid: ID not found", command3.getMessage());

        CommandInterface command4 = new UndoneCommandParser().parse("undone 2 to 40", 100);
        assertEquals(1, ((UndoneCommand) command4).getFirstIndex());
        assertEquals(39, ((UndoneCommand) command4).getLastIndex());

        CommandInterface command5 = new UndoneCommandParser().parse("undone 1 to 400", 100);//invalid
        assertTrue(command5 instanceof InvalidCommand);
        assertEquals("Undone index out of range!", command5.getMessage());

    }

}
```
###### \ArchPlanner\test\parser\ViewCommandParserTest.java
``` java
 * Test ViewCommandParser
 */
public class ViewCommandParserTest {
    ArrayList<Tag> tagArrayList;

    /**
     * Initialize tagList
     */
    @Before
    public void setUp() throws Exception {
        tagArrayList = new ArrayList<>();
        tagArrayList.add(new Tag("#a", false));
        tagArrayList.add(new Tag("#b", false));
        tagArrayList.add(new Tag("#ahhh", false));
        tagArrayList.add(new Tag("#a", false));

    }

    /**
     * Test all view type like "view all"
     */
    @Test
    public void testViewType() throws Exception {
        //view <view_type>
        CommandInterface command1 = new ViewCommandParser().parse("view all", tagArrayList);
        assertEquals(ViewCommand.VIEW_TYPE.ALL, ((ViewCommand) command1).getViewType());

        CommandInterface command2 = new ViewCommandParser().parse("view all things", tagArrayList);//invalid
        assertTrue(command2 instanceof InvalidCommand);

        CommandInterface command3 = new ViewCommandParser().parse("view done", tagArrayList);
        assertEquals(ViewCommand.VIEW_TYPE.DONE, ((ViewCommand) command3).getViewType());

        CommandInterface command4 = new ViewCommandParser().parse("view undone", tagArrayList);
        assertEquals(ViewCommand.VIEW_TYPE.UNDONE, ((ViewCommand) command4).getViewType());

        CommandInterface command5 = new ViewCommandParser().parse("view overdue", tagArrayList);
        assertEquals(ViewCommand.VIEW_TYPE.OVERDUE, ((ViewCommand) command5).getViewType());

        CommandInterface command6 = new ViewCommandParser().parse("view all done", tagArrayList);//invalid
        assertTrue(command6 instanceof InvalidCommand);

    }

    /**
     * Test view tags
     */
    @Test
    public void testTag() throws Exception {
        //view #tags
        tagArrayList.add(new Tag("#a", false));
        tagArrayList.add(new Tag("#b", false));
        tagArrayList.add(new Tag("#ahhh", false));
        tagArrayList.add(new Tag("#a", false));

        CommandInterface command7 = new ViewCommandParser().parse("view #a #b", tagArrayList);
        assertEquals("#a", ((ViewCommand) command7).getTaskParameters().getTagsList().get(0));
        assertEquals("#b", ((ViewCommand) command7).getTaskParameters().getTagsList().get(1));

        CommandInterface command8 = new ViewCommandParser().parse("view #ahhh boom", tagArrayList);//invalid
        assertTrue(command8 instanceof InvalidCommand);

        CommandInterface command9 = new ViewCommandParser().parse("view #a #c", tagArrayList);
        assertTrue(command9 instanceof InvalidCommand);
        assertEquals("Tag #c doesn't exist!", command9.getMessage());

    }

    /**
     * Test view description
     */
    @Test
    public void testDescription() throws Exception {
        //view description
        CommandInterface command10 = new ViewCommandParser().parse("view description task 1", tagArrayList);
        assertEquals("task 1", ((ViewCommand) command10).getTaskParameters().getDescription());

    }

    /**
     * Test all category type like "view tasks"
     */
    @Test
    public void testCategoryType() throws Exception {
        //view <category_type>
        CommandInterface command11 = new ViewCommandParser().parse("view task", tagArrayList);
        assertEquals("task", ((ViewCommand) command11).getTaskParameters().getDescription());

        CommandInterface command12 = new ViewCommandParser().parse("view tasks", tagArrayList);
        assertEquals(ViewCommand.CATEGORY_TYPE.TASKS, ((ViewCommand) command12)._categoryType);

        CommandInterface command13 = new ViewCommandParser().parse("view floating", tagArrayList);
        assertEquals("floating", ((ViewCommand) command13).getTaskParameters().getDescription());

        CommandInterface command14 = new ViewCommandParser().parse("view deadlines", tagArrayList);
        assertEquals(ViewCommand.CATEGORY_TYPE.DEADLINES, ((ViewCommand) command14)._categoryType);

        CommandInterface command15 = new ViewCommandParser().parse("view events", tagArrayList);
        assertEquals(ViewCommand.CATEGORY_TYPE.EVENTS, ((ViewCommand) command15)._categoryType);

    }

    /**
     * Test viewing date and time.
     * Including start date, start time, end date and end time.
     */
    @Test
    public void testDateAndTime() throws Exception {
        //view date/time
        LocalDate dateNow = LocalDate.now();
        CommandInterface command16 = new ViewCommandParser().parse("view start time 1pm", tagArrayList);
        LocalTime onePm = LocalTime.of(13, 0, 0);
        assertEquals(onePm, ((ViewCommand)command16).getTaskParameters().getStartTime());

        CommandInterface command17 = new ViewCommandParser().parse("view start time 13:00 1pm", tagArrayList);//invalid
        assertTrue(command17 instanceof InvalidCommand);

        CommandInterface command18 = new ViewCommandParser().parse("view end time 2:33", tagArrayList);
        LocalTime two33 = LocalTime.of(2, 33, 0);
        assertEquals(two33, ((ViewCommand)command18).getTaskParameters().getEndTime());

        CommandInterface command19 = new ViewCommandParser().parse("view start date Apr 19", tagArrayList);
        LocalDate apr19 = LocalDate.of(dateNow.getYear(), 4, 19);
        assertEquals(apr19, ((ViewCommand)command19).getTaskParameters().getStartDate());

        CommandInterface command20 = new ViewCommandParser().parse("view end date today", tagArrayList);
        assertEquals(dateNow, ((ViewCommand)command20).getTaskParameters().getEndDate());

        CommandInterface command21 = new ViewCommandParser().parse("view end date today 3pm", tagArrayList);//invalid
        assertTrue(command21 instanceof InvalidCommand);

        CommandInterface command22 = new ViewCommandParser().parse("view from May 4 to Aug 9", tagArrayList);
        LocalDate may4 = LocalDate.of(dateNow.getYear(), 5, 4);
        LocalDate aug9 = LocalDate.of(dateNow.getYear(), 8, 9);
        assertEquals(may4, ((ViewCommand)command22).getTaskParameters().getStartDate());
        assertEquals(aug9, ((ViewCommand)command22).getTaskParameters().getEndDate());
    }
}
```
###### \ArchPlanner\test\ParserTest.java
``` java
 * Run all parser tests
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({AddCommandParserTest.class, EditCommandParserTest.class, DeleteCommandParserTest.class,
                     DoneCommandParserTest.class, SetCommandParserTest.class, UndoneCommandParserTest.class, 
                     ViewCommandParserTest.class})
public class ParserTest {

}

```
###### \ArchPlanner\test\prompt\EditPromptTest.java
``` java
 * Test EditPrompt
 */
public class EditPromptTest {

    Prompt prompt;

    @Before
    public void setUp() throws Exception {
        prompt = new Prompt();
    }

    /**
     * Test edit command without keyword
     */
    @Test
    public void testNoKeyword() throws Exception {
        ArrayList<String> emptyKeywordPrompt = prompt.getPrompts("edit");
        assertEquals("edit <Task ID>", emptyKeywordPrompt.get(0));

        ArrayList<String> idOnlyPrompt = prompt.getPrompts("edit 3");
        assertEquals("edit <Task ID> description", idOnlyPrompt.get(0));
        assertEquals("edit <Task ID> start | end | from", idOnlyPrompt.get(1));
        assertEquals("edit <Task ID> #<Tag>", idOnlyPrompt.get(2));

        ArrayList<String> halfStartPrompt = prompt.getPrompts("edit 3 st");
        assertEquals("edit <Task ID> start", halfStartPrompt.get(0));
        assertEquals("edit <Task ID> start remove", halfStartPrompt.get(1));

        ArrayList<String> tagPrompt = prompt.getPrompts("edit 3 #tag1 #tag2 #");
        assertEquals("edit <Task ID> #<Tag> #<Tag> #<Tag>", tagPrompt.get(0));
    }

    /**
     * Test edit command with keyword description
     */
    @Test
    public void testDescription() throws Exception {
        ArrayList<String> descriptionPrompt = prompt.getPrompts("edit 3 description assignment 3");
        assertEquals("edit <Task ID> description <Description>", descriptionPrompt.get(0));

        ArrayList<String> descriptionPromptWithoutKeyword = prompt.getPrompts("edit 4 oh my god");
        assertEquals("Invalid Edit Command", descriptionPromptWithoutKeyword.get(0));
    }

    /**
     * Test edit command with keyword start
     */
    @Test
    public void testStart() throws Exception {
        ArrayList<String> startPrompt = prompt.getPrompts("edit 4 start");
        assertEquals("edit <Task ID> start <Date>", startPrompt.get(0));
        assertEquals("edit <Task ID> start <Time>", startPrompt.get(1));
        assertEquals("edit <Task ID> start <Date> <Time>", startPrompt.get(2));
        assertEquals("edit <Task ID> start remove", startPrompt.get(3));

        ArrayList<String> startDatePrompt = prompt.getPrompts("edit 4 start Mar 3");
        assertEquals("edit <Task ID> start <Date>", startDatePrompt.get(0));
        assertEquals("edit <Task ID> start <Date> <Time>", startDatePrompt.get(1));
    }

    /**
     * Test edit command with keyword end
     */
    @Test
    public void testEnd() throws Exception {
        ArrayList<String> endTime = prompt.getPrompts("edit 4 end 1pm");
        assertEquals("edit <Task ID> end <Time>", endTime.get(0));

        ArrayList<String> endRemove = prompt.getPrompts("edit 4 end rem");
        assertEquals("edit <Task ID> end remove", endRemove.get(0));
    }

    /**
     * Test edit command with keyword from
     */
    @Test
    public void testFrom() throws Exception {
        ArrayList<String> from = prompt.getPrompts("edit 6 from");
        assertEquals("edit <Task ID> from <Start Date> to <End Date>", from.get(0));
        assertEquals("edit <Task ID> from <Start Time> to <End Time>", from.get(1));
        assertEquals("edit <Task ID> from <Start Date> <Start Time> to <End Date> <End Time>", from.get(2));

        ArrayList<String> fromDateTime = prompt.getPrompts("edit 3 from May 5 1pm");
        assertEquals("edit <Task ID> from <Start Date> <Start Time> to <End Time>", fromDateTime.get(0));
        assertEquals("edit <Task ID> from <Start Date> <Start Time> to <End Date> <End Time>", fromDateTime.get(1));
    }

    /**
     * Test invalid cases
     */
    @Test
    public void testInvalid() throws Exception {
        ArrayList<String> invalidId = prompt.getPrompts("edit from May 5 1pm");
        assertEquals("Invalid ID: edit <Task ID>", invalidId.get(0));

        ArrayList<String> invalidTime = prompt.getPrompts("edit 3 start some day");
        assertEquals("Invalid Time", invalidTime.get(0));

        ArrayList<String> invalidTag = prompt.getPrompts("edit 3 #tag dfd");
        assertEquals("Invalid tag: edit <Task ID> #<Tag>", invalidTag.get(0));
    }

    /**
     * Test auto complete
     */
    @Test
    public void testAutoComplete() throws Exception {

        prompt.getPrompts("edit 3 d");
        String description = prompt.getAutoComplete("edit 3 d");
        assertEquals("edit 3 description", description);

        prompt.getPrompts("edit 3 st");
        String start = prompt.getAutoComplete("edit 3 st");
        assertEquals("edit 3 start", start);

        prompt.getPrompts("edit 3 start r");
        String startRemove = prompt.getAutoComplete("edit 3 start r");
        assertEquals("edit 3 start remove", startRemove);
    }
}
```
###### \ArchPlanner\test\prompt\IdOnlyPromptTest.java
``` java
 * Test IdOnlyPrompt
 */
public class IdOnlyPromptTest {

    Prompt prompt;

    @Before
    public void setUp() throws Exception {
        prompt = new Prompt();
    }

    /**
     * Test ID only prompt with one id only
     */
    @Test
    public void testOneId() throws Exception {
        ArrayList<String> oneId = prompt.getPrompts("delete 3");
        assertEquals("delete <Task ID>", oneId.get(0));
        assertEquals("delete <Task ID> to <Task ID>", oneId.get(1));

        ArrayList<String> oneInvalidId = prompt.getPrompts("done -3");
        assertEquals("Invalid ID: done <Task ID>", oneInvalidId.get(0));
    }

    /**
     * Test ID only prompt with two id
     */
    @Test
    public void testTwoId() throws Exception {
        ArrayList<String> twoId = prompt.getPrompts("delete 3 to 10");
        assertEquals("delete <Task ID> to <Task ID>", twoId.get(0));

        ArrayList<String> twoIdInvalid = prompt.getPrompts("undone 30 to 10");
        assertEquals("Invalid command", twoIdInvalid.get(0));
    }
}
```
###### \ArchPlanner\test\prompt\SetPromptTest.java
``` java
 * Test SetPrompt
 */
public class SetPromptTest {
    Prompt prompt;

    @Before
    public void setUp() throws Exception {
        prompt = new Prompt();
    }

    /**
     * Test set prompt
     */
    @Test
    public void testSetPrompt() throws Exception {
        ArrayList<String> emptySet = prompt.getPrompts("set");
        assertEquals("set filepath <New File Path>", emptySet.get(0));
        assertEquals("set filepath default", emptySet.get(1));

        ArrayList<String> halfDefaultSet = prompt.getPrompts("set filepath def");
        assertEquals("set filepath default", halfDefaultSet.get(0));
        assertEquals("set filepath <New File Path>", halfDefaultSet.get(1));

        ArrayList<String> pathSet = prompt.getPrompts("set filepath C:\\\\path");
        assertEquals("set filepath <New File Path>", pathSet.get(0));
    }

    @Test
    public void testAutoComplete() throws Exception {

        prompt.getPrompts("set f");
        String filepath = prompt.getAutoComplete("set f");
        assertEquals("set filepath", filepath);

        prompt.getPrompts("set filepath de");
        String defaultPath = prompt.getAutoComplete("set filepath de");
        assertEquals("set filepath default", defaultPath);
    }
}
```
###### \ArchPlanner\test\prompt\ViewPromptTest.java
``` java
 * Test ViewPrompt
 */
public class ViewPromptTest {

    Prompt prompt;

    @Before
    public void setUp() throws Exception {
        prompt = new Prompt();
    }

    /**
     * Test view prompt without keyword
     */
    @Test
    public void testNoKeyword() throws Exception {
        ArrayList<String> empty = prompt.getPrompts("view");
        assertEquals("view description <Partial Description>", empty.get(0));
        assertEquals("view events | deadlines | tasks", empty.get(1));
        assertEquals("view all | done | undone | overdue", empty.get(2));
        assertEquals("view start | end | from", empty.get(3));

        ArrayList<String> view_d = prompt.getPrompts("view d");
        assertEquals("view description <Partial Description>", view_d.get(0));
        assertEquals("view deadlines", view_d.get(1));
        assertEquals("view done", view_d.get(2));

        ArrayList<String> halfStart = prompt.getPrompts("view st");
        assertEquals("view start date <Start Date>", halfStart.get(0));
        assertEquals("view start time <Start Time>", halfStart.get(1));

        ArrayList<String> tag = prompt.getPrompts("view #t");
        assertEquals("view #<Tag>", tag.get(0));
    }

    /**
     * Test view description
     */
    @Test
    public void testDescription() throws Exception {
        ArrayList<String> description = prompt.getPrompts("view description abc");
        assertEquals("view description <Partial Description>", description.get(0));

        ArrayList<String> partialDescription = prompt.getPrompts("view abc");
        assertEquals("view <Partial Description>", partialDescription.get(0));
    }

    /**
     * Test view start date
     */
    @Test
    public void testStartDate() throws Exception {
        ArrayList<String> startDate = prompt.getPrompts("view start date today");
        assertEquals("view start date <Start Date>", startDate.get(0));

        ArrayList<String> startDateInvalid = prompt.getPrompts("view start date hdfdf");
        assertEquals("Invalid date: view start date <Start Date>", startDateInvalid.get(0));
    }

    /**
     * Test view end time
     */
    @Test
    public void testEndTime() throws Exception {
        ArrayList<String> endTime = prompt.getPrompts("view end time 1pm");
        assertEquals("view end time <End Time>", endTime.get(0));

        ArrayList<String> endTimeInvalid = prompt.getPrompts("view end time today");
        assertEquals("Invalid time: view end time <End Time>", endTimeInvalid.get(0));
    }

    /**
     * Test view types and category types
     */
    @Test
    public void testTypes() throws Exception {
        ArrayList<String> events = prompt.getPrompts("view events");
        assertEquals("view events", events.get(0));


        ArrayList<String> all = prompt.getPrompts("view all");
        assertEquals("view all", all.get(0));
    }

    /**
     * Test auto complete
     */
    @Test
    public void testAutoComplete() throws Exception {
        prompt.getPrompts("view d");
        String description = prompt.getAutoComplete("view d");
        assertEquals("view description", description);

        prompt.getPrompts("view st");
        String startDate1 = prompt.getAutoComplete("view st");
        assertEquals("view start", startDate1);

        prompt.getPrompts("view start d");
        String startDate2 = prompt.getAutoComplete("view start d");
        assertEquals("view start date", startDate2);

        prompt.getPrompts("view e");
        String events = prompt.getAutoComplete("view e");
        assertEquals("view events", events);
    }
}
```
###### \ArchPlanner\test\PromptTest.java
``` java
 * Run all prompt tests
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({CommandPromptTest.class, AddPromptTest.class, EditPromptTest.class, IdOnlyPromptTest.class, 
                     SetPromptTest.class, ViewPromptTest.class})
public class PromptTest {

}
```
